<!DOCTYPE html>
<!--
    ARTEMIS - Advanced Real-Time Embedded Metrics & Insights System
    Copyright (c) 2026 Hajime Kumami
    
    Based on APOLLO by しばやま, under MIT License.
    Original APOLLO: Copyright (c) 2025 しばやま
    https://github.com/shibayamalicht/apollo-patent-analysis
    
    This software is licensed under the MIT License.
    See LICENSE.txt for details.
-->

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ARTEMIS - PyScriptで動作するブラウザベース特許分析ツール">
    <meta name="author" content="Hajime Kumami">
    <title>ARTEMIS - 特許分析ツール</title>

    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.7/build/d3.layout.cloud.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <style>

        :root {
            --color-primary: #4fc3f7;
            --color-primary-light: #81d4fa;
            --color-primary-dark: #29b6f6;
            --color-primary-glow: rgba(79, 195, 247, 0.4);
            
            
            --color-secondary: #415a77;
            --color-secondary-light: #5a7a9a;
            
            
            --color-accent: #a855f7;
            --color-accent-light: #c084fc;
            
            
            --color-success: #22c55e;
            --color-success-light: #4ade80;
            --color-warning: #f59e0b;
            --color-warning-light: #fbbf24;
            --color-error: #ef4444;
            --color-error-light: #f87171;
            --color-danger: #dc2626;
            --color-danger-hover: #ef4444;
            
            
            --bg-primary: #0a0f1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1e293b;
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --bg-card: rgba(255, 255, 255, 0.03);
            --bg-card-hover: rgba(255, 255, 255, 0.06);
            --bg-glass: rgba(255, 255, 255, 0.05);
            --bg-input: rgba(0, 0, 0, 0.3);
            
            
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            
            
            --border-light: rgba(255, 255, 255, 0.08);
            --border-medium: rgba(255, 255, 255, 0.15);
            --border-focus: rgba(79, 195, 247, 0.5);
            
            
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Meiryo', sans-serif;
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.8125rem;
            --font-size-md: 0.875rem;
            --font-size-lg: 1rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 2rem;
            
            
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            --shadow-glow: 0 0 20px var(--color-primary-glow);
            
            
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            
            
            --sidebar-width: 200px;
            --header-height: 56px;
        }

        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            background-image: 
                radial-gradient(ellipse at 20% 0%, rgba(79, 195, 247, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(168, 85, 247, 0.06) 0%, transparent 50%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        
        .header {
            background: rgba(10, 15, 26, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 0 var(--spacing-lg);
            height: var(--header-height);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            border-bottom: 1px solid var(--border-light);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .badge {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: #000;
            padding: 0.2rem 0.6rem;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-xs);
            font-weight: 600;
        }

        .container {
            display: flex;
            min-height: calc(100vh - var(--header-height));
        }

        
        .sidebar {
            width: 200px;
            background: rgba(0, 0, 0, 0.4);
            padding: 0.5rem;
            border-right: 1px solid var(--border-light);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.3rem;
        }

        .sidebar h3 {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
            padding-left: 0.5rem;
            white-space: nowrap;
        }

        .nav-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            height: 44px;
            padding: 0 var(--spacing-md);
            margin-bottom: 0;
            background: transparent;
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.1rem;
            transition: all var(--transition-fast);
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 0;
            background: var(--color-primary);
            border-radius: 0 2px 2px 0;
            transition: height var(--transition-fast);
        }

        .nav-btn .nav-label {
            font-size: var(--font-size-sm);
            font-weight: 500;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .nav-btn:hover::before {
            height: 24px;
        }

        .nav-btn.active {
            background: rgba(79, 195, 247, 0.1);
            color: var(--color-primary);
            font-weight: 600;
        }

        .nav-btn.active::before {
            height: 28px;
            background: linear-gradient(180deg, var(--color-primary) 0%, var(--color-accent) 100%);
        }

        .nav-divider {
            width: calc(100% - 1rem);
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-light), transparent);
            margin: 0.75rem auto;
        }

        
        .module-status {
            margin-top: auto;
            padding: var(--spacing-sm);
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-md);
        }

        .module-status-item {
            display: flex;
            justify-content: space-between;
            gap: 0.4rem;
            padding: 0.15rem 0.3rem;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .module-progress {
            height: 2px;
            margin: 0.1rem 0.3rem 0.3rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            overflow: hidden;
        }

        
        .main {
            flex: 1;
            padding: var(--spacing-lg);
            overflow-y: auto;
            background: transparent;
        }

        .card {
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            transition: all var(--transition-normal);
        }

        .card:hover {
            border-color: var(--border-medium);
            box-shadow: var(--shadow-md);
        }

        .card h2 {
            font-size: var(--font-size-lg);
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--border-light);
            color: var(--text-primary);
        }

        
        .tabs {
            display: flex;
            gap: 0.25rem;
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.3rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }

        .tab-btn {
            padding: 0.6rem var(--spacing-md);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            color: var(--text-muted);
            cursor: pointer;
            font-size: var(--font-size-sm);
            font-weight: 500;
            transition: all var(--transition-fast);
            position: relative;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab-btn.active {
            background: rgba(79, 195, 247, 0.15);
            color: var(--color-primary);
            font-weight: 600;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        
        input[type="file"] {
            width: 100%;
            padding: var(--spacing-lg);
            background: rgba(0, 0, 0, 0.2);
            border: 2px dashed var(--border-medium);
            border-radius: var(--radius-lg);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        input[type="file"]:hover {
            border-color: var(--color-primary);
            background: rgba(79, 195, 247, 0.05);
        }

        select,
        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 0.65rem 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-md);
            transition: all var(--transition-fast);
        }

        
        select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.5rem;
        }

        select option:checked,
        select option:hover {
            background: var(--bg-tertiary);
            color: #ffffff;
        }

        
        select:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px var(--color-primary-glow);
        }

        
        select:disabled,
        input:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.3);
        }

        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.7rem 1.4rem;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            border: none;
            border-radius: var(--radius-md);
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: var(--font-size-md);
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: var(--bg-tertiary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:disabled::before {
            display: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
            padding: 0.6rem 1rem;
            border: 1px solid var(--border-light);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: var(--border-medium);
            box-shadow: var(--shadow-md);
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: var(--font-size-xs);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--color-error) 0%, var(--color-danger) 100%);
            color: #fff;
        }

        .btn-danger:hover {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }

        
        .btn.loading {
            pointer-events: none;
            opacity: 0.85;
        }

        .btn.loading::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: btn-spinner 0.8s linear infinite;
        }

        .btn.loading .btn-text {
            opacity: 0;
        }

        @keyframes btn-spinner {
            to { transform: rotate(360deg); }
        }

        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spinner-rotate 0.8s linear infinite;
        }

        .spinner-lg {
            width: 40px;
            height: 40px;
            border-width: 3px;
        }

        @keyframes spinner-rotate {
            to { transform: rotate(360deg); }
        }

        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-overlay .spinner-text {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-4 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: var(--spacing-md);
        }

        
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-group label {
            display: block;
            margin-bottom: 0.4rem;
            font-size: var(--font-size-sm);
            font-weight: 500;
            color: var(--text-secondary);
        }

        
        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            min-height: 400px;
            position: relative;
        }

        .data-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: var(--font-size-sm);
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem var(--spacing-md);
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }

        .data-table th {
            background: rgba(79, 195, 247, 0.1);
            color: var(--color-primary);
            font-weight: 600;
            position: sticky;
            top: 0;
            backdrop-filter: blur(10px);
        }

        .data-table tr {
            transition: background var(--transition-fast);
        }

        .data-table tr:hover {
            background: rgba(79, 195, 247, 0.05);
        }

        .data-table td {
            color: var(--text-primary);
        }

        
        .hidden {
            display: none !important;
        }

        
        #init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(ellipse at 30% 20%, rgba(79, 195, 247, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(168, 85, 247, 0.1) 0%, transparent 50%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #init-overlay h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-light);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: var(--spacing-lg);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .metrics {
            display: flex;
            gap: var(--spacing-md);
            margin: var(--spacing-md) 0;
            flex-wrap: wrap;
        }

        .metric {
            flex: 1;
            min-width: 100px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-light);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            text-align: center;
            transition: all var(--transition-normal);
        }

        .metric:hover {
            transform: translateY(-2px);
            border-color: rgba(79, 195, 247, 0.3);
            box-shadow: var(--shadow-md);
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-label {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        
        .status-ok {
            color: var(--color-success);
        }

        .status-err {
            color: var(--color-error);
        }

        .status-warn {
            color: var(--color-warning);
        }

        
        .status-message {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 1.25rem;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            animation: status-fade-in 0.3s ease-out;
        }

        @keyframes status-fade-in {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--color-error-light);
        }

        .status-message.warning {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--color-warning-light);
        }

        .status-message.success {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: var(--color-success-light);
        }

        .status-message.info {
            background: rgba(79, 195, 247, 0.15);
            border: 1px solid rgba(79, 195, 247, 0.3);
            color: var(--color-primary-light);
        }

        .status-message .status-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .status-message .status-content {
            flex: 1;
        }

        .status-message .status-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .status-message .status-detail {
            opacity: 0.85;
            font-size: var(--font-size-xs);
        }

        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%);
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .checkbox-group { 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            margin: 0.5rem 0; 
        }

        .checkbox-group input[type="checkbox"] { 
            width: 18px; 
            height: 18px; 
            accent-color: var(--color-primary);
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            user-select: none;
        }

        .status-toggle-row { 
            display: flex; 
            align-items: center; 
            gap: 0.6rem; 
            margin: 0.4rem 0 0.8rem; 
        }

        
        textarea {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            font-family: var(--font-family);
            resize: vertical;
            min-height: 80px;
            transition: all var(--transition-fast);
        }

        textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px var(--color-primary-glow);
        }

        
        ::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }

        
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(79, 195, 247, 0.4) 0%, rgba(168, 85, 247, 0.3) 100%);
            border-radius: 5px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(79, 195, 247, 0.6) 0%, rgba(168, 85, 247, 0.5) 100%);
        }

        
        a {
            color: var(--color-primary);
            text-decoration: none;
            transition: color var(--transition-fast);
        }

        a:hover {
            color: var(--color-primary-light);
        }

        .bg-progress { 
            width: 240px; 
            height: 8px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 4px; 
            overflow: hidden; 
            margin: 0.4rem auto 0.2rem; 
        }

        .bg-progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%); 
            width: 0%; 
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        .bg-module-list { 
            margin-top: 0.4rem; 
            font-size: 0.72rem; 
            opacity: 0.75; 
            text-align: left; 
            display: inline-block; 
        }

        .bg-module-item { 
            display: flex; 
            gap: 0.6rem; 
            justify-content: space-between; 
            min-width: 220px; 
        }

        .bg-module-state { opacity: 0.8; }

        .module-status { 
            margin-top: 0.6rem; 
            font-size: 0.72rem; 
            opacity: 0.8;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
        }

        .module-status-item { 
            display: flex; 
            justify-content: space-between; 
            gap: 0.6rem; 
            padding: 0.15rem 0; 
        }

        .module-status-state { opacity: 0.9; }

        .module-progress { 
            width: 100%; 
            height: 6px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 3px; 
            overflow: hidden; 
            margin: 0.15rem 0 0.4rem; 
        }

        .module-progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%); 
            width: 0%; 
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        
        .module-progress-fill.indeterminate {
            width: 30%;
            animation: module-loading 1.5s ease-in-out infinite;
        }
        
        @keyframes module-loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }

        
        .toast-container {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toast {
            background: rgba(27, 38, 59, 0.98);
            border: 1px solid var(--border-light);
            border-left: 4px solid var(--color-primary);
            border-radius: var(--radius-lg);
            padding: 1rem 1.25rem;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            animation: toast-slide-in 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            max-width: 420px;
        }

        .toast.toast-success { 
            border-left-color: var(--color-success); 
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.1) 0%, rgba(27, 38, 59, 0.98) 20%);
        }
        .toast.toast-warning { 
            border-left-color: var(--color-warning); 
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.1) 0%, rgba(27, 38, 59, 0.98) 20%);
        }
        .toast.toast-error { 
            border-left-color: var(--color-error); 
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.1) 0%, rgba(27, 38, 59, 0.98) 20%);
        }

        .toast-icon { 
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .toast-message { 
            flex: 1;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.1rem;
            padding: 0.25rem;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .toast-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
        }

        @keyframes toast-slide-in {
            from {
                transform: translateX(120%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        
        #drop-zone {
            border: 2px dashed var(--border-medium);
            border-radius: var(--radius-xl);
            padding: 3rem;
            text-align: center;
            transition: all var(--transition-normal);
            cursor: pointer;
            background: rgba(0, 0, 0, 0.2);
        }

        #drop-zone:hover {
            border-color: var(--color-primary);
            background: rgba(79, 195, 247, 0.08);
            transform: scale(1.01);
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.15);
        }

        #drop-zone.drag-over {
            border-color: var(--color-primary);
            background: rgba(79, 195, 247, 0.15);
            transform: scale(1.02);
            box-shadow: 0 0 40px rgba(79, 195, 247, 0.25);
        }

        #drop-zone .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
            transition: all var(--transition-normal);
        }

        #drop-zone:hover .upload-icon {
            transform: translateY(-5px);
            opacity: 1;
        }

        
        .dashboard-card {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            transition: all var(--transition-normal);
            backdrop-filter: blur(10px);
        }

        .dashboard-card:hover {
            border-color: rgba(79, 195, 247, 0.3);
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 1.25em;
            background: linear-gradient(180deg, var(--color-primary) 0%, var(--color-accent) 100%);
            border-radius: 2px;
        }

        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: var(--font-size-base);
            max-width: 300px;
        }

        
        @media (max-width: 1200px) {
            .sidebar {
                width: 160px;
            }
            .nav-btn {
                height: 38px;
                font-size: 1rem;
            }
            .nav-btn .nav-label {
                font-size: 0.75rem;
            }
        }

        @media (max-width: 900px) {
            .sidebar {
                width: 56px;
            }
            .nav-btn {
                justify-content: center;
                padding: 0;
            }
            .nav-btn .nav-label {
                display: none !important;
            }
            .sidebar .module-status {
                display: none;
            }
            .sidebar h3 {
                display: none;
            }
        }

        
        .wc-tooltip,
        .network-tooltip,
        .sankey-tooltip,
        .circle-tooltip {
            position: absolute !important;
            background: rgba(13, 17, 23, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            color: var(--text-primary) !important;
            padding: 12px 16px !important;
            border-radius: var(--radius-lg) !important;
            font-size: 0.85rem !important;
            font-family: var(--font-family) !important;
            pointer-events: none !important;
            box-shadow: var(--shadow-xl) !important;
            border: 1px solid var(--border-light) !important;
            z-index: 10000 !important;
            animation: tooltip-fade-in 0.15s ease;
        }

        @keyframes tooltip-fade-in {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        
        .kbd {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            font-size: 0.7rem;
            font-family: var(--font-mono);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            color: var(--text-secondary);
        }

        
        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        .fade-out {
            animation: fadeOut 0.3s ease forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        
        .skeleton {
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.05) 0%,
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.05) 100%
            );
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s ease-in-out infinite;
            border-radius: var(--radius-md);
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        
        .hover-lift {
            transition: transform var(--transition-normal), box-shadow var(--transition-normal);
        }

        .hover-lift:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        
        .glow-primary {
            box-shadow: 0 0 20px var(--color-primary-glow);
        }

        .glow-accent {
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
        }

        
        #init-overlay .init-subtitle {
            font-size: 0.9rem;
            color: var(--color-primary);
            margin-top: 0.5rem;
            font-weight: 500;
        }

        #init-overlay .init-detail {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 0.3rem;
        }

        #init-overlay .init-hint {
            font-size: 0.8rem;
            opacity: 0.5;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div id="init-overlay">
        <h1>ARTEMIS</h1>
        <div class="spinner"></div>
        <p id="init-status" style="font-size: 1rem; margin-top: 0.5rem;">Python環境初期化中...</p>
        <p id="init-elapsed" class="init-subtitle">経過時間: 0秒</p>
        <p id="init-detail" class="init-detail">Pyodide + pandas + numpy をダウンロード中</p>
        <p class="init-hint">最小構成で起動中。重いモジュールはバックグラウンドで読み込み</p>
        <p id="bg-load-status" style="font-size: 0.75rem; opacity: 0.5; margin-top: 0.4rem;">追加モジュール: 未ロード</p>
        <div class="bg-progress"><div id="bg-load-progress-fill" class="bg-progress-fill"></div></div>
        <div id="bg-load-detail" class="bg-module-list"></div>
    </div>

    <div class="header">
        <h1>ARTEMIS</h1>
        <span id="py-status" style="margin-left: 0.6rem; font-size: 0.75rem; opacity: 0.6; font-weight: 400;">Engine loading…</span>
        <span id="file-info" style="margin-left: auto; font-size: 0.8rem; opacity: 0.8; font-weight: 500; background: rgba(79, 195, 247, 0.1); padding: 0.3rem 0.8rem; border-radius: 20px;">データ未読込</span>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <button class="nav-btn active" onclick="showPage('home')" title="ダッシュボード"><span class="nav-label">ダッシュボード</span></button>
            <button class="nav-btn" onclick="showPage('mission')" title="前処理"><span class="nav-label">前処理</span></button>
            <div class="nav-divider"></div>
            <button class="nav-btn" onclick="showPage('atlas')" title="統計チャート"><span class="nav-label">統計チャート</span></button>
            <button class="nav-btn" onclick="showPage('core')" title="論理分類"><span class="nav-label">論理分類</span></button>
            <button class="nav-btn" onclick="showPage('mega')" title="テキスト分析"><span class="nav-label">テキスト分析</span></button>
            <button class="nav-btn" onclick="showPage('saturn')" title="技術マップ"><span class="nav-label">技術マップ</span></button>
            <button class="nav-btn" onclick="showPage('explorer')" title="キーワード"><span class="nav-label">キーワード</span></button>
            <button class="nav-btn" onclick="showPage('crew')" title="ネットワーク"><span class="nav-label">ネットワーク</span></button>
            <button class="nav-btn" onclick="showPage('advanced')" title="アドバンスト"><span class="nav-label">アドバンスト</span></button>
            <div class="nav-divider"></div>
            <button class="nav-btn" onclick="showPage('export')" title="エクスポート"><span class="nav-label">エクスポート</span></button>
            <div class="module-status">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.3rem;">
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-core-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">分析</span>
                    </div>
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-mega-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">テキスト</span>
                    </div>
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-saturn-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">マップ</span>
                    </div>
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-explorer-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">キーワード</span>
                    </div>
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-crew-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">ネットワーク</span>
                    </div>
                    <div class="module-status-item" style="flex-direction: column; align-items: center; padding: 0.2rem;">
                        <span id="mod-export-status" style="font-size: 0.7rem; color: var(--color-primary);">0%</span>
                        <span style="font-size: 0.55rem;">出力</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main">
            
            <div id="page-home" class="page">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                    
                    <div class="dashboard-card" style="grid-row: span 2;">
                        <div class="section-title">データを読み込む</div>
                        <div id="drop-zone" onclick="document.getElementById('file-input-home').click()">
                            <div class="upload-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><polyline points="9 15 12 12 15 15"/></svg></div>
                            <div style="font-size: 1.1rem; color: var(--color-primary); margin-bottom: 0.5rem;">CSVファイルをドロップ</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">また クリックして選択</div>
                            <input type="file" id="file-input-home" accept=".csv" style="display: none;">
                        </div>
                        <div id="home-file-status" style="margin-top: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;"></div>
                        
                        
                        <div style="margin-top: 1.5rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                            <button class="btn btn-secondary" onclick="showPage('mission')">詳細設定</button>
                            <button class="btn" id="home-launch-btn" disabled onclick="quickLaunch()">分析を開始</button>
                        </div>
                    </div>
                    
                    
                    <div class="dashboard-card">
                        <div class="section-title">データサマリー</div>
                        <div id="home-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                            <div class="metric hover-lift">
                                <div class="metric-value" id="home-stat-total">-</div>
                                <div class="metric-label">総件数</div>
                            </div>
                            <div class="metric hover-lift">
                                <div class="metric-value" id="home-stat-years">-</div>
                                <div class="metric-label">期間</div>
                            </div>
                            <div class="metric hover-lift">
                                <div class="metric-value" id="home-stat-applicants">-</div>
                                <div class="metric-label">出願人</div>
                            </div>
                        </div>
                    </div>
                    
                    
                    <div class="dashboard-card">
                        <div class="section-title">クイックアクセス</div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem;">
                            <button class="btn btn-secondary hover-lift" onclick="showPage('atlas'); setAtlasChart('trend');">件数推移を表示</button>
                            <button class="btn btn-secondary hover-lift" onclick="showPage('atlas'); setAtlasChart('applicant');">出願人ランキング</button>
                            <button class="btn btn-secondary hover-lift" onclick="showPage('mega'); showTab('mega', 'wordcloud');">ワードクラウド</button>
                            <button class="btn btn-secondary hover-lift" onclick="showPage('crew');">共起ネットワーク</button>
                        </div>
                    </div>
                </div>
                
                
                <div class="dashboard-card" style="margin-top: 1.5rem;">
                    <div class="section-title">データ分析プレビュー</div>
                    <div id="home-preview-container" class="empty-state" style="min-height: 280px;">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3v18h18"/><path d="M18 9l-5 5-4-4-3 3"/></svg></div>
                        <div class="empty-state-text">データを読み込むとリアルタイム分析が表示されます</div>
                    </div>
                    
                    <div id="home-preview-grid" class="hidden" style="display: none;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            
                            <div style="background: rgba(0,0,0,0.2); border-radius: 12px; padding: 1rem;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">年次推移</div>
                                <div id="preview-trend" style="height: 140px;"></div>
                            </div>
                            
                            <div style="background: rgba(0,0,0,0.2); border-radius: 12px; padding: 1rem;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">Top 出願人</div>
                                <div style="display: flex; align-items: center; gap: 0.5rem; height: 140px;">
                                    <div id="preview-applicants" style="flex: 0 0 100px; height: 100px;"></div>
                                    <div id="preview-applicants-legend" style="flex: 1; font-size: 0.7rem; overflow: hidden;"></div>
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            
                            <div style="background: rgba(0,0,0,0.2); border-radius: 12px; padding: 1rem;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">IPC分布</div>
                                <div id="preview-ipc" style="height: 100px;"></div>
                            </div>
                            
                            <div style="background: rgba(0,0,0,0.2); border-radius: 12px; padding: 1rem;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">キーワード</div>
                                <div id="preview-keywords" style="height: 100px; position: relative; overflow: hidden;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            
            <div id="page-mission" class="page hidden">
                <div class="card">
                    <h2>前処理</h2>
                    <div class="tabs">
                        <button class="tab-btn active" onclick="showTab('mission', 'import')">インポート</button>
                        <button class="tab-btn" onclick="showTab('mission', 'columns')">カラム設定</button>
                        <button class="tab-btn" onclick="showTab('mission', 'launch')">起動</button>
                    </div>
                    
                    <div id="mission-tab-import" class="tab-content active">
                        <p style="margin-bottom: 0.8rem; font-size: 0.9rem;">CSVファイルをアップロードしてください。</p>
                        <input type="file" id="file-input" accept=".csv">
                        <div id="preview-area" style="margin-top: 0.8rem;"></div>
                    </div>
                    
                    <div id="mission-tab-columns" class="tab-content">
                        <div class="grid-2">
                            <div class="form-group">
                                <label>タイトル</label>
                                <select id="col-title"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>要約</label>
                                <select id="col-abstract"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>出願日</label>
                                <select id="col-date"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>出願人</label>
                                <select id="col-applicant"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>IPC</label>
                                <select id="col-ipc"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>発明者</label>
                                <select id="col-inventor"><option>(未選択)</option></select>
                            </div>
                            <div class="form-group">
                                <label>ステータス色分け用</label>
                                <select id="col-status"><option>(未選択)</option></select>
                            </div>
                        </div>
                    </div>
                    
                    <div id="mission-tab-launch" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.9rem;">分析エンジンを起動して前処理を実行します。</p>
                        <button id="btn-launch" class="btn" style="width: 100%;">分析エンジンを起動</button>
                        <div class="progress-bar" style="display: none;" id="launch-progress">
                            <div class="progress-fill" id="launch-progress-fill" style="width: 0%;"></div>
                        </div>
                        <div id="launch-status" style="margin-top: 0.8rem;"></div>
                    </div>
                </div>
            </div>
            
            
            <div id="page-atlas" class="page hidden">
                <div class="card">
                    <h2>統計チャート</h2>
                    <div class="grid-4" style="margin-bottom: 0.8rem;">
                        <div class="form-group">
                            <label>開始年</label>
                            <input type="number" id="year-start" value="2000">
                        </div>
                        <div class="form-group">
                            <label>終了</label>
                            <input type="number" id="year-end" value="2025">
                        </div>
                        <div class="form-group">
                            <label>TOP N</label>
                            <input type="number" id="top-n" value="15" min="5" max="50">
                        </div>
                        <div class="form-group">
                            <label style="visibility: hidden;">_</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="use-status-breakdown">
                                <label for="use-status-breakdown" style="color: #e0e1dd;">ステータス別を表示</label>
                            </div>
                        </div>
                    </div>
                    <div class="tabs">
                        <button class="tab-btn active" onclick="setAtlasChart('trend')">件数推移</button>
                        <button class="tab-btn" onclick="setAtlasChart('trend_line')">折れ線</button>
                        <button class="tab-btn" onclick="setAtlasChart('applicant')">出願人</button>
                        <button class="tab-btn" onclick="setAtlasChart('ipc')">IPC</button>
                        <button class="tab-btn" onclick="setAtlasChart('bubble')">出願人×年</button>
                        <button class="tab-btn" onclick="setAtlasChart('ipc_applicant')">IPC×出願人</button>
                        <button class="tab-btn" onclick="setAtlasChart('treemap')">Treemap</button>
                        <button class="tab-btn" onclick="setAtlasChart('lifecycle')">ライフサイクル</button>
                    </div>
                    <div id="atlas-status-toggle-row" class="status-toggle-row"></div>
                    <div id="atlas-control-applicant" class="grid-2" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>表示人数</label>
                            <input type="number" id="atlas-applicant-count" value="20" min="1" max="50">
                        </div>
                    </div>
                    <div id="atlas-control-ipc" class="grid-3" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>IPCレベル</label>
                            <select id="atlas-ipc-level">
                                <option value="1">サブクラス (A01B)</option>
                                <option value="2">メイングループ (A01B 1/00)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>表示IPC数</label>
                            <input type="number" id="atlas-ipc-count" value="20" min="1" max="50">
                        </div>
                    </div>
                    <div id="atlas-control-bubble" class="grid-2" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>表示人数</label>
                            <input type="number" id="atlas-bubble-count" value="10" min="1" max="30">
                        </div>
                    </div>
                    <div id="atlas-control-ipc-applicant" class="grid-3" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>IPCレベル</label>
                            <select id="atlas-ipcapp-level">
                                <option value="1">サブクラス</option>
                                <option value="2">メイングループ</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>IPC数 (Y軸)</label>
                            <input type="number" id="atlas-ipcapp-ipc-count" value="15" min="1" max="50">
                        </div>
                        <div class="form-group">
                            <label>出願人数 (X軸)</label>
                            <input type="number" id="atlas-ipcapp-app-count" value="15" min="1" max="50">
                        </div>
                    </div>
                    <div id="atlas-control-treemap" class="grid-2" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>表示モード</label>
                            <select id="atlas-treemap-mode">
                                <option value="ipc">IPC階層 (技術分野)</option>
                                <option value="applicant">出願人シェア</option>
                            </select>
                        </div>
                    </div>
                    <div id="atlas-line-controls" class="grid-2" style="margin: 0.5rem 0; display: none;">
                        <div class="form-group">
                            <label>表示モード</label>
                            <select id="atlas-line-mode">
                                <option value="overall">全体推移</option>
                                <option value="compare">出願人比較</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>出願人最大5社</label>
                            <select id="atlas-line-applicants" multiple style="height: 110px;"></select>
                        </div>
                    </div>
                    <button id="btn-atlas" class="btn" style="margin: 0.5rem 0;">チャートを描画</button>
                    <div id="atlas-chart" class="chart-container"></div>
                    <button class="btn btn-secondary" onclick="saveSnapshot('atlas-chart', '統計チャート')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                </div>
            </div>
            
            
            <div id="page-core" class="page hidden">
                <div class="card">
                    <h2>論理分類</h2>
                    <div class="form-group">
                        <label>フェーズ選択</label>
                        <select id="core-phase">
                            <option value="phase1">フェーズ 1: AIアシスタント(KMeans)</option>
                            <option value="phase2">フェーズ 2: 分類ルール定義</option>
                            <option value="phase3">フェーズ 3: 分類実行</option>
                            <option value="phase4" selected>フェーズ 4: 特許マップ作成</option>
                        </select>
                    </div>

                    <div id="core-phase1" class="core-phase" style="display:none;">
                        <div class="form-group">
                            <label>分析対象カラム</label>
                            <select id="core-ai-target">
                                <option value="text">タイトル+要約</option>
                            </select>
                        </div>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>トピック数 (K)</label>
                                <input type="number" id="core-ai-k" value="8" min="2" max="20">
                            </div>
                            <div class="form-group">
                                <label>サンプル数 (N)</label>
                                <input type="number" id="core-ai-n" value="5" min="1" max="20">
                            </div>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="core-ai-mece" checked>
                            <label for="core-ai-mece" style="color: #e0e1dd;">MECEモード（自動決定）</label>
                        </div>
                        <button class="btn" id="btn-core-ai" style="margin-top:0.5rem;">🧠 AIアシスタント用プロンプト生成</button>
                        <div id="core-ai-output" style="margin-top:0.8rem;"></div>
                    </div>

                    <div id="core-phase2" class="core-phase" style="display:none;">
                        <div class="grid-2" style="margin-bottom:0.6rem;">
                            <div class="form-group">
                                <label>軸の名称</label>
                                <select id="core-axis-mode">
                                    <option value="new">新規作</option>
                                    <option value="existing" selected>既存に追加</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>追加/修正先軸</label>
                                <select id="core-axis-select"></select>
                            </div>
                        </div>
                        <div class="grid-3">
                            <div class="form-group">
                                <label>新規軸名</label>
                                <input type="text" id="core-axis-new" placeholder="例: 課題軸">
                            </div>
                            <div class="form-group">
                                <label>分類名</label>
                                <input type="text" id="core-cat-name" placeholder="例: 耐久性向上">
                            </div>
                            <div class="form-group">
                                <label>論理式</label>
                                <input type="text" id="core-cat-rule" placeholder="(耐久 + 寿命) * 向上">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>定義</label>
                            <textarea id="core-cat-def" rows="2"></textarea>
                        </div>
                        <button class="btn" id="btn-core-add">➕ ルールを追加</button>
                        <button class="btn" id="btn-core-update" style="display:none; margin-left:0.4rem;">✏️ ルールを更新</button>
                        <button class="btn" id="btn-core-cancel" style="display:none; margin-left:0.4rem;">❌ 編集キャンセル</button>
                        <div id="core-rule-list" style="margin-top:0.8rem;"></div>
                        <div class="form-group">
                            <label>JSON一括インポート</label>
                            <textarea id="core-json" rows="8" placeholder="AIが生成したJSONを貼り付け"></textarea>
                        </div>
                        <button class="btn" id="btn-core-import">JSONをインポート</button>
                        <div id="core-rule-status" style="margin-top:0.8rem;"></div>
                    </div>

                    <div id="core-phase3" class="core-phase" style="display:none;">
                        <p style="color:#9fb3c8;">探索対象は「タイトル+要約」結合テキストです。</p>
                        <button class="btn" id="btn-core-run">▶ すべての分類を実行</button>
                        <div id="core-run-status" style="margin-top:0.8rem;"></div>
                        <div id="core-summary" style="margin-top:0.8rem;"></div>
                        <div style="margin-top:0.8rem;">
                            <label>分類結果CSVコピー用</label>
                            <textarea id="core-csv" rows="6" readonly></textarea>
                        </div>
                        <div class="grid-2" style="margin-top:0.8rem;">
                            <div class="form-group">
                                <label>再分析する軸</label>
                                <select id="core-reanalyze-axis"></select>
                            </div>
                            <div class="form-group">
                                <label>抽出トピック数 (K)</label>
                                <input type="number" id="core-reanalyze-k" value="5" min="1" max="10">
                            </div>
                            <div class="form-group">
                                <label>サンプル数 (N)</label>
                                <input type="number" id="core-reanalyze-n" value="3" min="1" max="10">
                            </div>
                        </div>
                        <div class="checkbox-group" style="margin-top:0.4rem;">
                            <input type="checkbox" id="core-reanalyze-mece" checked>
                            <label for="core-reanalyze-mece" style="color:#e0e1dd;">MECEモード（自動決定）</label>
                        </div>
                        <button class="btn" id="btn-core-reanalyze" style="margin-top:0.6rem;">🔁 『その他』を再分析</button>
                        <div id="core-reanalyze-output" style="margin-top:0.8rem;"></div>
                    </div>

                    <div id="core-phase4" class="core-phase">
                        <div class="grid-3">
                            <div class="form-group">
                                <label>X軸</label>
                                <select id="core-x-axis"></select>
                            </div>
                            <div class="form-group">
                                <label>Y軸</label>
                                <select id="core-y-axis"></select>
                            </div>
                            <div class="form-group">
                                <label>グラフタイプ</label>
                                <select id="core-map-type">
                                    <option value="heatmap">ヒートマップ</option>
                                    <option value="bubble">バブルチャート</option>
                                </select>
                            </div>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="core-exclude-other" checked>
                            <label for="core-exclude-other" style="color:#e0e1dd;">「その他」を除外する</label>
                        </div>
                        <button id="btn-core-map" class="btn">特許マップを描画</button>
                        <div id="core-map" class="chart-container" style="margin-top:0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('core-map', '論理分類')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                        <hr style="margin:1rem 0; border-color:#2b3a4a;">
                        <div class="form-group">
                            <label>検索クエリ（AND, OR, NOT, nearN, adjN対応）</label>
                            <input type="text" id="core-query" placeholder="例: (電池 + セル) * (リチウム + ナトリウム)">
                        </div>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>検索対象</label>
                                <select id="core-target">
                                    <option value="all">タイトル+要約</option>
                                    <option value="title">タイトルのみ</option>
                                    <option value="abstract">要約のみ</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>最大結果数</label>
                                <input type="number" id="core-limit" value="100" min="10" max="500">
                            </div>
                        </div>
                        <button id="btn-core-search" class="btn">検索を実行</button>
                        <div id="core-results" style="margin-top: 0.8rem;"></div>
                    </div>
                </div>
            </div>
            
            
            <div id="page-saturn" class="page hidden">
                <div class="card">
                    <h2>技術マップ</h2>
                    <div class="grid-3" style="margin-bottom: 0.8rem;">
                        <div class="form-group">
                            <label>クラスタ数</label>
                            <input type="number" id="n-clusters" value="8" min="3" max="20">
                        </div>
                        <div class="form-group">
                            <label>サンプル数 (0=全件)</label>
                            <input type="number" id="sample-size" value="500" min="0" step="100">
                        </div>
                        <div class="form-group">
                            <label>次元削減</label>
                            <select id="dim-method">
                                <option value="pca">PCA</option>
                                <option value="svd">TruncatedSVD</option>
                                <option value="tsne">t-SNE</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid-3" style="margin-bottom: 0.8rem;">
                        <div class="checkbox-group">
                            <input type="checkbox" id="saturn-contour" checked>
                            <label for="saturn-contour" style="color: #e0e1dd;">等高線表示</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="saturn-hull">
                            <label for="saturn-hull" style="color: #e0e1dd;">クラスタ境界</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="saturn-labels" checked>
                            <label for="saturn-labels" style="color: #e0e1dd;">ラベル表示</label>
                        </div>
                    </div>
                    <button id="btn-saturn" class="btn" style="width: 100%;">マップを生成</button>
                    <div id="saturn-status" style="margin-top: 0.5rem;"></div>
                    <div id="saturn-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                    <button class="btn btn-secondary" onclick="saveSnapshot('saturn-chart', '技術マップ')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    <div id="saturn-summary" style="margin-top: 0.8rem;"></div>
                </div>
            </div>
            
            
            <div id="page-explorer" class="page hidden">
                <div class="card">
                    <h2>キーワード分析</h2>
                    <div class="tabs">
                        <button class="tab-btn active" onclick="showTab('explorer', 'ranking')">ランキング</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'trend')">トレンド</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'compare')">企業比較</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'heatmap')">ヒートマップ</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'emerging')">急上昇ワード</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'kwic')">KWIC検索</button>
                        <button class="tab-btn" onclick="showTab('explorer', 'stream')">ストリームグラフ</button>
                    </div>
                    
                    <div id="explorer-tab-ranking" class="tab-content active">
                        <div class="form-group">
                            <label>TOP N</label>
                            <input type="number" id="keyword-top" value="30" min="10" max="100">
                        </div>
                        <button id="btn-keyword" class="btn">ランキングを分析</button>
                        <div id="keyword-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('keyword-chart', 'キーワードランキング')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="explorer-tab-trend" class="tab-content">
                        <div class="form-group">
                            <label>キーワード（カンマ区切り）</label>
                            <input type="text" id="trend-keywords" placeholder="例: AI, 機械学習, ディープラーニング">
                        </div>
                        <button id="btn-trend" class="btn">トレンドを分析</button>
                        <div id="trend-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('trend-chart', 'トレンド')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="explorer-tab-compare" class="tab-content">
                        <div class="form-group">
                            <label>比較する企業・出願人</label>
                            <select id="compare-companies" multiple size="5" style="height: auto;"></select>
                        </div>
                        <button id="btn-compare" class="btn">比較実行</button>
                        <div id="compare-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('compare-chart', '企業比較')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="explorer-tab-heatmap" class="tab-content">
                        <div class="grid-2">
                            <div class="form-group">
                                <label>企業数</label>
                                <input type="number" id="heatmap-companies" value="10" min="5" max="20">
                            </div>
                            <div class="form-group">
                                <label>キーワード数</label>
                                <input type="number" id="heatmap-keywords" value="15" min="5" max="30">
                            </div>
                        </div>
                        <button id="btn-heatmap" class="btn">ヒートマップを生成</button>
                        <div id="heatmap-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('heatmap-chart', 'ヒートマップ')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="explorer-tab-emerging" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">直近期間で急上昇しているキーワードを検出します。</p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>基準年（この年以降を「直近」とする）</label>
                                <input type="number" id="emerging-year" value="2020">
                            </div>
                            <div class="form-group">
                                <label>表示数</label>
                                <input type="number" id="emerging-top" value="20" min="10" max="50">
                            </div>
                        </div>
                        <button id="btn-emerging" class="btn">急上昇ワードを検出</button>
                        <div id="emerging-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('emerging-chart', '急上昇ワード')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="explorer-tab-kwic" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">キーワード文脈を確認します（KWIC: Keyword in Context）</p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>検索キーワード</label>
                                <input type="text" id="kwic-keyword" placeholder="例: ロボット">
                            </div>
                            <div class="form-group">
                                <label>前後語数</label>
                                <input type="number" id="kwic-context" value="30" min="10" max="100">
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 0.5rem;">
                            <label>検索対象</label>
                            <select id="kwic-target">
                                <option value="title">発明名称</option>
                                <option value="abstract">要約</option>
                                <option value="claims">請求項</option>
                            </select>
                        </div>
                        <button id="btn-kwic" class="btn">KWICを検索</button>
                        <div id="kwic-result" style="margin-top: 0.8rem; max-height: 400px; overflow-y: auto;"></div>
                    </div>
                    
                    
                    <div id="explorer-tab-stream" class="tab-content">
                        <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 1rem;">
                            キーワード時系列推移を美しいストリームグラフで可視化します。
                        </p>
                        <div class="grid-2" style="margin-bottom: 0.8rem;">
                            <div class="form-group">
                                <label>分析タイプ</label>
                                <select id="stream-type">
                                    <option value="keyword">キーワード推移</option>
                                    <option value="applicant">出願人推移</option>
                                    <option value="ipc">IPC推移</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>表示数</label>
                                <input type="number" id="stream-count" value="8" min="3" max="15">
                            </div>
                        </div>
                        <button id="btn-stream" class="btn">ストリームグラフを生成</button>
                        <div id="stream-chart" class="chart-container" style="margin-top: 0.8rem; min-height: 450px;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('stream-chart', 'ストリームグラフ')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                </div>
            </div>
            
            
            <div id="page-crew" class="page hidden">
                <div class="card">
                    <h2>ネットワーク分析</h2>
                    <div class="tabs" style="margin-bottom: 0.8rem;">
                        <button class="tab-btn active" onclick="showTab('crew', 'force')">フォースレイアウト</button>
                        <button class="tab-btn" onclick="showTab('crew', 'chord')">コード図</button>
                    </div>
                    
                    <div id="crew-tab-force" class="tab-content active">
                    <div class="grid-2" style="margin-bottom: 0.8rem;">
                        <div class="form-group">
                            <label>ネットワークタイプ</label>
                            <select id="network-type">
                                <option value="applicant" selected>出願人ネットワーク</option>
                                <option value="inventor">発明者ネットワーク</option>
                                <option value="ipc">IPC共起ネットワーク</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>最小エッジ重み</label>
                            <input type="number" id="min-edge" value="2" min="1" max="10">
                        </div>
                    </div>
                    <div class="grid-2" style="margin-bottom: 0.8rem;">
                        <div class="form-group">
                            <label>抽出要素</label>
                            <select id="network-centrality">
                                <option value="degree">次数中心性</option>
                                <option value="betweenness">媒介中心性</option>
                                <option value="closeness">近接中心性</option>
                                <option value="eigenvector">固有ベクトル中心性</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>表示ノード数</label>
                            <input type="number" id="network-max-nodes" value="50" min="10" max="200">
                        </div>
                    </div>
                    <button id="btn-network" class="btn" style="width: 100%;">ネットワークを生成</button>
                    <div id="network-status" style="margin-top: 0.5rem;"></div>
                    <div id="network-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                    <button class="btn btn-secondary" onclick="saveSnapshot('network-chart', 'ネットワーク')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    <div id="network-stats" style="margin-top: 0.8rem;"></div>
                    </div>
                    
                    
                    <div id="crew-tab-chord" class="tab-content">
                        <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 1rem;">
                            🎵 共同出願人・発明者の関係を美しいコード図（Chord Diagram）で可視化します。
                        </p>
                        <div class="grid-2" style="margin-bottom: 0.8rem;">
                            <div class="form-group">
                                <label>分析タイプ</label>
                                <select id="chord-type">
                                    <option value="ipc" selected>IPC共起関係</option>
                                    <option value="applicant">共同出願人関係</option>
                                    <option value="inventor">発明者ネットワーク</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>表示数</label>
                                <input type="number" id="chord-count" value="15" min="5" max="30">
                            </div>
                        </div>
                        <button id="btn-chord" class="btn">コード図を生成</button>
                        <div id="chord-chart" class="chart-container" style="margin-top: 0.8rem; min-height: 550px;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('chord-chart', 'コード図')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                </div>
            </div>
            
            
            <div id="page-mega" class="page hidden">
                <div class="card">
                    <h2>テキスト分析</h2>
                    <div style="margin-bottom: 0.5rem; font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">テキスト抽出</div>
                    <div class="tabs" style="margin-bottom: 0.5rem;">
                        <button class="tab-btn active" onclick="showTab('mega', 'wordcloud')">ワードクラウド</button>
                        <button class="tab-btn" onclick="showTab('mega', 'ngram')">N-gram</button>
                        <button class="tab-btn" onclick="showTab('mega', 'cooccur')">共起ネットワーク</button>
                        <button class="tab-btn" onclick="showTab('mega', 'tfidf')">TF-IDF</button>
                    </div>
                    <div style="margin-bottom: 0.5rem; font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">高度な可視化</div>
                    <div class="tabs">
                        <button class="tab-btn" onclick="showTab('mega', 'treemap')">ツリーマップ</button>
                        <button class="tab-btn" onclick="showTab('mega', 'sankey')">サンキー図</button>
                        <button class="tab-btn" onclick="showTab('mega', 'radar')">レーダー</button>
                        <button class="tab-btn" onclick="showTab('mega', 'sunburst')">サンバースト</button>
                    </div>
                    
                    <div id="mega-tab-wordcloud" class="tab-content active">
                        <div class="grid-2">
                            <div class="form-group">
                                <label>最大語数</label>
                                <input type="number" id="wc-max-words" value="100" min="20" max="200">
                            </div>
                            <div class="form-group">
                                <label>カラースキーム</label>
                                <select id="wc-colorscheme">
                                    <option value="viridis" selected>Viridis</option>
                                    <option value="plasma">Plasma</option>
                                    <option value="matplotlib">Matplotlib</option>
                                    <option value="warm">Warm</option>
                                    <option value="rainbow">Rainbow</option>
                                    <option value="blues">Blues</option>
                                </select>
                            </div>
                        </div>
                        <button id="btn-wordcloud" class="btn">ワードクラウドを生成</button>
                        <div id="wordcloud-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('wordcloud-chart', 'ワードクラウド')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="mega-tab-ngram" class="tab-content">
                        <div class="grid-2">
                            <div class="form-group">
                                <label>N-gramサイズ</label>
                                <select id="ngram-size">
                                    <option value="2">バイグラム (2語)</option>
                                    <option value="3">トライグラム (3語)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>TOP N</label>
                                <input type="number" id="ngram-top" value="25" min="10" max="50">
                            </div>
                        </div>
                        <button id="btn-ngram" class="btn">N-gramを分析</button>
                        <div id="ngram-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('ngram-chart', 'N-gram')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="mega-tab-cooccur" class="tab-content">
                        <div class="grid-2">
                            <div class="form-group">
                                <label>キーワード数</label>
                                <input type="number" id="cooccur-nodes" value="30" min="10" max="50">
                            </div>
                            <div class="form-group">
                                <label>最小共起数</label>
                                <input type="number" id="cooccur-min" value="3" min="1" max="10">
                            </div>
                        </div>
                        <button id="btn-cooccur" class="btn">共起ネットワークを生成</button>
                        <div id="cooccur-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('cooccur-chart', '共起ネットワーク')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    <div id="mega-tab-tfidf" class="tab-content">
                        <div class="form-group">
                            <label>分析対象企業・出願人</label>
                            <select id="tfidf-company"></select>
                        </div>
                        <button id="btn-tfidf" class="btn">特徴語を抽出</button>
                        <div id="tfidf-result" style="margin-top: 0.8rem;"></div>
                    </div>
                    
                    <div id="mega-tab-strategy" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">出願人の成長率とシェアを分析し、戦略ポジションを可視化します。</p>
                        <div class="grid-3">
                            <div class="form-group">
                                <label>分析対象企業数</label>
                                <input type="number" id="strategy-companies" value="15" min="5" max="30">
                            </div>
                            <div class="form-group">
                                <label>基準年 (AGR計算用)</label>
                                <input type="number" id="strategy-base-year" value="2018">
                            </div>
                            <div class="form-group">
                                <label>バブルサイズ</label>
                                <select id="strategy-size">
                                    <option value="total">総出願件数</option>
                                    <option value="recent">直近3年件数</option>
                                </select>
                            </div>
                        </div>
                        <button id="btn-strategy" class="btn">戦略マトリクスを分析</button>
                        <div id="strategy-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('strategy-chart', '戦略マトリクス')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                        <div id="strategy-summary" style="margin-top: 0.8rem;"></div>
                    </div>
                    
                    
                    <div id="mega-tab-treemap" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">IPC分類の階層構造をツリーマップで可視化します。</p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>表示階層</label>
                                <select id="treemap-level">
                                    <option value="section">セクション (A-H)</option>
                                    <option value="class" selected>クラス (例: G06)</option>
                                    <option value="subclass">サブクラス (例: G06F)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>カラースキーム</label>
                                <select id="treemap-color">
                                    <option value="Viridis" selected>Viridis (グリーン系)</option>
                                    <option value="Sunset">Sunset (オレンジ系)</option>
                                    <option value="Plasma">Plasma (パープル系)</option>
                                    <option value="Turbo">Turbo (レインボー)</option>
                                    <option value="Cividis">Cividis (イエロー系)</option>
                                    <option value="Inferno">Inferno (暖色系)</option>
                                </select>
                            </div>
                        </div>
                        <button id="btn-treemap" class="btn">ツリーマップを生成</button>
                        <div id="treemap-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('treemap-chart', 'IPCツリーマップ')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    
                    <div id="mega-tab-sankey" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">出願人と技術分野（IPC/FI）の関係をインタラクティブなサンキー図で可視化します。</p>
                        <div class="grid-3">
                            <div class="form-group">
                                <label>出願人数</label>
                                <input type="number" id="sankey-applicants" value="10" min="5" max="20">
                            </div>
                            <div class="form-group">
                                <label>IPC/FI数</label>
                                <input type="number" id="sankey-ipcs" value="10" min="5" max="20">
                            </div>
                            <div class="form-group">
                                <label>カラースキーム</label>
                                <select id="sankey-color">
                                    <option value="category" selected>カテゴリ別</option>
                                    <option value="gradient">グラデーション</option>
                                </select>
                            </div>
                        </div>
                        <button id="btn-sankey" class="btn">サンキー図を生成</button>
                        <div id="sankey-chart" class="chart-container" style="margin-top: 0.8rem; min-height: 500px;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('sankey-chart', 'サンキー図')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    
                    <div id="mega-tab-radar" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">選択した企業の技術ポートフォリオをレーダーチャートで比較します。</p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>比較企業1</label>
                                <select id="radar-company1"></select>
                            </div>
                            <div class="form-group">
                                <label>比較企業2</label>
                                <select id="radar-company2"></select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>比較軸 (IPC表示レベル)</label>
                            <select id="radar-axis">
                                <option value="section">セクション (A-H)</option>
                                <option value="class" selected>クラス (TOP10)</option>
                            </select>
                        </div>
                        <button id="btn-radar" class="btn">レーダーチャートを生成</button>
                        <div id="radar-chart" class="chart-container" style="margin-top: 0.8rem;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('radar-chart', 'レーダーチャート')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                    
                    
                    <div id="mega-tab-sunburst" class="tab-content">
                        <p style="margin-bottom: 0.8rem; font-size: 0.85rem;">IPC分類の階層構造を放射状のサンバースト図で可視化します。クリックでズームイン/アウト。</p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>データ源</label>
                                <select id="sunburst-source">
                                    <option value="ipc" selected>IPC分析</option>
                                    <option value="fi">FI分析</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>カラースキーム</label>
                                <select id="sunburst-color">
                                    <option value="Spectral" selected>Spectral</option>
                                    <option value="Rainbow">Rainbow</option>
                                    <option value="Viridis">Viridis</option>
                                    <option value="Plasma">Plasma</option>
                                </select>
                            </div>
                        </div>
                        <button id="btn-sunburst" class="btn">サンバーストを生成</button>
                        <div id="sunburst-chart" class="chart-container" style="margin-top: 0.8rem; min-height: 550px;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('sunburst-chart', 'サンバースト')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                </div>
            </div>
            
            
            <div id="page-advanced" class="page hidden">
                <div class="card">
                    <h2>アドバンスド可視化</h2>
                    <p style="margin-bottom: 1rem; color: #4fc3f7; font-size: 0.9rem;">
                        PyScriptならではのインタラクティブな可視化機能
                    </p>
                    
                    <div class="tabs">
                        <button class="tab-btn active" onclick="showTab('nova', 'bubble-race')">バブルレース</button>
                        <button class="tab-btn" onclick="showTab('nova', 'circle-pack')">サークルパック</button>
                        <button class="tab-btn" onclick="showTab('nova', 'dendro')">デンドログラム</button>
                    </div>
                    
                    
                    <div id="nova-tab-bubble-race" class="tab-content active">
                        <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 1rem;">
                            年ごとの出願人シェアをアニメーションで再生します。
                        </p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>表示企業数</label>
                                <input type="number" id="race-companies" value="10" min="5" max="15">
                            </div>
                            <div class="form-group">
                                <label>アニメーション速度</label>
                                <select id="race-speed">
                                    <option value="slow">ゆっくり (1秒/年)</option>
                                    <option value="normal" selected>普通 (0.5秒/年)</option>
                                    <option value="fast">高速 (0.25秒/年)</option>
                                    <option value="ultra">超高速 (0.1秒/年)</option>
                                </select>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button id="btn-race-play" class="btn" onclick="window.bubbleRacePlay()">▶再生</button>
                            <button id="btn-race-pause" class="btn btn-secondary" onclick="window.bubbleRacePause()">⏸一時停止</button>
                            <button id="btn-race-reset" class="btn btn-secondary" onclick="window.bubbleRaceReset()">⏮リセット</button>
                        </div>
                        <div id="race-year-display" style="text-align: center; font-size: 2rem; font-weight: bold; color: #4fc3f7; margin: 1rem 0;"></div>
                        <div id="race-chart" class="chart-container" style="min-height: 450px;"></div>
                    </div>
                    
                    
                    <div id="nova-tab-circle-pack" class="tab-content">
                        <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 1rem;">
                            階層的データ構造をインタラクティブに表示します。クリックでズーム、さらにクリックで案件リスト表示。
                        </p>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>階層</label>
                                <select id="circle-hierarchy">
                                    <option value="applicant-ipc" selected>出願人 →IPC</option>
                                    <option value="ipc-applicant">IPC →出願人</option>
                                    <option value="year-applicant">年 →出願人</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>表示数</label>
                                <input type="number" id="circle-count" value="8" min="5" max="15">
                            </div>
                        </div>
                        <button id="btn-circle-pack" class="btn">サークルパックを生成</button>
                        <div style="display: flex; gap: 1rem; margin-top: 0.8rem;">
                            <div id="circle-chart" class="chart-container" style="flex: 0 0 550px; min-height: 550px;"></div>
                            <div id="circle-detail-panel" style="flex: 1; min-width: 300px; max-height: 550px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 1rem; display: none;">
                                <h4 style="color: #4fc3f7; margin-bottom: 0.8rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <span id="circle-detail-title">📋 案件リスト</span>
                                    <button onclick="document.getElementById('circle-detail-panel').style.display='none';" style="margin-left: auto; background: none; border: none; color: #888; cursor: pointer; font-size: 1.2rem;">✖</button>
                                </h4>
                                <div id="circle-detail-content" style="font-size: 0.85rem;"></div>
                            </div>
                        </div>
                    </div>
                    
                    
                    <div id="nova-tab-dendro" class="tab-content">
                        <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 1rem;">
                            🌿 階層的クラスタリングの結果をデンドログラム（樹形図）で可視化します。
                        </p>
                        <div class="grid-2" style="margin-bottom: 0.8rem;">
                            <div class="form-group">
                                <label>クラスタリング対象</label>
                                <select id="dendro-target">
                                    <option value="applicant" selected>出願人技術類似度</option>
                                    <option value="keyword">キーワード共起パターン</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>表示数</label>
                                <input type="number" id="dendro-count" value="20" min="10" max="50">
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 0.8rem;">
                            <label>距離計算方法</label>
                            <select id="dendro-method">
                                <option value="ward" selected>Ward法</option>
                                <option value="complete">Complete法</option>
                                <option value="average">Average法</option>
                            </select>
                        </div>
                        <button id="btn-dendro" class="btn">デンドログラムを生成</button>
                        <div id="dendro-chart" class="chart-container" style="margin-top: 0.8rem; min-height: 500px;"></div>
                        <button class="btn btn-secondary" onclick="saveSnapshot('dendro-chart', 'デンドログラム')" style="margin-top: 0.5rem;">スナップショットを保存</button>
                    </div>
                </div>
            </div>
            
            
            <div id="page-export" class="page hidden">
                <div class="card">
                    <h2>エクスポート</h2>
                    <p style="margin-bottom: 1rem;">分析結果をエクスポートしレポートを生成できます。</p>
                    <div class="grid-2">
                        <button id="btn-export-summary" class="btn">統計サマリーをコピー</button>
                        <button id="btn-export-keywords" class="btn">キーワードをコピー</button>
                    </div>
                    <div class="grid-2" style="margin-top: 0.5rem;">
                        <button id="btn-generate-report" class="btn">レポートを生成</button>
                        <button id="btn-export-all" class="btn">全データをエクスポート</button>
                    </div>
                    <div id="export-result" style="margin-top: 1rem;"></div>
                    
                    <div id="report-output" style="margin-top: 1rem; display: none;">
                        <h4>📋 自動生成レポート</h4>
                        <textarea id="report-text" rows="15" style="width: 100%; background: rgba(0,0,0,0.3); color: #e0e1dd; border: 1px solid rgba(255,255,255,0.2); border-radius: 5px; padding: 0.5rem;"></textarea>
                        <button class="btn btn-secondary" onclick="navigator.clipboard.writeText(document.getElementById('report-text').value); alert('コピーしました');" style="margin-top: 0.3rem;">📋 レポートをコピー</button>
                    </div>
                    
                    <div style="margin-top: 1.5rem;">
                        <h4>📸 スナップショットギャラリー</h4>
                        <p style="font-size: 0.85rem; color: #888; margin-bottom: 0.5rem;">チャートの「スナップショット保存」ボタンで画像を保存できます</p>
                        <div id="snapshot-gallery" style="margin-top: 0.5rem;">
                            <p style="color: #888;">保存されたスナップショットはありません</p>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1.5rem;">
                        <h4>📋 データプレビュー</h4>
                        <div id="data-preview" style="max-height: 300px; overflow-y: auto; margin-top: 0.5rem;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * ============================================================================
         * ARTEMIS - JavaScript UI Engine
         * ============================================================================
         * 
         * 概要:
         *   ブラウザ上で動作する特許分析ツールのUIレイヤー。
         *   PyScript (Pyodide) で実行されるPython分析エンジンと連携し、
         *   Plotly.js / D3.js による可視化を提供する。
         * 
         * アーキテクチャ:
         *   - 状態管理: window.appState オブジェクト
         *   - Python連携: window.pyodide_globals / window.pyLoadHeavyPackages
         *   - 可視化: drawChart(), drawWordCloud(), drawForceNetwork() など
         * 
         * 依存関係:
         *   - Plotly.js 2.27.0
         *   - D3.js v7 + d3-cloud + d3-sankey
         *   - PapaParse 5.4.1
         *   - PyScript 2024.1.1
         * 
         * ============================================================================
         */

        // ============================================================================
        // 設定定数
        // ============================================================================

        /** @const {boolean} デバッグモードフラグ (本番環境では false) */
        const DEBUG = false;

        /** @const {number} トースト通知のデフォルト表示時間 (ms) */
        const TOAST_DURATION_DEFAULT = 3000;

        /** @const {number} Python起動タイムアウト (秒) */
        const PYTHON_INIT_TIMEOUT = 120;

        /** @const {number} パッケージロード最大リトライ回数 */
        const HEAVY_PACKAGE_MAX_RETRY = 60;

        // ============================================================================
        // アプリケーション状態
        // ============================================================================

        /** @type {HTMLElement|null} 現在表示中のページ要素 */
        let currentPage = null;

        /**
         * デバッグ用ログ出力
         * @param {...*} args - 出力する値
         */
        function debugLog(...args) {
            if (!DEBUG) return;
            console.log('[ARTEMIS]', ...args);
        }
        window.__pyInitStart = Date.now();
        window.__pyInitTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - window.__pyInitStart) / 1000);
            const min = Math.floor(elapsed / 60);
            const sec = elapsed % 60;
            const timeStr = min > 0 ? `${min}分${sec}秒` : `${sec}秒`;
            const elapsedEl = document.getElementById('init-elapsed');
            if (elapsedEl) elapsedEl.textContent = `経過時間: ${timeStr}`;
            
            const detailEl = document.getElementById('init-detail');
            if (detailEl) {
                if (elapsed > 120) {
                    detailEl.textContent = '⚠️ 読み込みに時間がかかっています。ネットワーク接続を確認してください。';
                    detailEl.style.color = '#ff6b6b';
                } else if (elapsed > 60) {
                    detailEl.textContent = 'パッケージのダウンロード中... (初回は時間がかかります)';
                    detailEl.style.color = '#ffd93d';
                } else {
                    detailEl.textContent = 'Pyodide + pandas + numpy をダウンロード中...';
                }
            }
            
            if (elapsed % 10 === 0 && elapsed > 0) {
                debugLog(`[Init] Python初期化中... ${timeStr}`);
            }
        }, 1000);

        // ============================================================================
        // Quick Parse (Python起動前のCSV解析用)
        // ============================================================================

        /** @type {Object[]|null} PapaParse で解析された生CSVデータ */
        window.quickData = null;

        /** @type {string[]} CSVのカラム名リスト */
        window.quickColumns = [];

        /** @type {boolean} Quick Parse データが利用可能か */
        window.quickReady = false;

        /**
         * アプリケーションのグローバル状態
         * @type {Object}
         * @property {string} chartType - 現在選択中のチャートタイプ
         * @property {Object.<string, boolean>} statusBreakdownByType - チャートタイプ別のステータス分類フラグ
         */
        window.appState = {
            chartType: 'trend',
            statusBreakdownByType: {
                trend: false,
                trend_line: false,
                applicant: false,
                ipc: false,
                bubble: false,
                ipc_applicant: false,
                treemap: false,
                lifecycle: false
            }
        };

        // ============================================================================
        // UIコントロール関数
        // ============================================================================

        /**
         * ATLASページのステータス分類チェックボックスの状態を同期
         * チャートタイプに応じてチェックボックスの有効/無効を切り替える
         */
        function syncAtlasStatusCheckbox() {
            const checkbox = document.getElementById('use-status-breakdown');
            if (!checkbox) return;
            
            const enabledTypes = ['trend', 'trend_line', 'applicant', 'bubble'];
            let enabled = enabledTypes.includes(window.appState.chartType);
            
            if (window.appState.chartType === 'trend_line') {
                const lineMode = document.getElementById('atlas-line-mode')?.value || 'overall';
                enabled = enabled && lineMode === 'overall';
            }
            
            checkbox.disabled = !enabled;
            const row = document.getElementById('atlas-status-toggle-row');
            if (row) row.style.display = enabled ? 'flex' : 'none';
            
            if (!enabled) {
                checkbox.checked = false;
                return;
            }
            
            const state = window.appState.statusBreakdownByType || {};
            checkbox.checked = !!state[window.appState.chartType];
        }
        function syncAtlasControls() {
            const lineControls = document.getElementById('atlas-line-controls');
            if (!lineControls) return;
            lineControls.style.display = window.appState.chartType === 'trend_line' ? 'grid' : 'none';

            const applicantCtl = document.getElementById('atlas-control-applicant');
            if (applicantCtl) applicantCtl.style.display = window.appState.chartType === 'applicant' ? 'grid' : 'none';

            const ipcCtl = document.getElementById('atlas-control-ipc');
            if (ipcCtl) ipcCtl.style.display = window.appState.chartType === 'ipc' ? 'grid' : 'none';

            const bubbleCtl = document.getElementById('atlas-control-bubble');
            if (bubbleCtl) bubbleCtl.style.display = window.appState.chartType === 'bubble' ? 'grid' : 'none';

            const ipcAppCtl = document.getElementById('atlas-control-ipc-applicant');
            if (ipcAppCtl) ipcAppCtl.style.display = window.appState.chartType === 'ipc_applicant' ? 'grid' : 'none';

            const treemapCtl = document.getElementById('atlas-control-treemap');
            if (treemapCtl) treemapCtl.style.display = window.appState.chartType === 'treemap' ? 'grid' : 'none';
        }

        /**
         * ATLASページの入力要素にイベントリスナーをバインド
         * 入力変更時に自動でチャートを再描画する
         */
        function bindAtlasInputs() {
            const btn = document.getElementById('btn-atlas');
            if (!btn) return;
            
            const replot = () => btn.click();
            const ids = [
                'atlas-line-mode',
                'atlas-line-applicants',
                'atlas-applicant-count',
                'atlas-ipc-level',
                'atlas-ipc-count',
                'atlas-bubble-count',
                'atlas-ipcapp-level',
                'atlas-ipcapp-ipc-count',
                'atlas-ipcapp-app-count',
                'atlas-treemap-mode'
            ];
            
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('change', replot);
            });
            
            const lineMode = document.getElementById('atlas-line-mode');
            if (lineMode) {
                lineMode.addEventListener('change', syncAtlasStatusCheckbox);
            }
        }

        /**
         * COREモジュールのフェーズ表示を同期
         * 選択されたフェーズに応じてUIを切り替える
         */
        function syncCorePhase() {
            const sel = document.getElementById('core-phase');
            if (!sel) return;
            
            document.querySelectorAll('.core-phase').forEach(p => p.style.display = 'none');
            const target = document.getElementById('core-' + sel.value);
            if (target) target.style.display = 'block';
            
            if (window.pyodide_globals && window.pyodide_globals.update_core_axis_selects) {
                window.pyodide_globals.update_core_axis_selects();
            }
            
            if (sel.value === 'phase2' && window.pyodide_globals && window.pyodide_globals.render_core_rules) {
                window.pyodide_globals.render_core_rules();
            }
            
            if (sel.value === 'phase2') {
                const addBtn = document.getElementById('btn-core-add');
                const updBtn = document.getElementById('btn-core-update');
                const cancelBtn = document.getElementById('btn-core-cancel');
                if (addBtn && updBtn && cancelBtn) {
                    addBtn.style.display = 'inline-block';
                    updBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                }
            }
        }

        // ============================================================================
        // Python連携
        // ============================================================================

        /** @type {boolean} Python環境が準備完了したか */
        window.__pyReady = false;

        /** @type {boolean} Python起動前にLaunchボタンが押されたか (遅延実行用) */
        window.__pendingLaunch = false;

        /**
         * Python環境の準備状態を設定
         * @param {boolean} isReady - Python環境が準備完了したか
         */
        function setPyReady(isReady) {
            debugLog('[Init] setPyReady called with:', isReady);
            
            if (isReady && window.__pyInitTimer) {
                clearInterval(window.__pyInitTimer);
                const elapsed = Math.floor((Date.now() - window.__pyInitStart) / 1000);
                debugLog(`[Init] Python初期化完了 ${elapsed}秒`);
            }
            
            const status = document.getElementById('py-status');
            if (status) status.textContent = isReady ? 'Engine ready' : 'Engine loading…';
            updateModuleProgress('export', isReady ? '準備完了' : '準備中', isReady ? 100 : 0);
            
            const baseIds = [];
            baseIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !isReady;
            });
            
            if (!isReady) {
                setHeavyReady(false);
            }
            
            window.__pyReady = isReady;
            
            if (isReady && window.__pendingLaunch) {
                const launchBtn = document.getElementById('btn-launch');
                if (launchBtn) launchBtn.click();
                window.__pendingLaunch = false;
            }
            
            if (isReady) {
                requestHeavyPackages();
            }
        }

        /**
         * 重量パッケージ (scikit-learn, networkx) の準備状態を設定
         * @param {boolean} isReady - パッケージが準備完了したか
         */
        function setHeavyReady(isReady) {
            debugLog('[Heavy] setHeavyReady called with:', isReady);
            
            if (isReady && window.__heavyElapsedTimer) {
                clearInterval(window.__heavyElapsedTimer);
            }
            
            const status = document.getElementById('bg-load-status');
            if (status && isReady) status.textContent = '追加モジュール: 読み込み完了';
            
            if (isReady) {
                updateHeavyProgress('完了', { 'scikit-learn': '完了', 'networkx': '完了' });
            }
            
            const phaseText = isReady ? '準備完了' : '読み込み中';
            const phasePct = isReady ? 100 : null;
            
            if (!isReady) {
                ['core','mega','saturn','explorer','crew'].forEach(key => {
                    updateModuleProgress(key, phaseText, phasePct);
                });
            }
            
            const ids = [
                'btn-core-search','btn-core-ai','btn-core-import','btn-core-add','btn-core-update','btn-core-cancel',
                'btn-core-run','btn-core-reanalyze','btn-core-map',
                'btn-saturn','btn-keyword','btn-trend','btn-compare','btn-heatmap','btn-emerging',
                'btn-network','btn-wordcloud','btn-ngram','btn-cooccur','btn-tfidf',
                'btn-export-summary','btn-export-keywords'
            ];
            
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !isReady;
            });
            
            if (isReady) {
                startModuleSequence();
            }
        }

        
        function startModuleSequence() {
            if (window.__moduleSeqRunning) return;
            window.__moduleSeqRunning = true;
            
            const plan = [
                { key: 'core', buttons: ['btn-core-search','btn-core-ai','btn-core-import','btn-core-add','btn-core-update','btn-core-cancel','btn-core-run','btn-core-reanalyze','btn-core-map'] },
                { key: 'mega', buttons: ['btn-keyword','btn-trend','btn-compare','btn-heatmap','btn-emerging'] },
                { key: 'saturn', buttons: ['btn-saturn'] },
                { key: 'explorer', buttons: ['btn-network','btn-wordcloud','btn-ngram','btn-cooccur'] },
                { key: 'crew', buttons: ['btn-tfidf'] }
            ];
            plan.forEach((item, idx) => {
                const delay = idx * 700;
                setTimeout(() => {
                    updateModuleProgress(item.key, '読み込み中', null);
                    setTimeout(() => {
                        updateModuleProgress(item.key, '準備完了', 100);
                        item.buttons.forEach(id => {
                            const el = document.getElementById(id);
                            if (el) el.disabled = false;
                        });
                    }, 500);
                }, delay);
            });
        }

        function updateHeavyProgress(phaseText, states, elapsedSec) {
            const status = document.getElementById('bg-load-status');
            const detail = document.getElementById('bg-load-detail');
            const fill = document.getElementById('bg-load-progress-fill');
            let elapsed = '';
            if (elapsedSec !== undefined && elapsedSec > 0) {
                const min = Math.floor(elapsedSec / 60);
                const sec = Math.floor(elapsedSec % 60);
                elapsed = min > 0 ? ` (${min}分${sec}秒)` : ` (${sec}秒)`;
            }
            if (status && phaseText) status.textContent = `追加モジュール: ${phaseText}${elapsed}`;
            const modules = ['scikit-learn', 'networkx'];
            const stateMap = states || {};
            if (detail) {
                detail.innerHTML = modules.map(m => {
                    const s = stateMap[m] || '不明';
                    return `<div class="bg-module-item"><span>${m}</span><span class="bg-module-state">${s}</span></div>`;
                }).join('');
            }
            if (fill) {
                const done = modules.filter(m => stateMap[m] === '完了').length;
                const pct = Math.round((done / modules.length) * 100);
                fill.style.width = `${pct}%`;
            }
        }

        function updateModuleProgress(key, label, pct) {
            const statusEl = document.getElementById(`mod-${key}-status`);
            const progEl = document.getElementById(`mod-${key}-progress`);
            if (statusEl) {
                statusEl.textContent = pct === null ? '...' : `${pct}%`;
            }
            if (progEl) {
                if (pct === null) {
                    progEl.classList.add('indeterminate');
                } else {
                    progEl.classList.remove('indeterminate');
                    progEl.style.width = `${pct}%`;
                }
            }
        }

        function syncCoreAxisMode() {
            const mode = document.getElementById('core-axis-mode').value;
            const axisSelect = document.getElementById('core-axis-select');
            const axisNew = document.getElementById('core-axis-new');
            if (axisSelect && axisSelect.value === '') {
                document.getElementById('core-axis-mode').value = 'new';
            }
            if (mode === 'new') {
                axisSelect.disabled = true;
                axisNew.disabled = false;
            } else {
                axisSelect.disabled = false;
                axisNew.disabled = true;
            }
        }

        async function requestHeavyPackages() {
            debugLog('[Heavy] requestHeavyPackages called, loading:', window.__heavyPackagesLoading);
            if (window.__heavyPackagesLoading) return;
            window.__heavyPackagesLoading = true;
            window.__heavyLoadStart = Date.now();
            
            const status = document.getElementById('bg-load-status');
            const startTime = Date.now();
            
            const updateElapsed = () => {
                const sec = Math.floor((Date.now() - startTime) / 1000);
                const min = Math.floor(sec / 60);
                const s = sec % 60;
                const timeStr = min > 0 ? `${min}分${s}秒` : `${s}秒`;
                
                const pyFuncReady = typeof window.pyLoadHeavyPackages === 'function';
                if (!pyFuncReady) {
                    if (status) status.textContent = `Python起動待機中... (${timeStr})`;
                    updateHeavyProgress(`Python起動待機中 (${timeStr})`, { 'scikit-learn': '待機中', 'networkx': '待機中' });
                    updateModuleProgress('core', `Python起動待機中 (${timeStr})`, null);
                }
            };
            
            window.__heavyElapsedTimer = setInterval(updateElapsed, 1000);
            
            updateModuleProgress('core', 'Python起動待機中', null);
            ['mega','saturn','explorer','crew'].forEach(key => {
                updateModuleProgress(key, '準備中', 0);
            });
            
            try {
                if (typeof window.pyLoadHeavyPackages === 'function') {
                    debugLog('[Heavy] Python function available, calling pyLoadHeavyPackages...');
                    clearInterval(window.__heavyElapsedTimer);
                    
                    const pkgStartTime = Date.now();
                    window.__heavyElapsedTimer = setInterval(() => {
                        const sec = Math.floor((Date.now() - pkgStartTime) / 1000);
                        const min = Math.floor(sec / 60);
                        const s = sec % 60;
                        const timeStr = min > 0 ? `${min}分${s}秒` : `${s}秒`;
                        if (status) status.textContent = `パッケージ読み込み中... (${timeStr})`;
                    }, 1000);
                    
                    // Python側のパッケージロード関数を呼び出す
                    await window.pyLoadHeavyPackages();
                    
                } else {
                    debugLog('[Heavy] Python function not ready, retrying... count:', window.__heavyRetryCount);
                    window.__heavyPackagesLoading = false;
                    window.__heavyRetryCount = (window.__heavyRetryCount || 0) + 1;
                    if (window.__heavyRetryCount < 60) {
                        setTimeout(() => {
                            window.__heavyPackagesLoading = false;
                            requestHeavyPackages();
                        }, 1000);
                    } else {
                        clearInterval(window.__heavyElapsedTimer);
                        if (status) status.textContent = '追加モジュール: タイムアウト - ページを再読み込みしてください';
                        updateHeavyProgress('タイムアウト(Python関数未登録)', { 'scikit-learn': 'エラー', 'networkx': 'エラー' });
                        updateModuleProgress('core', 'タイムアウト', 0);
                    }
                }
            } catch (e) {
                console.error('[Heavy] Error:', e);
                clearInterval(window.__heavyElapsedTimer);
                if (status) status.textContent = `追加モジュール: エラー`;
                updateHeavyProgress('エラー', { 'scikit-learn': 'エラー', 'networkx': 'エラー' });
                updateModuleProgress('core', `エラー: ${String(e.message || e).replace(/</g, '&lt;').replace(/>/g, '&gt;')}`, 0);
            }
        }

        function setupQuickFileParse() {
            if (!window.Papa) return;
            const input = document.getElementById('file-input');
            if (!input) return;
            input.addEventListener('change', async (e) => {
                if (window.__pyReady) return;
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                
                // Read file as ArrayBuffer to detect encoding
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                
                let text = null;
                let encoding = 'utf-8';
                
                // Check for UTF-16 LE BOM (FF FE)
                if (bytes.length >= 2 && bytes[0] === 0xFF && bytes[1] === 0xFE) {
                    encoding = 'utf-16le';
                    const decoder = new TextDecoder('utf-16le');
                    text = decoder.decode(arrayBuffer);
                }
                // Check for UTF-16 BE BOM (FE FF)
                else if (bytes.length >= 2 && bytes[0] === 0xFE && bytes[1] === 0xFF) {
                    encoding = 'utf-16be';
                    const decoder = new TextDecoder('utf-16be');
                    text = decoder.decode(arrayBuffer);
                }
                // Check for UTF-8 BOM (EF BB BF)
                else if (bytes.length >= 3 && bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
                    encoding = 'utf-8';
                    const decoder = new TextDecoder('utf-8');
                    text = decoder.decode(arrayBuffer);
                }
                // Check for null bytes pattern (likely UTF-16 LE without BOM)
                else if (bytes.length >= 4 && (bytes[1] === 0 || bytes[3] === 0)) {
                    encoding = 'utf-16le';
                    const decoder = new TextDecoder('utf-16le');
                    text = decoder.decode(arrayBuffer);
                }
                // Default: try UTF-8, then Shift-JIS
                else {
                    try {
                        const decoder = new TextDecoder('utf-8', { fatal: true });
                        text = decoder.decode(arrayBuffer);
                    } catch {
                        try {
                            const decoder = new TextDecoder('shift_jis');
                            text = decoder.decode(arrayBuffer);
                            encoding = 'shift_jis';
                        } catch {
                            // Fallback to UTF-8 without fatal
                            const decoder = new TextDecoder('utf-8');
                            text = decoder.decode(arrayBuffer);
                        }
                    }
                }
                
                Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (res) => {
                        window.quickData = res.data || [];
                        window.quickColumns = res.meta && res.meta.fields ? res.meta.fields : [];
                        window.quickReady = window.quickData.length > 0;
                        const info = document.getElementById('file-info');
                        if (info) info.textContent = `📂 ${file.name} (${window.quickData.length.toLocaleString()}件)`;

                        const safeHtml = (str) => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
                        const cols = ['(未選択)', ...window.quickColumns];
                        ['col-title','col-abstract','col-date','col-applicant','col-ipc','col-inventor','col-status'].forEach(id => {
                            const sel = document.getElementById(id);
                            if (sel) sel.innerHTML = cols.map(c => `<option value="${safeHtml(c)}">${safeHtml(c)}</option>`).join('');
                        });

                        const autoMap = {
                            'col-title': ['発明名称','Title','title','名称'],
                            'col-abstract': ['要約','Abstract','abstract','要約・抄録'],
                            'col-date': ['出願日','Date','applicationDate','出願年'],
                            'col-applicant': ['出願人','Applicant','applicant','出願人/権利者'],
                            'col-ipc': ['IPC','FI','ipc','Fターム'],
                            'col-inventor': ['発明者','Inventor','inventor'],
                            'col-status': ['IPC','FI','ステータス','Status','status','法的状況','審査状況']
                        };
                        Object.keys(autoMap).forEach(selId => {
                            const sel = document.getElementById(selId);
                            if (!sel) return;
                            const keys = autoMap[selId];
                            const match = window.quickColumns.find(c => keys.some(k => String(c).toLowerCase().includes(k.toLowerCase())));
                            if (match) sel.value = match;
                        });

                        const preview = document.getElementById('preview-area');
                        if (preview) {
                            const head = window.quickColumns.slice(0, 6);
                            let html = `<div class="status-ok">✅ ${window.quickData.length.toLocaleString()} 行読み込み完了（簡易）</div>`;
                            html += '<div style="overflow-x: auto; margin-top: 0.5rem;"><table class="data-table"><tr>';
                            head.forEach(c => { html += `<th>${safeHtml(c)}</th>`; });
                            html += '</tr>';
                            window.quickData.slice(0, 3).forEach(row => {
                                html += '<tr>';
                                head.forEach(c => { html += `<td>${safeHtml(String(row[c] || '').slice(0, 25))}</td>`; });
                                html += '</tr>';
                            });
                            html += '</table></div>';
                            preview.innerHTML = html;
                        }
                    }
                });
            });
        }

        function ensureAtlasStatusVisible() {
            const checkbox = document.getElementById('use-status-breakdown');
            const row = document.getElementById('atlas-status-toggle-row');
            if (!checkbox || !row) return;
            const group = checkbox.closest('.checkbox-group');
            if (group && row.children.length === 0) {
                row.appendChild(group);
            }
        }

        function quickParseYear(val) {
            const m = String(val || '').match(/(\d{4})/);
            return m ? parseInt(m[1], 10) : null;
        }

        function quickSplitList(val) {
            if (!val) return [];
            return String(val).split(/[;、|\n]/).map(s => s.trim()).filter(Boolean);
        }

        function quickNormalizeStatus(val) {
            const parts = quickSplitList(val);
            return parts.length ? parts[0] : '未設定';
        }

        function quickStatusMap(statuses) {
            // ダークテーマ対応: 視認性の高い鮮明な色
            const palette = [
                '#4fc3f7','#81c784','#ffb74d','#ce93d8','#ef5350',
                '#26a69a','#ffa726','#42a5f5','#ab47bc','#ec407a'
            ];
            const map = {};
            statuses.forEach((s, i) => { map[s] = palette[i % palette.length]; });
            return map;
        }

        function applyStatusLegend(layout, extraBottom = 80) {
            layout.legend = Object.assign({
                orientation: 'h',
                y: -0.25,
                x: 0,
                xanchor: 'left'
            }, layout.legend || {});
            layout.margin = layout.margin || {};
            layout.margin.b = Math.max(layout.margin.b || 0, extraBottom);
        }

        function truncateApplicantName(name, maxLen = 25) {
            if (!name) return '';
            const s = String(name).trim();
            if (s.length <= maxLen) return s;
            return s.slice(0, maxLen - 1) + '…';
        }

        function quickDrawAtlas() {
            if (!window.quickReady) {
                document.getElementById('atlas-chart').innerHTML = '<div class="status-warn">データがありません。Python起動後に利用可能</div>';
                return;
            }
            const chartType = window.appState.chartType;
            const start = parseInt(document.getElementById('year-start').value, 10);
            const end = parseInt(document.getElementById('year-end').value, 10);
            const topN = parseInt(document.getElementById('top-n').value, 10);
            let useStatus = document.getElementById('use-status-breakdown').checked;
            if (!['trend', 'trend_line', 'applicant', 'bubble'].includes(chartType)) {
                useStatus = false;
            }

            const colDate = document.getElementById('col-date').value;
            const colApplicant = document.getElementById('col-applicant').value;
            const colIpc = document.getElementById('col-ipc').value;
            const colStatus = document.getElementById('col-status').value;

            if (useStatus && colStatus === '(未選択)') {
                document.getElementById('atlas-chart').innerHTML = '<div class="status-warn">ステータス列が未選択です</div>';
                return;
            }

            const rows = window.quickData.map(r => {
                const year = quickParseYear(r[colDate]);
                return {
                    year,
                    applicant_list: quickSplitList(r[colApplicant]),
                    ipc_list: quickSplitList(r[colIpc]).map(v => String(v).toUpperCase()),
                    status: quickNormalizeStatus(r[colStatus])
                };
            }).filter(r => r.year && r.year >= start && r.year <= end);

            if (chartType === 'trend') {
                if (useStatus && colStatus !== '(未選択)') {
                    const statuses = Array.from(new Set(rows.map(r => r.status))).sort();
                    const statusMap = quickStatusMap(statuses);
                    const years = Array.from({length: end - start + 1}, (_, i) => start + i);
                    const traces = statuses.map(st => ({
                        x: years,
                        y: years.map(y => rows.filter(r => r.year === y && r.status === st).length),
                        type: 'bar',
                        name: st,
                        marker: {color: statusMap[st]}
                    }));
                    const layout = {title: `出願件数推移 (${start}-${end}) - ステータス別`, barmode:'stack', height: 450};
                    applyStatusLegend(layout, 80);
                    drawChart('atlas-chart', JSON.stringify(traces), JSON.stringify(layout));
                } else {
                    const yearCounts = {};
                    rows.forEach(r => { yearCounts[r.year] = (yearCounts[r.year] || 0) + 1; });
                    const years = Object.keys(yearCounts).sort();
                    const counts = years.map(y => yearCounts[y]);
                    drawChart('atlas-chart', JSON.stringify([{x: years, y: counts, type:'bar', marker:{color:'#4fc3f7'}}]), JSON.stringify({title:`出願件数推移 (${start}-${end})`, height:450}));
                }
                return;
            }

            if (chartType === 'applicant') {
                const applicantCount = parseInt(document.getElementById('atlas-applicant-count').value, 10) || topN;
                debugLog('[QuickAtlas] applicantCount:', applicantCount);
                const allApps = rows.flatMap(r => r.applicant_list);
                const counts = {};
                allApps.forEach(a => { if (a) counts[a] = (counts[a] || 0) + 1; });
                const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0, applicantCount);
                const names = top.map(t => t[0]);
                const displayNames = names.map(n => truncateApplicantName(n, 30));
                const displayNamesReversed = [...displayNames].reverse();
                const leftMargin = Math.min(350, Math.max(150, maxNameLen * 9));
                debugLog('[QuickAtlas] names count:', names.length, 'leftMargin:', leftMargin);
                
                if (useStatus && colStatus !== '(未選択)') {
                    const statuses = Array.from(new Set(rows.map(r => r.status))).sort();
                    debugLog('[QuickAtlas] statuses:', statuses);
                    const statusMap = quickStatusMap(statuses);
                    const traces = statuses.map(st => ({
                        x: names.map(n => rows.filter(r => r.status === st && r.applicant_list.includes(n)).length),
                        y: displayNames,
                        customdata: names,
                        hovertemplate: '%{customdata}<br>%{x}件<extra>%{fullData.name}</extra>',
                        textposition: 'none',
                        type:'bar',
                        orientation:'h',
                        name: st,
                        marker:{color: statusMap[st]}
                    }));
                    const layout = {
                        title:`出願人ランキング TOP${applicantCount} - ステータス別`, 
                        barmode:'stack', 
                        height: Math.max(500, applicantCount * 30 + 100), 
                        margin:{l: leftMargin, b: 100, t: 50},
                        yaxis: {
                            categoryorder: 'array',
                            categoryarray: displayNamesReversed,
                            automargin: true
                        }
                    };
                    applyStatusLegend(layout, 100);
                    drawChart('atlas-chart', JSON.stringify(traces), JSON.stringify(layout));
                } else {
                    const traces = [{
                        x: top.map(t=>t[1]), 
                        y: displayNames, 
                        customdata: names,
                        hovertemplate: '%{customdata}<br>%{x}件<extra></extra>',
                        textposition: 'none',
                        type:'bar', 
                        orientation:'h', 
                        marker:{color:'#81c784'}
                    }];
                    const layout = {
                        title:`出願人ランキング TOP${applicantCount}`, 
                        height: Math.max(450, applicantCount*28), 
                        margin:{l: leftMargin}, 
                        yaxis: {categoryorder: 'array', categoryarray: displayNamesReversed, automargin: true}
                    };
                    drawChart('atlas-chart', JSON.stringify(traces), JSON.stringify(layout));
                }
                return;
            }

            if (chartType === 'ipc') {
                const ipcLevel = parseInt(document.getElementById('atlas-ipc-level').value, 10);
                const ipcs = rows.flatMap(r => r.ipc_list.map(v => ipcLevel === 1 ? v.slice(0,4) : v));
                const counts = {};
                ipcs.forEach(i => { if (i) counts[i] = (counts[i] || 0) + 1; });
                const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0, topN);
                const names = top.map(t=>t[0]);
                if (useStatus && colStatus !== '(未選択)') {
                    const statuses = Array.from(new Set(rows.map(r => r.status))).sort();
                    const statusMap = quickStatusMap(statuses);
                    const traces = statuses.map(st => ({
                        x: names.map(n => rows.filter(r => r.status === st && r.ipc_list.some(v => (ipcLevel === 1 ? v.slice(0,4) : v) === n)).length),
                        y: names,
                        type:'bar',
                        orientation:'h',
                        name: st,
                        marker:{color: statusMap[st]}
                    }));
                    const layout = {title:`IPCランキング TOP${topN} - ステータス別`, barmode:'stack', height: Math.max(450, topN*28), margin:{l:120}};
                    applyStatusLegend(layout, 80);
                    drawChart('atlas-chart', JSON.stringify(traces), JSON.stringify(layout));
                } else {
                    drawChart('atlas-chart', JSON.stringify([{x: top.map(t=>t[1]), y: names, type:'bar', orientation:'h', marker:{color:'#ffb74d'}}]), JSON.stringify({title:`IPCランキング TOP${topN}`, height: Math.max(450, topN*28), margin:{l:120}}));
                }
                return;
            }

            document.getElementById('atlas-chart').innerHTML = '<div class="status-warn">このチャートはPython起動後に利用できます</div>';
        }

        // ============================================================================
        // 通知・フィードバック関数
        // ============================================================================

        /**
         * トースト通知を表示
         * @param {string} message - 表示するメッセージ
         * @param {'info'|'success'|'warning'|'error'} [type='info'] - 通知タイプ
         * @param {number} [duration=3000] - 表示時間 (ms)
         */
        function showToast(message, type = 'info', duration = TOAST_DURATION_DEFAULT) {
            let container = document.querySelector('.toast-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'toast-container';
                document.body.appendChild(container);
            }

            const icons = {
                success: '✅',
                warning: '⚠️',
                error: '❌',
                info: 'ℹ️'
            };

            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${message}</span>
                <button class="toast-close" onclick="this.parentElement.remove()">×</button>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'toast-slide-in 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ============================================================================
        // CORE モジュール用イベントハンドラ
        // ============================================================================

        /**
         * CORE分類ルールを削除
         * @param {Event} event - クリックイベント
         */
        window.coreDeleteRule = function (event) {
            const axis = event.target.getAttribute('data-axis');
            const name = event.target.getAttribute('data-name');
            if (axis && name) {
                window.pyodide_globals.core_delete_rule(axis, name);
            }
        };

        /**
         * CORE分類ルールを編集モードに切り替え
         * @param {Event} event - クリックイベント
         */
        window.coreEditRule = function (event) {
            const axis = event.target.getAttribute('data-axis');
            const name = event.target.getAttribute('data-name');
            if (axis && name) {
                window.pyodide_globals.core_edit_rule(axis, name);
            }
            const addBtn = document.getElementById('btn-core-add');
            const updBtn = document.getElementById('btn-core-update');
            const cancelBtn = document.getElementById('btn-core-cancel');
            if (addBtn && updBtn) {
                addBtn.style.display = 'none';
                updBtn.style.display = 'inline-block';
            }
            if (cancelBtn) cancelBtn.style.display = 'inline-block';
        };

        // ============================================================================
        // ページナビゲーション
        // ============================================================================

        /**
         * 指定されたページを表示
         * @param {string} page - 表示するページのID (例: 'home', 'atlas', 'core')
         */
        function showPage(page) {
            // すべてのページを隠す
            document.querySelectorAll('.page').forEach(p => {
                if (p.id !== 'page-' + page) {
                    p.classList.add('hidden');
                    p.classList.remove('fade-in', 'fade-out');
                }
            });
            
            // ナビボタンのアクティブ状態をリセット
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            
            // 対象ページを表示
            const targetPage = document.getElementById('page-' + page);
            if (targetPage) {
                targetPage.classList.remove('hidden');
                targetPage.classList.add('fade-in');
                setTimeout(() => targetPage.classList.remove('fade-in'), 300);
                currentPage = targetPage;
            }
            
            // 対応するナビボタンをアクティブに
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.getAttribute('onclick')?.includes("'" + page + "'")) {
                    btn.classList.add('active');
                }
            });
        }

        /**
         * クイックランチ (ホームページからの分析開始)
         */
        function quickLaunch() {
            const btn = document.getElementById('btn-launch');
            if (btn) btn.click();
        }

        // ============================================================================
        // ダッシュボード関数
        // ============================================================================

        /**
         * ダッシュボードの統計情報を更新
         * @param {number} total - 総件数
         * @param {string} years - 期間 (例: "2000-2024")
         * @param {number} applicants - 出願人数
         */
        function updateDashboardStats(total, years, applicants) {
            const elTotal = document.getElementById('home-stat-total');
            const elYears = document.getElementById('home-stat-years');
            const elApplicants = document.getElementById('home-stat-applicants');
            
            if (elTotal) animateValue(elTotal, 0, total, 1000);
            if (elYears) elYears.textContent = years || '-';
            if (elApplicants) animateValue(elApplicants, 0, applicants, 800);
        }

        /**
         * 数値をアニメーション表示
         * @param {HTMLElement} el - 対象要素
         * @param {number} start - 開始値
         * @param {number} end - 終了値
         * @param {number} duration - アニメーション時間 (ms)
         */
        function animateValue(el, start, end, duration) {
            if (!el || typeof end !== 'number') {
                el.textContent = end?.toLocaleString() || '-';
                return;
            }
            const startTime = performance.now();
            const update = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                const current = Math.floor(start + (end - start) * eased);
                el.textContent = current.toLocaleString();
                if (progress < 1) requestAnimationFrame(update);
            };
            requestAnimationFrame(update);
        }
        
        
        function updateDashboardPreview(dataJson) {
            const emptyState = document.getElementById('home-preview-container');
            const grid = document.getElementById('home-preview-grid');
            
            if (!dataJson) return;
            
            let data;
            try {
                data = typeof dataJson === 'string' ? JSON.parse(dataJson) : dataJson;
            } catch(e) {
                console.error('Failed to parse preview data:', e);
                return;
            }
            
            if (emptyState) emptyState.style.display = 'none';
            if (grid) {
                grid.classList.remove('hidden');
                grid.style.display = 'block';
            }
            
            setTimeout(() => drawPreviewTrendD3(data.yearCounts), 0);
            setTimeout(() => drawPreviewApplicantsD3(data.topApplicants), 100);
            setTimeout(() => drawPreviewIPCD3(data.topIPC), 200);
            setTimeout(() => drawPreviewKeywords(data.topKeywords), 300);
        }
        
        
        function drawPreviewTrendD3(yearCounts) {
            const container = document.getElementById('preview-trend');
            if (!container || !yearCounts || !d3) return;
            
            container.innerHTML = '';
            
            const margin = { top: 10, right: 15, bottom: 25, left: 35 };
            const width = (container.clientWidth || 250) - margin.left - margin.right;
            const height = (container.clientHeight || 140) - margin.top - margin.bottom;
            
            const years = Object.keys(yearCounts).map(Number).sort((a, b) => a - b);
            const data = years.map(y => ({ year: y, count: yearCounts[y] }));
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'areaGradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '0%').attr('y2', '100%');
            gradient.append('stop').attr('offset', '0%').attr('stop-color', '#4fc3f7').attr('stop-opacity', 0.6);
            gradient.append('stop').attr('offset', '100%').attr('stop-color', '#4fc3f7').attr('stop-opacity', 0.05);
            
            const x = d3.scaleLinear()
                .domain(d3.extent(years))
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.count) * 1.1])
                .range([height, 0]);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format('d')))
                .attr('color', '#5a6f85')
                .selectAll('text').attr('fill', '#9fb3c8').style('font-size', '9px');
            
            svg.append('g')
                .call(d3.axisLeft(y).ticks(4).tickFormat(d => d >= 1000 ? (d/1000)+'k' : d))
                .attr('color', '#5a6f85')
                .selectAll('text').attr('fill', '#9fb3c8').style('font-size', '9px');
            
            const area = d3.area()
                .x(d => x(d.year))
                .y0(height)
                .y1(d => y(d.count))
                .curve(d3.curveMonotoneX);
            
            const areaPath = svg.append('path')
                .datum(data)
                .attr('fill', 'url(#areaGradient)')
                .attr('d', area)
                .attr('opacity', 0);
            
            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.count))
                .curve(d3.curveMonotoneX);
            
            const linePath = svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#4fc3f7')
                .attr('stroke-width', 2.5)
                .attr('d', line);
            
            const totalLength = linePath.node().getTotalLength();
            linePath
                .attr('stroke-dasharray', totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .duration(1200)
                .ease(d3.easeCubicOut)
                .attr('stroke-dashoffset', 0);
            
            areaPath.transition()
                .delay(400)
                .duration(800)
                .attr('opacity', 1);
            
            svg.selectAll('.sparkline-dot')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.year))
                .attr('cy', d => y(d.count))
                .attr('r', 0)
                .attr('fill', '#4fc3f7')
                .attr('stroke', '#0d1117')
                .attr('stroke-width', 2)
                .transition()
                .delay((_, i) => 800 + i * 50)
                .duration(300)
                .attr('r', 4);
        }
        
        
        function drawPreviewApplicantsD3(topApplicants) {
            const container = document.getElementById('preview-applicants');
            const legendContainer = document.getElementById('preview-applicants-legend');
            if (!container || !topApplicants || !d3) return;
            
            container.innerHTML = '';
            if (legendContainer) legendContainer.innerHTML = '';
            
            const width = container.clientWidth || 100;
            const height = container.clientHeight || 100;
            const radius = Math.min(width, height) / 2 - 3;
            
            const entries = Object.entries(topApplicants).slice(0, 5);
            const data = entries.map(([name, value]) => ({ name, value }));
            const total = d3.sum(data, d => d.value);
            
            const colors = ['#4fc3f7', '#a855f7', '#10b981', '#f59e0b', '#ef4444'];
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width/2},${height/2})`);
            
            const pie = d3.pie()
                .value(d => d.value)
                .sort(null)
                .padAngle(0.02);
            
            const arc = d3.arc()
                .innerRadius(radius * 0.5)
                .outerRadius(radius);
            
            const arcHover = d3.arc()
                .innerRadius(radius * 0.5)
                .outerRadius(radius + 4);
            
            const paths = svg.selectAll('path')
                .data(pie(data))
                .enter()
                .append('path')
                .attr('fill', (_, i) => colors[i])
                .attr('stroke', '#0d1117')
                .attr('stroke-width', 1.5)
                .style('cursor', 'pointer')
                .each(function(d) { this._current = { startAngle: 0, endAngle: 0 }; });
            
            paths.transition()
                .duration(1000)
                .ease(d3.easeCubicOut)
                .attrTween('d', function(d) {
                    const interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(1);
                    return t => arc(interpolate(t));
                });
            
            paths.on('mouseover', function(event, d) {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('d', arcHover);
            })
            .on('mouseout', function(event, d) {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('d', arc);
            });
            
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.1em')
                .attr('fill', '#e0e6ed')
                .style('font-size', '11px')
                .style('font-weight', '600')
                .text(total >= 1000 ? (total/1000).toFixed(1) + 'k' : total)
                .style('opacity', 0)
                .transition()
                .delay(600)
                .duration(500)
                .style('opacity', 1);
            
            if (legendContainer) {
                data.forEach((d, i) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.35rem; opacity: 0; transition: opacity 0.3s;';
                    
                    const colorBox = document.createElement('span');
                    colorBox.style.cssText = `width: 10px; height: 10px; border-radius: 2px; background: ${colors[i]}; flex-shrink: 0;`;
                    
                    const label = document.createElement('span');
                    label.style.cssText = 'color: #9fb3c8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; flex: 1;';
                    const shortName = d.name.length > 25 ? d.name.slice(0, 25) + '…' : d.name;
                    label.textContent = shortName;
                    label.title = d.name;
                    
                    const value = document.createElement('span');
                    value.style.cssText = 'color: #e0e6ed; margin-left: auto; font-weight: 500;';
                    value.textContent = d.value.toLocaleString();
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    item.appendChild(value);
                    legendContainer.appendChild(item);
                    
                    setTimeout(() => { item.style.opacity = '1'; }, 700 + i * 100);
                });
            }
        }
        
        
        function drawPreviewIPCD3(topIPC) {
            const container = document.getElementById('preview-ipc');
            if (!container || !topIPC || !d3) return;
            
            container.innerHTML = '';
            
            const margin = { top: 5, right: 40, bottom: 5, left: 55 };
            const width = (container.clientWidth || 250) - margin.left - margin.right;
            const height = (container.clientHeight || 100) - margin.top - margin.bottom;
            
            const entries = Object.entries(topIPC)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            const data = entries.map(([name, value]) => ({ name, value }));
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const defs = svg.append('defs');
            data.forEach((d, i) => {
                const grad = defs.append('linearGradient')
                    .attr('id', `barGrad${i}`)
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '100%').attr('y2', '0%');
                const hue = 190 + i * 25;
                grad.append('stop').attr('offset', '0%').attr('stop-color', `hsl(${hue}, 70%, 45%)`);
                grad.append('stop').attr('offset', '100%').attr('stop-color', `hsl(${hue}, 70%, 60%)`);
            });
            
            const x = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.value) * 1.1])
                .range([0, width]);
            
            const y = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([0, height])
                .padding(0.3);
            
            svg.selectAll('.label')
                .data(data)
                .enter()
                .append('text')
                .attr('x', -5)
                .attr('y', d => y(d.name) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .attr('fill', '#9fb3c8')
                .style('font-size', '9px')
                .text(d => d.name.length > 7 ? d.name.slice(0, 7) : d.name);
            
            const bars = svg.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('x', 0)
                .attr('y', d => y(d.name))
                .attr('height', y.bandwidth())
                .attr('fill', (_, i) => `url(#barGrad${i})`)
                .attr('rx', 3)
                .attr('width', 0);
            
            bars.transition()
                .duration(800)
                .delay((_, i) => i * 100)
                .ease(d3.easeCubicOut)
                .attr('width', d => x(d.value));
            
            svg.selectAll('.value')
                .data(data)
                .enter()
                .append('text')
                .attr('x', d => x(d.value) + 5)
                .attr('y', d => y(d.name) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('fill', '#e0e6ed')
                .style('font-size', '9px')
                .style('font-weight', '500')
                .style('opacity', 0)
                .text(d => d.value.toLocaleString())
                .transition()
                .delay((_, i) => 600 + i * 100)
                .duration(300)
                .style('opacity', 1);
        }
        
        
        function drawPreviewKeywords(topKeywords) {
            const container = document.getElementById('preview-keywords');
            if (!container || !topKeywords || !d3 || !d3.layout?.cloud) return;
            
            container.innerHTML = '';
            
            const width = container.clientWidth || 200;
            const height = container.clientHeight || 100;
            
            const words = Object.entries(topKeywords).slice(0, 15).map(([text, score]) => ({
                text: text,
                size: 10 + Math.sqrt(score) * 8
            }));
            
            const colors = ['#4fc3f7', '#81d4fa', '#b3e5fc', '#a855f7', '#c084fc'];
            
            d3.layout.cloud()
                .size([width, height])
                .words(words)
                .padding(2)
                .rotate(() => (Math.random() > 0.7 ? 90 : 0))
                .fontSize(d => Math.min(d.size, 18))
                .on('end', (drawnWords) => {
                    const svg = d3.select(container)
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height);
                    
                    svg.append('g')
                        .attr('transform', `translate(${width/2},${height/2})`)
                        .selectAll('text')
                        .data(drawnWords)
                        .enter()
                        .append('text')
                        .style('font-size', d => `${d.size}px`)
                        .style('font-family', 'Meiryo, sans-serif')
                        .style('fill', (_, i) => colors[i % colors.length])
                        .style('cursor', 'default')
                        .attr('text-anchor', 'middle')
                        .attr('transform', d => `translate(${d.x},${d.y}) rotate(${d.rotate})`)
                        .text(d => d.text)
                        .style('opacity', 0)
                        .transition()
                        .duration(500)
                        .delay((_, i) => i * 50)
                        .style('opacity', 1);
                })
                .start();
        }
        
        
        function setupDropZone() {
            const dropZone = document.getElementById('drop-zone');
            const fileInputHome = document.getElementById('file-input-home');
            const fileInput = document.getElementById('file-input');
            
            if (!dropZone) return;
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.endsWith('.csv')) {
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(files[0]);
                    if (fileInputHome) fileInputHome.files = dataTransfer.files;
                    if (fileInput) {
                        fileInput.files = dataTransfer.files;
                        fileInput.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                    updateHomeFileStatus(files[0].name);
                    showToast('success', `📄 ${files[0].name} を読み込みました`);
                } else {
                    showToast('error', 'CSVファイルのみ対応しています');
                }
            });
            
            if (fileInputHome) {
                fileInputHome.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        if (fileInput) {
                            fileInput.files = dataTransfer.files;
                            fileInput.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        updateHomeFileStatus(file.name);
                    }
                });
            }
        }

        /**
         * ホームページのファイル読み込みステータスを更新
         * @param {string} filename - 読み込んだファイル名
         */
        function updateHomeFileStatus(filename) {
            const status = document.getElementById('home-file-status');
            const launchBtn = document.getElementById('home-launch-btn');
            if (status) {
                status.innerHTML = `<span style="color: #81c784;">✅</span> ${filename} を読み込みました`;
            }
            if (launchBtn) {
                launchBtn.disabled = false;
            }
        }

        /**
         * タブを切り替え
         * @param {string} page - ページID (例: 'mega', 'explorer')
         * @param {string} tab - タブID (例: 'wordcloud', 'ngram')
         */
        function showTab(page, tab) {
            const pageId = page === 'nova' ? 'advanced' : page;
            document.querySelectorAll('#page-' + pageId + ' .tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#page-' + pageId + ' .tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(page + '-tab-' + tab).classList.add('active');
            event.target.classList.add('active');
        }
        /**
         * ATLASチャートタイプを切り替え
         * @param {string} type - チャートタイプ (例: 'trend', 'applicant', 'ipc')
         */
        function setAtlasChart(type) {
            const checkbox = document.getElementById('use-status-breakdown');
            if (checkbox && window.appState.statusBreakdownByType) {
                window.appState.statusBreakdownByType[window.appState.chartType] = checkbox.checked;
            }
            window.appState.chartType = type;
            document.querySelectorAll('#page-atlas .tabs .tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            syncAtlasStatusCheckbox();
            syncAtlasControls();
            const btn = document.getElementById('btn-atlas');
            if (btn) btn.click();
        }

        // ============================================================================
        // Plotly.js チャート描画
        // ============================================================================

        /**
         * Plotly.jsでチャートを描画
         * @param {string} divId - 描画先のコンテナ要素ID
         * @param {string} dataJson - トレースデータのJSON文字列
         * @param {string} layoutJson - レイアウト設定のJSON文字列
         */
        function drawChart(divId, dataJson, layoutJson) {
            try {
                const data = JSON.parse(dataJson);
                const layout = JSON.parse(layoutJson);
                
                // ダークテーマ設定
                layout.template = 'plotly_dark';
                layout.paper_bgcolor = layout.paper_bgcolor || 'rgba(0,0,0,0)';
                layout.plot_bgcolor = layout.plot_bgcolor || 'rgba(0,0,0,0)';
                layout.font = { color: '#e0e1dd', family: 'Meiryo, Segoe UI, sans-serif' };
                
                // タイトルの色を明示的に設定
                if (layout.title && typeof layout.title === 'string') {
                    layout.title = { text: layout.title, font: { color: '#e0e1dd' } };
                }
                
                // 軸ラベルの色を設定
                if (layout.xaxis) {
                    layout.xaxis.tickfont = layout.xaxis.tickfont || { color: '#e0e1dd' };
                    layout.xaxis.titlefont = layout.xaxis.titlefont || { color: '#e0e1dd' };
                    layout.xaxis.color = '#e0e1dd';
                }
                if (layout.yaxis) {
                    layout.yaxis.tickfont = layout.yaxis.tickfont || { color: '#e0e1dd' };
                    layout.yaxis.titlefont = layout.yaxis.titlefont || { color: '#e0e1dd' };
                    layout.yaxis.color = '#e0e1dd';
                }
                
                layout.legend = Object.assign({
                    font: { size: 11, color: '#e0e1dd' },
                    bgcolor: 'rgba(0,0,0,0.3)',
                    bordercolor: 'rgba(255,255,255,0.1)',
                    borderwidth: 1,
                    itemsizing: 'constant',
                    itemwidth: 30
                }, layout.legend || {});
                
                layout.hoverlabel = Object.assign({
                    bgcolor: 'rgba(30, 41, 59, 0.95)',
                    bordercolor: 'rgba(79, 195, 247, 0.5)',
                    font: { color: '#f1f5f9', size: 12, family: 'Meiryo, sans-serif' }
                }, layout.hoverlabel || {});
                
                const config = {
                    responsive: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                    toImageButtonOptions: {
                        format: 'png',
                        filename: 'artemis_chart',
                        height: 600,
                        width: 900,
                        scale: 2
                    }
                };
                
                Plotly.newPlot(divId, data, layout, config).then(() => {
                    const container = document.getElementById(divId);
                    if (container) {
                        container.style.opacity = '0';
                        container.style.transform = 'translateY(10px)';
                        container.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
                        requestAnimationFrame(() => {
                            container.style.opacity = '1';
                            container.style.transform = 'translateY(0)';
                        });
                    }
                });
            } catch(e) {
                console.error('Chart error:', e);
                const container = document.getElementById(divId);
                if (container) {
                    const safeMsg = String(e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    container.innerHTML = `
                        <div class="status-message error">
                            <span class="status-icon">⚠</span>
                            <div class="status-content">
                                <div class="status-title">グラフ描画エラー</div>
                                <div class="status-detail">${safeMsg}</div>
                            </div>
                        </div>`;
                }
            }
        }
        
        
        function setButtonLoading(buttonId, loading, loadingText = '') {
            const btn = document.getElementById(buttonId);
            if (!btn) return;
            
            if (loading) {
                btn.classList.add('loading');
                btn.disabled = true;
                btn.dataset.originalText = btn.innerHTML;
                if (loadingText) {
                    btn.innerHTML = `<span class="btn-text">${loadingText}</span>`;
                }
            } else {
                btn.classList.remove('loading');
                btn.disabled = false;
                if (btn.dataset.originalText) {
                    btn.innerHTML = btn.dataset.originalText;
                    delete btn.dataset.originalText;
                }
            }
        }

        /**
         * チャートコンテナにローディングオーバーレイを表示/非表示
         * @param {string} containerId - コンテナ要素ID
         * @param {boolean} show - 表示する場合true
         * @param {string} [message='読み込み中...'] - 表示するメッセージ
         */
        function showChartLoading(containerId, show, message = '読み込み中...') {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            let overlay = container.querySelector('.loading-overlay');
            
            if (show) {
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'loading-overlay';
                    overlay.innerHTML = `
                        <div class="spinner spinner-lg"></div>
                        <span class="spinner-text">${message}</span>
                    `;
                    container.style.position = 'relative';
                    container.appendChild(overlay);
                }
                requestAnimationFrame(() => overlay.classList.add('active'));
            } else if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => overlay.remove(), 300);
            }
        }

        /**
         * ステータスメッセージを表示
         * @param {string} containerId - コンテナ要素ID
         * @param {'error'|'warning'|'success'|'info'} type - メッセージタイプ
         * @param {string} title - メッセージタイトル
         * @param {string} [detail=''] - 詳細メッセージ
         */
        function showStatusMessage(containerId, type, title, detail = '') {
            const icons = { error: '❌', warning: '⚠️', success: '✅', info: 'ℹ️' };
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = `
                <div class="status-message ${type}">
                    <span class="status-icon">${icons[type] || 'ℹ️'}</span>
                    <div class="status-content">
                        <div class="status-title">${title}</div>
                        ${detail ? `<div class="status-detail">${detail}</div>` : ''}
                    </div>
                </div>`;
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js ワードクラウド
        // ─────────────────────────────────────────────────────────────

        /**
         * D3.js ワードクラウドを描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} wordsJson - 単語データJSON [{text, score}, ...]
         * @param {string} colorScheme - カラースキーム名
         */
        function drawWordCloud(divId, wordsJson, colorScheme) {
            try {
                const container = document.getElementById(divId);
                if (!container) return;
                
                container.innerHTML = '';
                
                const words = JSON.parse(wordsJson);
                if (!words || words.length === 0) {
                    container.innerHTML = '<div class="status-warn">表示するデータがありません</div>';
                    return;
                }
                
                const width = container.clientWidth || 800;
                const height = 500;
                
                const colorPalettes = {
                    'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'],
                    'plasma': ['#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786', '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'],
                    'warm': ['#6e40aa', '#bf3caf', '#fe4b83', '#ff7847', '#e2b72f', '#aff05b'],
                    'rainbow': ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'],
                    'blues': ['#08306b', '#08519c', '#2171b5', '#4292c6', '#6baed6', '#9ecae1', '#c6dbef', '#deebf7'],
                    'matplotlib': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']
                };
                const palette = colorPalettes[colorScheme] || colorPalettes['viridis'];
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('viewBox', `0 0 ${width} ${height}`)
                    .style('background', '#1a1a2e')
                    .style('border-radius', '6px');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${width/2}, ${height/2})`);
                
                const minScore = d3.min(words, d => d.score);
                const maxScore = d3.max(words, d => d.score);
                const sizeScale = d3.scaleLinear()
                    .domain([minScore, maxScore])
                    .range([12, 90]);
                
                const layout = d3.layout.cloud()
                    .size([width - 10, height - 10])
                    .words(words.map((d, i) => ({
                        text: d.text,
                        size: sizeScale(d.score),
                        score: d.score,
                        originalIndex: i
                    })))
                    .padding(2)
                    .rotate(() => {
                        const r = Math.random();
                        if (r < 0.65) return 0;
                        if (r < 0.85) return 90;
                        if (r < 0.92) return -90;
                        return (Math.random() > 0.5 ? 45 : -45);
                    })
                    .font('Impact, Arial Black, sans-serif')
                    .fontSize(d => d.size)
                    .spiral('archimedean')
                    .on('end', draw);
                
                layout.start();
                
                function draw(words) {
                    const texts = g.selectAll('text')
                        .data(words)
                        .enter()
                        .append('text')
                        .style('font-size', '0px')
                        .style('font-family', 'Impact, Arial Black, sans-serif')
                        .style('fill', (d, i) => palette[i % palette.length])
                        .style('cursor', 'pointer')
                        .attr('text-anchor', 'middle')
                        .attr('transform', d => `translate(${d.x}, ${d.y}) rotate(${d.rotate})`)
                        .text(d => d.text);
                    
                    texts.transition()
                        .duration(600)
                        .delay((d, i) => i * 8)
                        .style('font-size', d => `${d.size}px`);
                    
                    texts
                        .on('mouseover', function(event, d) {
                            d3.select(this)
                                .transition()
                                .duration(150)
                                .style('font-size', `${d.size * 1.15}px`)
                                .style('filter', 'brightness(1.3)');
                            
                            d3.select(container)
                                .append('div')
                                .attr('class', 'wc-tooltip')
                                .style('position', 'absolute')
                                .style('background', 'rgba(20,20,40,0.95)')
                                .style('color', '#fff')
                                .style('padding', '10px 14px')
                                .style('border-radius', '6px')
                                .style('font-size', '14px')
                                .style('font-family', 'Meiryo, sans-serif')
                                .style('pointer-events', 'none')
                                .style('box-shadow', '0 4px 12px rgba(0,0,0,0.4)')
                                .style('left', `${event.offsetX + 15}px`)
                                .style('top', `${event.offsetY - 35}px`)
                                .style('z-index', '1000')
                                .html(`<strong style="font-size:16px;">${d.text}</strong><br><span style="color:#aaa;">TF-IDF:</span> ${d.score.toFixed(4)}`);
                        })
                        .on('mouseout', function(event, d) {
                            d3.select(this)
                                .transition()
                                .duration(150)
                                .style('font-size', `${d.size}px`)
                                .style('filter', 'none');
                            d3.select(container).selectAll('.wc-tooltip').remove();
                        });
                    
                    debugLog(`[drawWordCloud] Rendered ${words.length} words with ${colorScheme} palette`);
                }
                
            } catch(e) {
                console.error('WordCloud error:', e);
                document.getElementById(divId).innerHTML = '<div class="status-err">ワードクラウドエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Force-Directed ネットワーク
        // ─────────────────────────────────────────────────────────────

        /**
         * D3.js Force-Directed ネットワークを描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} nodesJson - ノードデータJSON
         * @param {string} linksJson - リンクデータJSON
         * @param {string} title - グラフタイトル
         */
        function drawForceNetwork(divId, nodesJson, linksJson, title) {
            try {
                const container = document.getElementById(divId);
                if (!container) return;
                container.innerHTML = '';
                
                const nodes = JSON.parse(nodesJson);
                const links = JSON.parse(linksJson);
                
                if (!nodes.length) {
                    container.innerHTML = '<div class="status-warn">表示するデータがありません</div>';
                    return;
                }
                
                const width = container.clientWidth || 800;
                const height = 550;
                
                const colors = ['#4fc3f7', '#81c784', '#ffb74d', '#f06292', '#ba68c8', '#4db6ac', '#ff8a65', '#aed581', '#7986cb', '#e57373'];
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', 'linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%)')
                    .style('border-radius', '8px');
                
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', 25)
                    .attr('text-anchor', 'middle')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(title);
                
                const g = svg.append('g').attr('transform', 'translate(0, 30)');
                
                const simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links).id(d => d.id).distance(120).strength(0.3))
                    .force('charge', d3.forceManyBody().strength(-400))
                    .force('center', d3.forceCenter(width / 2, (height - 30) / 2))
                    .force('collision', d3.forceCollide().radius(d => d.size + 25))
                    .force('x', d3.forceX(width / 2).strength(0.05))
                    .force('y', d3.forceY((height - 30) / 2).strength(0.05));
                
                const link = g.append('g')
                    .selectAll('line')
                    .data(links)
                    .enter()
                    .append('line')
                    .style('stroke', 'rgba(255,255,255,0.2)')
                    .style('stroke-width', d => Math.sqrt(d.weight) * 0.5 + 0.5);
                
                const node = g.append('g')
                    .selectAll('g')
                    .data(nodes)
                    .enter()
                    .append('g')
                    .style('cursor', 'grab')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                node.append('circle')
                    .attr('r', d => d.size)
                    .style('fill', (d, i) => colors[d.group % colors.length])
                    .style('stroke', '#fff')
                    .style('stroke-width', 1.5)
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');
                
                node.append('text')
                    .text(d => d.label.length > 12 ? d.label.slice(0, 12) + '…' : d.label)
                    .attr('dy', 4)
                    .attr('text-anchor', 'middle')
                    .style('fill', '#fff')
                    .style('font-size', '10px')
                    .style('font-weight', 'bold')
                    .style('font-family', 'Meiryo, sans-serif')
                    .style('text-shadow', '0 1px 3px rgba(0,0,0,0.8), 0 0 8px rgba(0,0,0,0.6)')
                    .style('pointer-events', 'none');
                
                node.on('mouseover', function(event, d) {
                    d3.select(this).select('circle')
                        .transition().duration(150)
                        .attr('r', d.size * 1.3)
                        .style('filter', 'drop-shadow(0 4px 8px rgba(79,195,247,0.5))');
                    
                    d3.select(container)
                        .append('div')
                        .attr('class', 'network-tooltip')
                        .style('position', 'absolute')
                        .style('background', 'rgba(20,20,40,0.95)')
                        .style('color', '#fff')
                        .style('padding', '12px 16px')
                        .style('border-radius', '8px')
                        .style('font-size', '13px')
                        .style('font-family', 'Meiryo, sans-serif')
                        .style('pointer-events', 'none')
                        .style('box-shadow', '0 4px 16px rgba(0,0,0,0.4)')
                        .style('left', `${event.offsetX + 15}px`)
                        .style('top', `${event.offsetY - 40}px`)
                        .style('z-index', '1000')
                        .html(`<strong style="font-size:15px;color:#4fc3f7;">${d.label}</strong><br>
                               <span style="color:#aaa;">次数:</span> ${d.degree}<br>
                               <span style="color:#aaa;">中心性:</span> ${d.centrality.toFixed(3)}`);
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).select('circle')
                        .transition().duration(150)
                        .attr('r', d.size)
                        .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');
                    d3.select(container).selectAll('.network-tooltip').remove();
                });
                
                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    node.attr('transform', d => `translate(${d.x}, ${d.y})`);
                });
                
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                    d3.select(this).style('cursor', 'grabbing');
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                    d3.select(this).style('cursor', 'grab');
                }
                
                debugLog(`[drawForceNetwork] Rendered ${nodes.length} nodes, ${links.length} links`);
                
            } catch(e) {
                console.error('Network error:', e);
                document.getElementById(divId).innerHTML = '<div class="status-err">ネットワークエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js アニメーション付き横棒グラフ
        // ─────────────────────────────────────────────────────────────

        /**
         * D3.js アニメーション付き横棒グラフを描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - データJSON [{label, value}, ...]
         * @param {string} title - グラフタイトル
         * @param {string} colorScheme - カラースキーム名
         */
        function drawAnimatedBarChart(divId, dataJson, title, colorScheme) {
            try {
                const container = document.getElementById(divId);
                if (!container) return;
                container.innerHTML = '';
                
                const data = JSON.parse(dataJson);
                if (!data.length) {
                    container.innerHTML = '<div class="status-warn">表示するデータがありません</div>';
                    return;
                }
                
                const margin = {top: 40, right: 30, bottom: 20, left: 120};
                const width = (container.clientWidth || 800) - margin.left - margin.right;
                const height = Math.max(400, data.length * 28) - margin.top - margin.bottom;
                
                const gradients = {
                    'viridis': ['#440154', '#21918c', '#fde725'],
                    'plasma': ['#0d0887', '#cc4778', '#f0f921'],
                    'warm': ['#6e40aa', '#ff7847', '#aff05b'],
                    'cool': ['#4fc3f7', '#81c784', '#ffb74d']
                };
                const gradient = gradients[colorScheme] || gradients['viridis'];
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom)
                    .style('background', 'linear-gradient(180deg, #0d1b2a 0%, #1b263b 100%)')
                    .style('border-radius', '8px');
                
                svg.append('text')
                    .attr('x', (width + margin.left + margin.right) / 2)
                    .attr('y', 25)
                    .attr('text-anchor', 'middle')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(title);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)])
                    .range([0, width]);
                
                const y = d3.scaleBand()
                    .domain(data.map(d => d.label))
                    .range([0, height])
                    .padding(0.25);
                
                const colorScale = d3.scaleLinear()
                    .domain([0, data.length / 2, data.length])
                    .range(gradient);
                
                const bars = g.selectAll('.bar')
                    .data(data)
                    .enter()
                    .append('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', d => y(d.label))
                    .attr('width', 0)
                    .attr('height', y.bandwidth())
                    .attr('rx', 4)
                    .attr('ry', 4)
                    .style('fill', (d, i) => colorScale(i))
                    .style('cursor', 'pointer');
                
                bars.transition()
                    .duration(800)
                    .delay((d, i) => i * 30)
                    .attr('width', d => x(d.value));
                
                bars.on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition().duration(100)
                        .style('filter', 'brightness(1.3)')
                        .attr('height', y.bandwidth() * 1.1)
                        .attr('y', y(d.label) - y.bandwidth() * 0.05);
                })
                .on('mouseout', function(event, d) {
                    d3.select(this)
                        .transition().duration(100)
                        .style('filter', 'none')
                        .attr('height', y.bandwidth())
                        .attr('y', y(d.label));
                });
                
                g.selectAll('.value-label')
                    .data(data)
                    .enter()
                    .append('text')
                    .attr('class', 'value-label')
                    .attr('x', d => x(d.value) + 5)
                    .attr('y', d => y(d.label) + y.bandwidth() / 2)
                    .attr('dy', '0.35em')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '11px')
                    .style('font-family', 'Meiryo, sans-serif')
                    .style('opacity', 0)
                    .text(d => d.value.toFixed ? d.value.toFixed(2) : d.value)
                    .transition()
                    .duration(800)
                    .delay((d, i) => i * 30 + 400)
                    .style('opacity', 1);
                
                g.selectAll('.y-label')
                    .data(data)
                    .enter()
                    .append('text')
                    .attr('class', 'y-label')
                    .attr('x', -8)
                    .attr('y', d => y(d.label) + y.bandwidth() / 2)
                    .attr('dy', '0.35em')
                    .attr('text-anchor', 'end')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '12px')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(d => d.label.length > 15 ? d.label.slice(0, 15) + '…' : d.label);
                
                debugLog(`[drawAnimatedBarChart] Rendered ${data.length} bars`);
                
            } catch(e) {
                console.error('BarChart error:', e);
                document.getElementById(divId).innerHTML = '<div class="status-err">グラフエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Sankey ダイアグラム
        // ─────────────────────────────────────────────────────────────

        /**
         * D3.js Sankey ダイアグラムを描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - フローデータJSON {nodes, links}
         * @param {string} colorScheme - カラースキーム名
         */
        function drawSankeyDiagram(divId, dataJson, colorScheme) {
            const container = document.getElementById(divId);
            if (!container) {
                console.error('Sankey container not found:', divId);
                return;
            }
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const width = container.clientWidth || 900;
                const height = 500;
                const margin = {top: 20, right: 200, bottom: 20, left: 200};
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const sankey = d3.sankey()
                    .nodeWidth(20)
                    .nodePadding(12)
                    .extent([[0, 0], [innerWidth, innerHeight]]);
                
                const graph = sankey({
                    nodes: data.nodes.map(d => Object.assign({}, d)),
                    links: data.links.map(d => Object.assign({}, d))
                });
                
                const defs = svg.append('defs');
                
                graph.links.forEach((link, i) => {
                    const gradientId = `link-gradient-${i}`;
                    const gradient = defs.append('linearGradient')
                        .attr('id', gradientId)
                        .attr('gradientUnits', 'userSpaceOnUse')
                        .attr('x1', link.source.x1)
                        .attr('x2', link.target.x0);
                    
                    gradient.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', d3.schemeTableau10[link.source.index % 10])
                        .attr('stop-opacity', 0.7);
                    gradient.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', d3.schemeTableau10[link.target.index % 10])
                        .attr('stop-opacity', 0.7);
                    
                    link.gradientId = gradientId;
                });
                
                const links = g.append('g')
                    .attr('fill', 'none')
                    .selectAll('path')
                    .data(graph.links)
                    .enter()
                    .append('path')
                    .attr('d', d3.sankeyLinkHorizontal())
                    .attr('stroke', d => colorScheme === 'gradient' 
                        ? `url(#${d.gradientId})` 
                        : d3.schemeTableau10[d.source.index % 10])
                    .attr('stroke-width', d => Math.max(2, d.width))
                    .attr('stroke-opacity', 0.5)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        d3.select(this)
                            .attr('stroke-opacity', 0.9)
                            .attr('stroke-width', d.width + 2);
                        
                        d3.select('body').append('div')
                            .attr('class', 'sankey-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '10px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .html(`<strong>${d.source.name}</strong> → <strong>${d.target.name}</strong><br/>件数: ${d.value}`)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function(event, d) {
                        d3.select(this)
                            .attr('stroke-opacity', 0.5)
                            .attr('stroke-width', d.width);
                        d3.selectAll('.sankey-tooltip').remove();
                    });
                
                const nodes = g.append('g')
                    .selectAll('rect')
                    .data(graph.nodes)
                    .enter()
                    .append('rect')
                    .attr('x', d => d.x0)
                    .attr('y', d => d.y0)
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => Math.max(1, d.y1 - d.y0))
                    .attr('fill', (d, i) => d3.schemeTableau10[i % 10])
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('opacity', 0)
                    .transition()
                    .duration(600)
                    .delay((d, i) => i * 30)
                    .attr('opacity', 1);
                
                g.append('g')
                    .selectAll('text')
                    .data(graph.nodes)
                    .enter()
                    .append('text')
                    .attr('x', d => d.x0 < innerWidth / 2 ? d.x0 - 8 : d.x1 + 8)
                    .attr('y', d => (d.y0 + d.y1) / 2)
                    .attr('dy', '0.35em')
                    .attr('text-anchor', d => d.x0 < innerWidth / 2 ? 'end' : 'start')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '11px')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(d => d.name.length > 20 ? d.name.slice(0, 20) + '…' : d.name);
                
                debugLog(`[drawSankeyDiagram] Rendered ${graph.nodes.length} nodes, ${graph.links.length} links`);
                
            } catch(e) {
                console.error('Sankey error:', e);
                container.innerHTML = '<div class="status-err">サンキー図エラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js バブルレースチャート
        // ─────────────────────────────────────────────────────────────

        /** @type {{running: boolean, timer: number|null, yearIndex: number, initialized: boolean}} */
        window.bubbleRaceState = { running: false, timer: null, yearIndex: 0, initialized: false };

        /** バブルレースの再生を開始 */
        window.bubbleRacePlay = function() {
            const btn = document.getElementById('btn-race-play');
            if (!window.bubbleRaceState.initialized) {
                debugLog('BubbleRace: Initializing data first...');
                if (btn) btn.textContent = '準備中...';
                if (window.pyShowBubbleRace) {
                    window.pyShowBubbleRace();
                } else {
                    console.error('Python function not available');
                }
                return;
            }
            window._bubbleRacePlayInternal();
        };

        /** バブルレースを一時停止 */
        window.bubbleRacePause = function() { debugLog('BubbleRace not initialized yet'); };

        /** バブルレースをリセット */
        window.bubbleRaceReset = function() { debugLog('BubbleRace not initialized yet'); };

        /**
         * バブルレースチャートを描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 年ごとのデータJSON
         * @param {number} speed - アニメーション速度 (ms)
         */
        function drawBubbleRace(divId, dataJson, speed) {
            const container = document.getElementById(divId);
            const yearDisplay = document.getElementById('race-year-display');
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const years = Object.keys(data).sort();
                const companies = [...new Set(Object.values(data).flatMap(y => y.map(d => d.name)))];
                const colorMap = {};
                companies.forEach((c, i) => colorMap[c] = d3.schemeCategory10[i % 10]);
                
                const width = container.clientWidth || 800;
                const height = 450;
                const margin = {top: 30, right: 80, bottom: 30, left: 140};
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const maxVal = d3.max(Object.values(data).flat(), d => d.value) || 100;
                
                const x = d3.scaleLinear()
                    .domain([0, maxVal * 1.1])
                    .range([0, innerWidth]);
                
                const y = d3.scaleBand()
                    .domain(d3.range(10))
                    .range([0, innerHeight])
                    .padding(0.15);
                
                g.append('g')
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0, ${innerHeight})`)
                    .call(d3.axisBottom(x).ticks(5))
                    .selectAll('text, line, path')
                    .style('stroke', '#4fc3f7')
                    .style('fill', '#4fc3f7');
                
                function update(yearIdx) {
                    const year = years[yearIdx];
                    const yearData = data[year].slice(0, 10);
                    
                    if (yearDisplay) {
                        yearDisplay.innerHTML = `📅 ${year}`;
                    }
                    
                    const bars = g.selectAll('.race-bar')
                        .data(yearData, d => d.name);
                    
                    bars.exit()
                        .transition().duration(speed * 0.3)
                        .attr('width', 0)
                        .remove();
                    
                    const barsEnter = bars.enter()
                        .append('rect')
                        .attr('class', 'race-bar')
                        .attr('x', 0)
                        .attr('width', 0)
                        .attr('rx', 4)
                        .attr('ry', 4);
                    
                    bars.merge(barsEnter)
                        .transition().duration(speed * 0.8)
                        .attr('y', (d, i) => y(i))
                        .attr('width', d => x(d.value))
                        .attr('height', y.bandwidth())
                        .attr('fill', d => colorMap[d.name]);
                    
                    const labels = g.selectAll('.race-label')
                        .data(yearData, d => d.name);
                    
                    labels.exit().remove();
                    
                    const labelsEnter = labels.enter()
                        .append('text')
                        .attr('class', 'race-label')
                        .style('fill', '#e0e1dd')
                        .style('font-size', '11px')
                        .style('font-family', 'Meiryo, sans-serif');
                    
                    labels.merge(labelsEnter)
                        .transition().duration(speed * 0.8)
                        .attr('x', -8)
                        .attr('y', (d, i) => y(i) + y.bandwidth() / 2)
                        .attr('dy', '0.35em')
                        .attr('text-anchor', 'end')
                        .text(d => d.name.length > 12 ? d.name.slice(0, 12) + '…' : d.name);
                    
                    const values = g.selectAll('.race-value')
                        .data(yearData, d => d.name);
                    
                    values.exit().remove();
                    
                    const valuesEnter = values.enter()
                        .append('text')
                        .attr('class', 'race-value')
                        .style('fill', '#4fc3f7')
                        .style('font-size', '11px')
                        .style('font-weight', 'bold');
                    
                    values.merge(valuesEnter)
                        .transition().duration(speed * 0.8)
                        .attr('x', d => x(d.value) + 5)
                        .attr('y', (d, i) => y(i) + y.bandwidth() / 2)
                        .attr('dy', '0.35em')
                        .text(d => d.value);
                }
                
                update(0);
                window.bubbleRaceState.yearIndex = 0;
                window.bubbleRaceState.initialized = true;
                
                const btn = document.getElementById('btn-race-play');
                if (btn) btn.textContent = '▶再生';
                
                window._bubbleRacePlayInternal = function() {
                    if (window.bubbleRaceState.running) return;
                    window.bubbleRaceState.running = true;
                    
                    function step() {
                        if (!window.bubbleRaceState.running) return;
                        
                        window.bubbleRaceState.yearIndex++;
                        if (window.bubbleRaceState.yearIndex >= years.length) {
                            window.bubbleRaceState.running = false;
                            window.bubbleRaceState.yearIndex = years.length - 1;
                            const btn = document.getElementById('btn-race-play');
                            if (btn) btn.textContent = '🔄 最初から';
                            return;
                        }
                        update(window.bubbleRaceState.yearIndex);
                        window.bubbleRaceState.timer = setTimeout(step, speed);
                    }
                    step();
                };
                
                window.bubbleRacePlay = function() {
                    if (window.bubbleRaceState.yearIndex >= years.length - 1) {
                        window.bubbleRaceState.yearIndex = 0;
                        update(0);
                        const btn = document.getElementById('btn-race-play');
                        if (btn) btn.textContent = '▶再生';
                    }
                    window._bubbleRacePlayInternal();
                };
                
                window.bubbleRacePause = function() {
                    window.bubbleRaceState.running = false;
                    if (window.bubbleRaceState.timer) {
                        clearTimeout(window.bubbleRaceState.timer);
                    }
                };
                
                window.bubbleRaceReset = function() {
                    window.bubbleRacePause();
                    window.bubbleRaceState.yearIndex = 0;
                    update(0);
                };
                
                debugLog(`[drawBubbleRace] Ready with ${years.length} years of data`);
                
                // 初期化完了後、自動的に再生を開始
                setTimeout(function() {
                    window._bubbleRacePlayInternal();
                }, 300);
                
            } catch(e) {
                console.error('BubbleRace error:', e);
                container.innerHTML = '<div class="status-err">バブルレースエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Circle Packing (円充填図)
        // ─────────────────────────────────────────────────────────────

        /**
         * Circle Packing (円充填図) を描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 階層データJSON
         */
        function drawCirclePacking(divId, dataJson) {
            const container = document.getElementById(divId);
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                
                const size = Math.min(container.clientWidth || 600, 550);
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', size)
                    .attr('height', size)
                    .style('background', '#0d1b2a')
                    .style('cursor', 'pointer');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${size/2}, ${size/2})`);
                
                const color = d3.scaleSequential([0, 3], d3.interpolatePlasma);
                
                const pack = d3.pack()
                    .size([size - 4, size - 4])
                    .padding(3);
                
                const root = pack(d3.hierarchy(data)
                    .sum(d => d.value || 0)
                    .sort((a, b) => b.value - a.value));
                
                let focus = root;
                let view;
                
                const nodes = g.selectAll('circle')
                    .data(root.descendants())
                    .enter()
                    .append('circle')
                    .attr('class', d => d.children ? 'circle-parent' : 'circle-leaf')
                    .attr('fill', d => d.children ? color(d.depth) : 'rgba(79, 195, 247, 0.7)')
                    .attr('stroke', d => d.children ? 'rgba(255,255,255,0.2)' : 'none')
                    .attr('stroke-width', 1)
                    .style('opacity', 0)
                    .on('click', (event, d) => {
                        if (focus !== d) {
                            zoom(event, d);
                        }
                        showCircleDetail(d);
                        event.stopPropagation();
                    })
                    .on('mouseover', function(event, d) {
                        d3.select(this)
                            .attr('stroke', '#4fc3f7')
                            .attr('stroke-width', 2);
                        
                        const tooltip = d3.select('body').append('div')
                            .attr('class', 'circle-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '8px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .html(`<strong>${d.data.name}</strong><br/>件数: ${d.value}`)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function(event, d) {
                        d3.select(this)
                            .attr('stroke', d.children ? 'rgba(255,255,255,0.2)' : 'none')
                            .attr('stroke-width', 1);
                        d3.selectAll('.circle-tooltip').remove();
                    });
                
                const labels = g.selectAll('text')
                    .data(root.descendants().filter(d => !d.children || d.depth <= 1))
                    .enter()
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .style('fill', d => d.children ? '#fff' : '#0d1b2a')
                    .style('font-size', d => d.children ? '12px' : '10px')
                    .style('font-weight', d => d.children ? 'bold' : 'normal')
                    .style('font-family', 'Meiryo, sans-serif')
                    .style('pointer-events', 'none')
                    .style('opacity', 0)
                    .text(d => {
                        const name = d.data.name || '';
                        const maxLen = d.children ? 15 : 10;
                        return name.length > maxLen ? name.slice(0, maxLen) + '…' : name;
                    });
                
                function zoomTo(v) {
                    const k = size / v[2];
                    view = v;
                    
                    nodes.attr('transform', d => `translate(${(d.x - v[0]) * k}, ${(d.y - v[1]) * k})`)
                        .attr('r', d => d.r * k);
                    
                    labels.attr('transform', d => `translate(${(d.x - v[0]) * k}, ${(d.y - v[1]) * k})`)
                        .style('font-size', d => Math.min(12, d.r * k / 3) + 'px')
                        .style('opacity', d => d.r * k > 20 ? 1 : 0);
                }
                
                function zoom(event, d) {
                    focus = d;
                    
                    g.transition()
                        .duration(750)
                        .tween('zoom', () => {
                            const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
                            return t => zoomTo(i(t));
                        });
                }
                
                zoomTo([root.x, root.y, root.r * 2]);
                
                nodes.transition()
                    .duration(800)
                    .delay((d, i) => i * 5)
                    .style('opacity', 1);
                
                labels.transition()
                    .duration(800)
                    .delay(500)
                    .style('opacity', d => d.r * view[2] / (root.r * 2) > 20 ? 1 : 0);
                
                svg.on('click', (event) => {
                    zoom(event, root);
                    showCircleDetail(root);
                });
                
                setTimeout(() => showCircleDetail(root), 900);
                
                debugLog(`[drawCirclePacking] Rendered ${root.descendants().length} nodes`);
                
            } catch(e) {
                console.error('CirclePacking error:', e);
                container.innerHTML = '<div class="status-err">サークルパックエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }
        
        
        function showCircleDetail(node) {
            const panel = document.getElementById('circle-detail-panel');
            const title = document.getElementById('circle-detail-title');
            const content = document.getElementById('circle-detail-content');
            
            if (!panel || !content) return;
            
            const nodeValue = node.value || 0;
            const nodeName = node.data ? node.data.name : 'Unknown';
            
            title.innerHTML = `📋 ${nodeName} <span style="font-weight: normal; font-size: 0.85rem;">(${nodeValue}件)</span>`;
            
            if (window.circlePackPatents && window.circlePackPatents[nodeName]) {
                const patents = window.circlePackPatents[nodeName];
                let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                
                patents.slice(0, 50).forEach((p, i) => {
                    html += `
                        <div style="background: rgba(79, 195, 247, 0.1); border-left: 3px solid #4fc3f7; padding: 0.5rem; border-radius: 4px;">
                            <div style="font-weight: bold; color: #4fc3f7; font-size: 0.8rem;">${p.app_number || ''}</div>
                            <div style="color: #e0e1dd; margin-top: 0.2rem;">${(p.title || '').slice(0, 60)}${(p.title || '').length > 60 ? '...' : ''}</div>
                            <div style="color: #888; font-size: 0.75rem; margin-top: 0.2rem;">
                                ${p.year || ''} | ${(p.applicant || '').slice(0, 25)}${(p.applicant || '').length > 25 ? '...' : ''}
                            </div>
                        </div>
                    `;
                });
                
                if (patents.length > 50) {
                    html += `<div style="color: #888; text-align: center; padding: 0.5rem;">...他 ${patents.length - 50} 件</div>`;
                }
                html += '</div>';
                content.innerHTML = html;
            } else {
                if (node.children && node.children.length > 0) {
                    let html = '<div style="display: flex; flex-direction: column; gap: 0.4rem;">';
                    node.children.forEach(child => {
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(79, 195, 247, 0.1); padding: 0.4rem 0.6rem; border-radius: 4px;">
                                <span style="color: #e0e1dd;">${child.data.name}</span>
                                <span style="color: #4fc3f7; font-weight: bold;">${child.value}件</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                    html += `<div style="color: #888; font-size: 0.8rem; margin-top: 1rem; text-align: center;">💡 個別案件を見るには下位階層をダブルクリック</div>`;
                    content.innerHTML = html;
                } else {
                    content.innerHTML = `
                        <div style="color: #888; text-align: center; padding: 2rem;">
                            <div style="font-size: 2rem; margin-bottom: 0.5rem;">📊</div>
                            <div>${nodeName}: ${nodeValue}件</div>
                            <div style="font-size: 0.8rem; margin-top: 0.5rem;">詳細な案件データは階層設定で取得されます</div>
                        </div>
                    `;
                }
            }
            
            panel.style.display = 'block';
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Sunburst (サンバースト図)
        // ─────────────────────────────────────────────────────────────

        /**
         * Sunburst (サンバースト図) を描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 階層データJSON
         * @param {string} colorScheme - カラースキーム名
         */
        function drawSunburst(divId, dataJson, colorScheme) {
            const container = document.getElementById(divId);
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const width = container.clientWidth || 600;
                const height = 550;
                const radius = Math.min(width, height) / 2 - 10;
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${width/2}, ${height/2})`);
                
                const root = d3.hierarchy(data)
                    .sum(d => d.value || 0)
                    .sort((a, b) => b.value - a.value);
                
                const partition = d3.partition()
                    .size([2 * Math.PI, radius]);
                
                partition(root);
                
                const colorScale = d3[`interpolate${colorScheme}`] || d3.interpolateSpectral;
                const colorFn = (d) => {
                    if (!d.parent) return '#0d1b2a';
                    let ancestor = d;
                    while (ancestor.parent && ancestor.parent.parent) ancestor = ancestor.parent;
                    const siblings = ancestor.parent.children;
                    const idx = siblings.indexOf(ancestor);
                    const baseHue = idx / siblings.length;
                    const depth = d.depth;
                    return d3.hsl(baseHue * 360, 0.7, 0.3 + depth * 0.15).toString();
                };
                
                const arc = d3.arc()
                    .startAngle(d => d.x0)
                    .endAngle(d => d.x1)
                    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                    .padRadius(radius / 2)
                    .innerRadius(d => d.y0)
                    .outerRadius(d => d.y1 - 1);
                
                const paths = g.selectAll('path')
                    .data(root.descendants().filter(d => d.depth))
                    .enter()
                    .append('path')
                    .attr('fill', colorFn)
                    .attr('stroke', '#0d1b2a')
                    .attr('stroke-width', 0.5)
                    .style('cursor', 'pointer')
                    .each(function(d) { d.current = d; })
                    .on('click', clicked)
                    .on('mouseover', function(event, d) {
                        d3.select(this).attr('opacity', 0.8);
                        
                        d3.select('body').append('div')
                            .attr('class', 'd3-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '10px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .html(`<strong>${d.data.name}</strong><br/>件数: ${d.value}`)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('opacity', 1);
                        d3.selectAll('.d3-tooltip').remove();
                    });
                
                paths.transition()
                    .duration(800)
                    .delay((d, i) => i * 5)
                    .attrTween('d', function(d) {
                        const i = d3.interpolate({x0: 0, x1: 0, y0: d.y0, y1: d.y1}, d);
                        return t => arc(i(t));
                    });
                
                function clicked(event, p) {
                    root.each(d => {
                        d.target = {
                            x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                            x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                            y0: Math.max(0, d.y0 - p.y0),
                            y1: Math.max(0, d.y1 - p.y0)
                        };
                    });
                    
                    paths.transition()
                        .duration(750)
                        .tween('data', d => {
                            const i = d3.interpolate(d.current, d.target);
                            return t => d.current = i(t);
                        })
                        .attrTween('d', d => () => arc(d.current));
                }
                
                g.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '-0.3em')
                    .style('fill', '#4fc3f7')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .text('IPC分布');
                
                g.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '1em')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '12px')
                    .text(`全${root.value}件`);
                
                debugLog(`[drawSunburst] Rendered ${root.descendants().length} nodes`);
                
            } catch(e) {
                console.error('Sunburst error:', e);
                container.innerHTML = '<div class="status-err">サンバーストエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Chord Diagram (弦図)
        // ─────────────────────────────────────────────────────────────

        /**
         * Chord Diagram (弦図) を描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 共起マトリクスデータJSON
         */
        function drawChordDiagram(divId, dataJson) {
            const container = document.getElementById(divId);
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const width = container.clientWidth || 600;
                const height = 550;
                const margin = 100;
                const innerRadius = Math.min(width - margin * 2, height - margin * 2) * 0.38;
                const outerRadius = innerRadius + 16;
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${width/2}, ${height/2})`);
                
                const names = data.names;
                const matrix = data.matrix;
                
                const chord = d3.chord()
                    .padAngle(0.05)
                    .sortSubgroups(d3.descending);
                
                const chords = chord(matrix);
                
                const maxLabelLength = 12;
                
                const color = d3.scaleOrdinal()
                    .domain(d3.range(names.length))
                    .range(d3.schemeTableau10);
                
                const arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(outerRadius);
                
                const groups = g.append('g')
                    .selectAll('g')
                    .data(chords.groups)
                    .enter()
                    .append('g');
                
                groups.append('path')
                    .attr('fill', d => color(d.index))
                    .attr('stroke', '#0d1b2a')
                    .attr('d', arc)
                    .attr('opacity', 0)
                    .transition()
                    .duration(600)
                    .delay((d, i) => i * 50)
                    .attr('opacity', 1);
                
                groups.append('text')
                    .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
                    .attr('dy', '0.35em')
                    .attr('transform', d => `
                        rotate(${(d.angle * 180 / Math.PI - 90)})
                        translate(${outerRadius + 6})
                        ${d.angle > Math.PI ? 'rotate(180)' : ''}
                    `)
                    .attr('text-anchor', d => d.angle > Math.PI ? 'end' : 'start')
                    .style('fill', '#e0e1dd')
                    .style('font-size', '9px')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(d => {
                        const name = names[d.index];
                        return name.length > maxLabelLength ? name.slice(0, maxLabelLength) + '…' : name;
                    })
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        const tooltip = d3.select('body').append('div')
                            .attr('class', 'd3-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '8px 12px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .style('white-space', 'nowrap')
                            .text(names[d.index])
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.selectAll('.d3-tooltip').remove();
                    });
                
                const ribbon = d3.ribbon()
                    .radius(innerRadius);
                
                g.append('g')
                    .attr('fill-opacity', 0.7)
                    .selectAll('path')
                    .data(chords)
                    .enter()
                    .append('path')
                    .attr('d', ribbon)
                    .attr('fill', d => color(d.source.index))
                    .attr('stroke', d => d3.rgb(color(d.source.index)).darker())
                    .style('cursor', 'pointer')
                    .attr('opacity', 0)
                    .transition()
                    .duration(800)
                    .delay((d, i) => 300 + i * 20)
                    .attr('opacity', 0.7)
                    .selection()
                    .on('mouseover', function(event, d) {
                        d3.select(this).attr('opacity', 1);
                        
                        const tooltip = d3.select('body').append('div')
                            .attr('class', 'd3-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '10px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .html(`<strong>${names[d.source.index]}</strong> ↔ <strong>${names[d.target.index]}</strong><br/>共起: ${d.source.value}件`)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('opacity', 0.7);
                        d3.selectAll('.d3-tooltip').remove();
                    });
                
                debugLog(`[drawChordDiagram] Rendered ${names.length} nodes, ${chords.length} chords`);
                
            } catch(e) {
                console.error('ChordDiagram error:', e);
                container.innerHTML = '<div class="status-err">コード図エラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Streamgraph (ストリームグラフ)
        // ─────────────────────────────────────────────────────────────

        /**
         * Streamgraph (ストリームグラフ) を描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 時系列データJSON
         */
        function drawStreamgraph(divId, dataJson) {
            const container = document.getElementById(divId);
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const width = container.clientWidth || 800;
                const height = 450;
                const margin = {top: 20, right: 150, bottom: 40, left: 50};
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const keys = data.keys;
                const series = data.series;
                
                const x = d3.scaleLinear()
                    .domain(d3.extent(series, d => d.year))
                    .range([0, innerWidth]);
                
                const stack = d3.stack()
                    .keys(keys)
                    .offset(d3.stackOffsetWiggle)
                    .order(d3.stackOrderInsideOut);
                
                const stacked = stack(series);
                
                const y = d3.scaleLinear()
                    .domain([
                        d3.min(stacked, layer => d3.min(layer, d => d[0])),
                        d3.max(stacked, layer => d3.max(layer, d => d[1]))
                    ])
                    .range([innerHeight, 0]);
                
                const color = d3.scaleOrdinal()
                    .domain(keys)
                    .range(d3.schemeTableau10);
                
                const area = d3.area()
                    .curve(d3.curveBasis)
                    .x(d => x(d.data.year))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]));
                
                g.selectAll('path')
                    .data(stacked)
                    .enter()
                    .append('path')
                    .attr('fill', d => color(d.key))
                    .attr('stroke', '#0d1b2a')
                    .attr('stroke-width', 0.5)
                    .style('cursor', 'pointer')
                    .attr('d', area)
                    .attr('opacity', 0)
                    .on('mouseover', function(event, d) {
                        d3.select(this).attr('opacity', 1);
                        g.selectAll('path').filter(p => p !== d).attr('opacity', 0.3);
                        
                        const tooltip = d3.select('body').append('div')
                            .attr('class', 'd3-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(13, 27, 42, 0.95)')
                            .style('border', '1px solid #4fc3f7')
                            .style('border-radius', '6px')
                            .style('padding', '10px')
                            .style('color', '#e0e1dd')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '9999')
                            .html(`<strong>${d.key}</strong>`)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        g.selectAll('path').attr('opacity', 0.85);
                        d3.selectAll('.d3-tooltip').remove();
                    })
                    .transition()
                    .duration(1000)
                    .delay((d, i) => i * 100)
                    .attr('opacity', 0.85);
                
                g.append('g')
                    .attr('transform', `translate(0, ${innerHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format('d')).ticks(10))
                    .selectAll('text, line, path')
                    .style('stroke', '#666')
                    .style('fill', '#888');
                
                const legend = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 10}, 30)`);
                
                keys.forEach((key, i) => {
                    const lg = legend.append('g')
                        .attr('transform', `translate(0, ${i * 22})`);
                    
                    lg.append('rect')
                        .attr('width', 14)
                        .attr('height', 14)
                        .attr('fill', color(key))
                        .attr('rx', 2);
                    
                    lg.append('text')
                        .attr('x', 20)
                        .attr('y', 11)
                        .style('fill', '#e0e1dd')
                        .style('font-size', '11px')
                        .style('font-family', 'Meiryo, sans-serif')
                        .text(key.length > 12 ? key.slice(0, 12) + '…' : key);
                });
                
                debugLog(`[drawStreamgraph] Rendered ${keys.length} streams`);
                
            } catch(e) {
                console.error('Streamgraph error:', e);
                container.innerHTML = '<div class="status-err">ストリームグラフエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // D3.js Dendrogram (デンドログラム)
        // ─────────────────────────────────────────────────────────────

        /**
         * Dendrogram (デンドログラム) を描画
         * @param {string} divId - 描画先コンテナID
         * @param {string} dataJson - 階層クラスタリングデータJSON
         */
        function drawDendrogram(divId, dataJson) {
            const container = document.getElementById(divId);
            if (!container) return;
            
            try {
                const data = JSON.parse(dataJson);
                container.innerHTML = '';
                
                const width = container.clientWidth || 800;
                const height = 500;
                const margin = {top: 20, right: 150, bottom: 20, left: 50};
                
                const svg = d3.select('#' + divId)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0d1b2a');
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const root = d3.hierarchy(data);
                
                const cluster = d3.cluster()
                    .size([innerHeight, innerWidth - 100]);
                
                cluster(root);
                
                const link = g.selectAll('.link')
                    .data(root.links())
                    .enter()
                    .append('path')
                    .attr('class', 'link')
                    .attr('fill', 'none')
                    .attr('stroke', '#4fc3f7')
                    .attr('stroke-opacity', 0.5)
                    .attr('stroke-width', 1.5)
                    .attr('d', d => `
                        M${d.source.y},${d.source.x}
                        H${(d.source.y + d.target.y) / 2}
                        V${d.target.x}
                        H${d.target.y}
                    `);
                
                const totalLength = link.node() ? link.node().getTotalLength() : 0;
                link.attr('stroke-dasharray', totalLength)
                    .attr('stroke-dashoffset', totalLength)
                    .transition()
                    .duration(1500)
                    .delay((d, i) => i * 20)
                    .attr('stroke-dashoffset', 0);
                
                const node = g.selectAll('.node')
                    .data(root.descendants())
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.y}, ${d.x})`);
                
                node.append('circle')
                    .attr('r', 4)
                    .attr('fill', d => d.children ? '#4fc3f7' : '#e91e63')
                    .attr('stroke', '#0d1b2a')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .delay((d, i) => 800 + i * 30)
                    .attr('opacity', 1);
                
                node.append('text')
                    .attr('dy', '0.35em')
                    .attr('x', 10)
                    .style('fill', '#e0e1dd')
                    .style('font-size', '11px')
                    .style('font-family', 'Meiryo, sans-serif')
                    .text(d => d.data.name.length > 20 ? d.data.name.slice(0, 20) + '…' : d.data.name)
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .delay((d, i) => 1200 + i * 30)
                    .attr('opacity', 1);
                
                debugLog(`[drawDendrogram] Rendered ${root.descendants().length} nodes`);
                
            } catch(e) {
                console.error('Dendrogram error:', e);
                container.innerHTML = '<div class="status-err">デンドログラムエラー: ' + (e.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
            }
        }

        // ─────────────────────────────────────────────────────────────
        // スナップショット機能
        // ─────────────────────────────────────────────────────────────

        /** @type {Array<{id: number, name: string, timestamp: string, dataUrl: string}>} */
        window.snapshotList = [];

        /**
         * チャートをスナップショットとして保存
         * @param {string} chartId - チャートコンテナのID
         * @param {string} chartName - スナップショット名
         */
        function saveSnapshot(chartId, chartName) {
            const chartDiv = document.getElementById(chartId);
            if (!chartDiv) {
                alert('保存するチャートがありません');
                return;
            }
            
            if (chartDiv.data) {
                Plotly.toImage(chartDiv, {format: 'png', width: 1200, height: 800})
                    .then(dataUrl => {
                        addSnapshotToGallery(chartName, dataUrl);
                    })
                    .catch(err => {
                        console.error('Snapshot error:', err);
                        alert('スナップショット保存に失敗しました');
                    });
                return;
            }
            
            if (svg) {
                try {
                    const serializer = new XMLSerializer();
                    const svgStr = serializer.serializeToString(svg);
                    const svgBlob = new Blob([svgStr], {type: 'image/svg+xml;charset=utf-8'});
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = function() {
                        canvas.width = img.width || 1200;
                        canvas.height = img.height || 800;
                        
                        ctx.fillStyle = '#0d1b2a';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        
                        const dataUrl = canvas.toDataURL('image/png');
                        addSnapshotToGallery(chartName, dataUrl);
                        URL.revokeObjectURL(img.src);
                    };
                    
                    img.onerror = function() {
                        console.error('SVG to PNG conversion failed');
                        alert('スナップショット保存に失敗しました');
                    };
                    
                    img.src = URL.createObjectURL(svgBlob);
                } catch(e) {
                    console.error('SVG snapshot error:', e);
                    alert('スナップショット保存に失敗しました');
                }
                return;
            }
            
            alert('保存するチャートがありません');
        }

        /**
         * スナップショットをギャラリーに追加
         * @param {string} chartName - チャート名
         * @param {string} dataUrl - Base64エンコードされた画像URL
         */
        function addSnapshotToGallery(chartName, dataUrl) {
            const timestamp = new Date().toLocaleString('ja-JP');
            const snapshot = {
                id: Date.now(),
                name: chartName,
                timestamp: timestamp,
                dataUrl: dataUrl
            };
            window.snapshotList.push(snapshot);
            updateSnapshotGallery();
            alert(`📸 スナップショットを保存しました: ${chartName}`);
        }

        /** スナップショットギャラリーの表示を更新 */
        function updateSnapshotGallery() {
            const gallery = document.getElementById('snapshot-gallery');
            if (!gallery) return;
            
            if (window.snapshotList.length === 0) {
                gallery.innerHTML = '<p style="color: #888;">保存されたスナップショットはありません</p>';
                return;
            }
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">';
            window.snapshotList.forEach((snap, idx) => {
                html += `
                    <div class="snapshot-item" style="background: rgba(0,0,0,0.3); padding: 0.5rem; border-radius: 8px;">
                        <img src="${snap.dataUrl}" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="downloadSnapshot(${snap.id})">
                        <div style="margin-top: 0.3rem; font-size: 0.8rem;">
                            <div style="font-weight: bold;">${snap.name}</div>
                            <div style="color: #888;">${snap.timestamp}</div>
                            <button class="btn btn-small" onclick="downloadSnapshot(${snap.id})" style="margin-top: 0.3rem; font-size: 0.75rem; padding: 0.2rem 0.5rem;">ダウンロード</button>
                            <button class="btn btn-small btn-danger" onclick="deleteSnapshot(${snap.id})" style="margin-top: 0.3rem; font-size: 0.75rem; padding: 0.2rem 0.5rem;">削除</button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            gallery.innerHTML = html;
        }

        /**
         * スナップショットをダウンロード
         * @param {number} id - スナップショットID
         */
        function downloadSnapshot(id) {
            const snap = window.snapshotList.find(s => s.id === id);
            if (!snap) return;
            
            const link = document.createElement('a');
            link.href = snap.dataUrl;
            link.download = `ARTEMIS_${snap.name}_${new Date().toISOString().slice(0,10)}.png`;
            link.click();
        }

        /**
         * スナップショットを削除
         * @param {number} id - スナップショットID
         */
        function deleteSnapshot(id) {
            window.snapshotList = window.snapshotList.filter(s => s.id !== id);
            updateSnapshotGallery();
        }

        /**
         * 進捗バーを更新
         * @param {number} pct - 進捗パーセンテージ (0-100)
         */
        function updateProgress(pct) {
            document.getElementById('launch-progress-fill').style.width = pct + '%';
        }

        // ─────────────────────────────────────────────────────────────
        // 初期化処理
        // ─────────────────────────────────────────────────────────────

        bindAtlasInputs();
        // requestHeavyPackages is called from setPyReady(true) when Python is ready
        setPyReady(false);
        setupQuickFileParse();
        ensureAtlasStatusVisible();
        syncAtlasStatusCheckbox();
        syncAtlasControls();
        setTimeout(() => {
            const overlay = document.getElementById('init-overlay');
            if (overlay) overlay.style.display = 'none';
        }, 1200);

        const launchBtn = document.getElementById('btn-launch');
        if (launchBtn) {
            launchBtn.addEventListener('click', () => {
                if (!window.__pyReady) {
                    window.__pendingLaunch = true;
                    const status = document.getElementById('launch-status');
                    if (status) status.innerHTML = '<div class="status-warn">Python起動中です。起動後に自動で分析エンジンを開始します。</div>';
                }
            });
        }

        const atlasBtn = document.getElementById('btn-atlas');
        if (atlasBtn) {
            atlasBtn.addEventListener('click', () => {
                if (!window.__pyReady) {
                    quickDrawAtlas();
                }
            });
        }

        const statusToggle = document.getElementById('use-status-breakdown');
        if (statusToggle) {
            statusToggle.addEventListener('change', () => {
                if (window.appState && window.appState.statusBreakdownByType) {
                    window.appState.statusBreakdownByType[window.appState.chartType] = statusToggle.checked;
                }
                if (!window.__pyReady) {
                    quickDrawAtlas();
                    return;
                }
                const btn = document.getElementById('btn-atlas');
                if (btn) btn.click();
            });
        }

        const corePhaseSel = document.getElementById('core-phase');
        if (corePhaseSel) {
            corePhaseSel.addEventListener('change', syncCorePhase);
            syncCorePhase();
        }
        const coreAxisMode = document.getElementById('core-axis-mode');
        if (coreAxisMode) {
            coreAxisMode.addEventListener('change', syncCoreAxisMode);
            syncCoreAxisMode();
        }
        
        // Python (PyScript) からアクセスできるようにwindowに登録
        window.drawChart = drawChart;
        window.updateProgress = updateProgress;
        window.showChartLoading = showChartLoading;
        window.showStatusMessage = showStatusMessage;
        window.drawWordCloud = drawWordCloud;
        window.drawForceNetwork = drawForceNetwork;
        window.drawAnimatedBarChart = drawAnimatedBarChart;
        window.drawSankeyDiagram = drawSankeyDiagram;
        window.drawStreamgraph = drawStreamgraph;
        window.drawDendrogram = drawDendrogram;
        window.drawChordDiagram = drawChordDiagram;
        window.drawSunburst = drawSunburst;
        window.drawCirclePacking = drawCirclePacking;
        window.drawBubbleRace = drawBubbleRace;
        
        // 初期ページを設定
        currentPage = document.getElementById('page-home');
        
        // ドロップゾーンの設定
        setupDropZone();
    </script>

    <script type="py" config='{"packages": ["pandas", "numpy"]}'>
"""
================================================================================
ARTEMIS - Python分析エンジン
================================================================================

概要:
    PyScript (Pyodide WebAssemblyランタイム) でブラウザ上で実行される
    特許分析のコアロジック。
アーキテクチャ:
    - コアパッケージ (pandas, numpy) は即座に読み込み
    - 重量パッケージ (scikit-learn, networkx) は非同期で読み込み
    - 全ての可視化はJavaScript連携でPlotly.jsを使用

モジュール:
    - ATLAS: 統計チャート(トレンド、棒、ツリーマップ等)
    - COR: ルールベース分析エンジン (AND/OR/NEAR/ADJ演算子対応
    - Saturn V: TF-IDF + PCA/t-SNEランドスケープ可視化
    - Explorer: キーワード分析と共起ネットワーク
    - CREW: 発明者・出願人ネットワーク分析
    - MEGA: テキスト分析(ワードクラウド、N-gram、TF-IDF)

グローバル変数:
    g_df: CSVから読み込んだ生DataFrame
    g_df_processed: フィールド解析済みのDataFrame
    g_col_map: カラムマッピング設定
    g_core_rules: CORE分類ルール

================================================================================
"""

# Pyodideの既知の警告を抑制
import warnings
warnings.filterwarnings('ignore', message='libc not found')
warnings.filterwarnings('ignore', category=RuntimeWarning)

# ============================================================
# 標準ライブラリインポート
# ============================================================
import re
import json
import html
import unicodedata
import functools
from collections import Counter

# HTMLエスケープ用のヘルパー関数
def escape_html(text):
    """HTMLエスケープを行う（html.escapeのラッパー）"""
    return html.escape(str(text))

# ============================================================
# データ処理ライブラリ
# ============================================================
import pandas as pd
import numpy as np

# ============================================================
# PyScript/Pyodide連携
# ============================================================
from js import document, console, window
from pyodide.ffi import create_proxy
import asyncio

# デバッグログ関数（JavaScriptのdebugLog関数をラップ）
PY_DEBUG = False

def debugLog(*args):
    """コンソールにデバッグログを出力"""
    if not PY_DEBUG:
        return
    message = ' '.join(str(arg) for arg in args)
    console.log(message)

# JavaScript関数への参照（window経由でアクセス）
def drawChart(divId, dataJson, layoutJson):
    """Plotly.jsでチャートを描画"""
    window.drawChart(divId, dataJson, layoutJson)

def updateProgress(percent):
    """進捗バーを更新"""
    if hasattr(window, 'updateProgress'):
        window.updateProgress(percent)

# ============================================================
# ============================================================
# 遅延読み込みの重量パッケージ (scikit-learn, networkx)
# ============================================================

# micropip経由で非同期に読み込まれるため、初期値はNone
TfidfVectorizer = None
PCA = None
TruncatedSVD = None
TSNE = None
KMeans = None
cosine_similarity = None
euclidean_distances = None
nx = None  # networkx

async def load_heavy_packages():
    """
    scikit-learnとnetworkxをmicropip経由で非同期に読み込む。
    
    これらのパッケージは初回バンドルに含めるには大きすぎるため、
    基本UIが準備できた後にバックグラウンドで読み込む。
    Returns:
        bool: 成功した場合True、それ以外False
    """
    import micropip
    
    try:
        # 進捗UIを更新
        window.updateHeavyProgress('scikit-learn ダウンロード中...', 
            {'scikit-learn': 'ダウンロード中...', 'networkx': '不明'})
        window.updateModuleProgress('core', 'scikit-learn ダウンロード中', None)
        debugLog('[Heavy-Py] Installing scikit-learn...')
        
        await micropip.install('scikit-learn')
        debugLog('[Heavy-Py] scikit-learn installed')
        
        window.updateHeavyProgress('networkx ダウンロード中...', 
            {'scikit-learn': '完了', 'networkx': 'ダウンロード中...'})
        window.updateModuleProgress('core', 'networkx ダウンロード中', None)
        debugLog('[Heavy-Py] Installing networkx...')
        
        await micropip.install('networkx')
        debugLog('[Heavy-Py] networkx installed')
        
        # グローバル参照を初期化
        global TfidfVectorizer, PCA, TruncatedSVD, TSNE, KMeans
        global cosine_similarity, euclidean_distances, nx
        
        from sklearn.feature_extraction.text import TfidfVectorizer as _TfidfVectorizer
        from sklearn.decomposition import PCA as _PCA, TruncatedSVD as _TruncatedSVD
        from sklearn.manifold import TSNE as _TSNE
        from sklearn.cluster import KMeans as _KMeans
        from sklearn.metrics.pairwise import (
            cosine_similarity as _cosine_similarity,
            euclidean_distances as _euclidean_distances
        )
        import networkx as _nx
        
        TfidfVectorizer = _TfidfVectorizer
        PCA = _PCA
        TruncatedSVD = _TruncatedSVD
        TSNE = _TSNE
        KMeans = _KMeans
        cosine_similarity = _cosine_similarity
        euclidean_distances = _euclidean_distances
        nx = _nx
        
        debugLog('[Heavy-Py] All heavy packages initialized')
        window.updateHeavyProgress('完了', {'scikit-learn': '完了', 'networkx': '完了'})
        window.setHeavyReady(True)
        
        return True
        
    except Exception as e:
        console.error(f'[Heavy-Py] Error loading packages: {e}')
        window.updateHeavyProgress('読み込み失敗', {'scikit-learn': 'エラー', 'networkx': 'エラー'})
        window.updateModuleProgress('core', f'エラー: {str(e)[:50]}', 0)
        return False

def start_heavy_load():
    """JavaScriptから非同期パッケージ読み込みをトリガーするエントリポイント。"""
    debugLog('[Heavy-Py] start_heavy_load called')
    asyncio.ensure_future(load_heavy_packages())

# JavaScriptアクセス用に関数を登録
window.pyLoadHeavyPackages = create_proxy(start_heavy_load)

# ============================================================
# 定数クラス
# ============================================================

class Config:
    """アプリケーション設定定数"""
    # データ処理
    MAX_PREVIEW_ROWS = 20
    MAX_APPLICANT_NAME_LEN = 25
    MAX_TOP_APPLICANTS = 10
    MAX_TOP_KEYWORDS = 20
    MAX_TFIDF_FEATURES = 5000
    
    # チャート
    DEFAULT_CHART_HEIGHT = 500
    DEFAULT_CHART_MARGIN = {"t": 50, "b": 50, "l": 60, "r": 40}
    TREEMAP_MAX_ITEMS = 50
    
    # クラスタリング
    DEFAULT_N_CLUSTERS = 8
    TSNE_PERPLEXITY = 30
    
    # ネットワーク
    MAX_NETWORK_NODES = 100
    MIN_EDGE_WEIGHT = 2


class Colors:
    """カラーパレット定義"""
    # ステータス別チャート用パレット（ダークテーマ対応: 視認性の高い鮮明な色）
    PASTEL = (
        "#4fc3f7", "#81c784", "#ffb74d", "#ce93d8", "#ef5350",
        "#26a69a", "#ffa726", "#42a5f5", "#ab47bc", "#ec407a",
    )
    
    # チャート用のメインカラーシーケンス
    SEQUENCE = (
        "#4fc3f7", "#81c784", "#ffb74d", "#ce93d8", "#ef5350",
        "#26a69a", "#ffa726", "#42a5f5", "#ab47bc", "#ec407a",
        "#7e57c2", "#5c6bc0", "#29b6f6", "#26c6da", "#66bb6a",
    )
    
    # ステータス表示用
    SUCCESS = "#81c784"
    WARNING = "#ffb74d"
    ERROR = "#ef5350"
    INFO = "#4fc3f7"


# 後方互換性のためのエイリアス
PASTEL_PALETTE = list(Colors.PASTEL)
COLOR_SEQUENCE = list(Colors.SEQUENCE)

# ============================================================
# 日本語ストップワード
# ============================================================

STOPWORDS = frozenset({
    # Japanese common words
    '前記', '上記', '本発明', '実施形態', '方法', '装置', '手段', 'これ', 'それ', 'ため', 'こと',
    '場合', '等', 'も', '発明', '技術', '構成', '本実施', '一実施', '所定', '特定',
    # English common words
    'the', 'a', 'an', 'and', 'or', 'of', 'to', 'in', 'for', 'with', 'on', 'is', 'are', 'be',
    # Japanese functional words
    'する', 'される', 'できる', 'ない', 'ある', 'いる', 'について', 'における', 'として', 'によって',
    'に対して', 'および', 'ならびに', 'また', 'かつ', 'もしくは', 'これら', 'それら', '当該', '該',
})

# ============================================================
# ユーティリティ関数
# ============================================================

def ensure_sklearn() -> bool:
    """
    scikit-learnが読み込み済みで利用可能か確認する。
    Returns:
        scikit-learnが準備完了ならTrue、それ以外False
    """
    global TfidfVectorizer, PCA, TruncatedSVD, TSNE, KMeans
    global cosine_similarity, euclidean_distances
    
    if TfidfVectorizer is not None:
        return True
    
    try:
        from sklearn.feature_extraction.text import TfidfVectorizer as _TF
        from sklearn.decomposition import PCA as _PCA, TruncatedSVD as _SVD
        from sklearn.manifold import TSNE as _TSNE
        from sklearn.cluster import KMeans as _KMeans
        from sklearn.metrics.pairwise import cosine_similarity as _cos, euclidean_distances as _euc
        
        TfidfVectorizer = _TF
        PCA = _PCA
        TruncatedSVD = _SVD
        TSNE = _TSNE
        KMeans = _KMeans
        cosine_similarity = _cos
        euclidean_distances = _euc
        return True
    except Exception:
        try:
            import js
            window.requestHeavyPackages()
        except Exception:
            pass
        return False

def ensure_networkx() -> bool:
    """
    networkxが読み込み済みで利用可能か確認する。
    Returns:
        networkxが準備完了ならTrue、それ以外False
    """
    global nx
    
    if nx is not None:
        return True
    
    try:
        import networkx as _nx
        nx = _nx
        return True
    except Exception:
        try:
            import js
            window.requestHeavyPackages()
        except Exception:
            pass
        return False

def tokenize(text: str) -> list[str]:
    """
    日本語/英語テキストを分析用にトークン化する。
    
    Args:
        text: 入力テキスト文字列
        
    Returns:
        トークン語のリスト
    """
    if not isinstance(text, str):
        return []
    
    # Normalize unicode
    text = unicodedata.normalize('NFKC', text).lower()
    
    # Remove punctuation and numbers
    text = re.sub(r'[!"#$%&\'()*+,-./:;<=>?@\[\]^_`{|}~【】「」『』（）\d]', ' ', text)
    
    # Extract Japanese and English tokens
    jp_tokens = re.findall(r'[一-龥ァ-ヴー]{2,8}', text)
    en_tokens = re.findall(r'[a-z]{3,}', text)
    
    return [w for w in jp_tokens + en_tokens if w not in STOPWORDS and len(w) >= 2]

def tokenize_text(text: str) -> str:
    """テキストをトークン化してスペース区切り文字列で返す。"""
    return ' '.join(tokenize(text))

def parse_date(series: pd.Series) -> pd.Series:
    """
    各種フォーマット対応で日付カラムを解析する。
    Args:
        series: 日付値を含むpandas Series
        
    Returns:
        解析されたdatetime値のpandas Series
    """
    # Try ISO format first
    parsed = pd.to_datetime(series, errors='coerce')
    if parsed.notna().mean() > 0.5:
        return parsed
    
    # Try YYYYMMDD format
    parsed = pd.to_datetime(series, format='%Y%m%d', errors='coerce')
    if parsed.notna().mean() > 0.5:
        return parsed
    
    # Fall back to year-only
    return pd.to_datetime(series, format='%Y', errors='coerce')

def extract_ipc(text: str) -> list[str]:
    """
    テキストからIPCコードを抽出する。
    
    Args:
        text: IPCコードを含むテキスト
        
    Returns:
        見つかったユニークなIPCコードリスト
    """
    if not isinstance(text, str):
        return []
    text = unicodedata.normalize('NFKC', text).upper()
    return list(set(re.findall(r'[A-H]\d{2}[A-Z]', text)))

def parse_ipc_atlas(ipc: str, level: int) -> str:
    """
    IPCコードを指定された階層レベルに解析する。
    
    Args:
        ipc: IPCコード文字列
        level: 1=クラス、2=サブクラス+グループ
        
    Returns:
        指定レベルで解析されたIPCコード
    """
    if not isinstance(ipc, str):
        return ""
    ipc = ipc.strip().upper()
    
    if level == 1:
        return ipc[:4]
    elif level == 2:
        match = re.match(r'([A-H][0-9]{2}[A-Z]\s*[0-9]+)', ipc)
        return f"{match.group(1).strip()}/00" if match else ipc
    
    return ipc

def truncate_applicant_name(name: str, max_len: int = 25) -> str:
    """
    長い出願人名を表示用に短縮する。
    
    Args:
        name: 出願人名文字列
        max_len: 最大表示長
        
    Returns:
        必要に応じて省略記号付きで短縮された名前
    """
    if not isinstance(name, str):
        return str(name)
    
    name = name.strip()
    if len(name) <= max_len:
        return name
    
    return name[:max_len - 1] + '…'

def create_treemap_data(df: pd.DataFrame, mode: str = "ipc") -> pd.DataFrame:
    """
    ツリーマップ可視化用の階層データを作成する。
    
    Args:
        df: ipc_listまたはapplicant_listカラムを持つDataFrame
        mode: 'ipc'または'applicant'
        
    Returns:
        Plotlyツリーマップ用のDataFrame
    """
    if mode == "ipc":
        df_exploded = df['ipc_list'].explode().dropna().astype(str).str.upper()
        data = []
        for ipc in df_exploded:
            if len(ipc) >= 4:
                section = ipc[0]
                ipc_class = ipc[:3]
                subclass = ipc[:4]
                data.append([section, ipc_class, subclass])
        df_tree = pd.DataFrame(data, columns=['Section', 'Class', 'Subclass'])
        if df_tree.empty:
            return df_tree
        df_tree['count'] = 1
        return df_tree
    elif mode == "applicant":
        df_exploded = df['applicant_list'].explode().dropna()
        df_tree = df_exploded.value_counts().reset_index()
        df_tree.columns = ['Applicant', 'count']
        df_tree = df_tree.head(50)
        df_tree['Root'] = 'Total'
        return df_tree
    return pd.DataFrame()

def split_list(text: str, delim: str = ';') -> list[str]:
    """テキストを区切り文字で分割してリストにする。"""
    if not isinstance(text, str) or pd.isna(text): return []
    for d in [';', ', ', '、', '|', '\n']:
        if d in text:
            return [s.strip() for s in text.split(d) if s.strip()]
    return [text.strip()] if text.strip() else []

def normalize_status(value: str | None) -> str:
    """ステータス値を正規化する。"""
    if value is None or (isinstance(value, float) and pd.isna(value)):
        return '未設定'
    if isinstance(value, str):
        parts = split_list(value)
        return parts[0] if parts else '未設定'
    text = str(value).strip()
    return text if text else '未設定'

# ============================================================
# アプリケーション状態管理クラス
# ============================================================

class AppState:
    """
    アプリケーション全体の状態を管理するシングルトンクラス。
    グローバル変数を名前空間にカプセル化し、状態管理を一元化する。
    """
    # データ関連
    df: pd.DataFrame = None                # CSVインポートからの生DataFrame
    df_processed: pd.DataFrame = None      # フィールド解析済みのDataFrame
    col_map: dict = {}                     # カラムマッピング設定
    
    # TF-IDF関連
    tfidf_matrix = None                    # TF-IDF行列 (スパース)
    vectorizer = None                      # TfidfVectorizerインスタンス
    feature_names: list = []               # 語彙リスト
    
    # ステータス関連
    status_colors: dict = {}               # {ステータス名: 16進数色}
    status_order: list = []                # ステータスカテゴリの項目
    
    # PyScriptプロキシ (GC防止)
    proxies: list = []
    
    # CORE分モジュール
    core_rules: dict = {}                  # {軸名: [ルール]}
    core_df_classified: pd.DataFrame = None
    core_reanalyze_prompt: str = ""

    @classmethod
    def reset(cls):
        """全状態をリセット。"""
        cls.df = None
        cls.df_processed = None
        cls.col_map = {}
        cls.tfidf_matrix = None
        cls.vectorizer = None
        cls.feature_names = []
        cls.status_colors = {}
        cls.status_order = []
        cls.core_rules = {}
        cls.core_df_classified = None
        cls.core_reanalyze_prompt = ""

    @classmethod
    def has_data(cls) -> bool:
        """分析データが読み込まれているか。"""
        return cls.df_processed is not None and len(cls.df_processed) > 0
    
    @classmethod
    def has_tfidf(cls) -> bool:
        """TF-IDF行列が計算済みか。"""
        return cls.tfidf_matrix is not None
    
    @classmethod
    def has_core_classified(cls) -> bool:
        """CORE分類が完了しているか。"""
        return cls.core_df_classified is not None
    
    @classmethod
    def get_col(cls, key: str, default: str = None) -> str:
        """カラムマッピングから値を取得。"""
        val = cls.col_map.get(key, default)
        return val if val and val != '(未選択)' else default

# ============================================================
# チャート描画ヘルパー
# ============================================================

class ChartHelper:
    """
    Plotly/D3.jsチャート描画のためのヘルパークラス。
    共通レイアウト設定とトレース生成を統一化する。
    """
    # デフォルトレイアウト設定
    DEFAULT_LAYOUT = {
        "height": 450,
        "margin": {"l": 60, "r": 40, "t": 50, "b": 60},
        "paper_bgcolor": "rgba(0,0,0,0)",
        "plot_bgcolor": "rgba(0,0,0,0.1)",
        "font": {"color": "#e0e1dd", "family": "-apple-system, BlinkMacSystemFont, sans-serif"},
        "xaxis": {"gridcolor": "rgba(255,255,255,0.1)", "linecolor": "rgba(255,255,255,0.2)"},
        "yaxis": {"gridcolor": "rgba(255,255,255,0.1)", "linecolor": "rgba(255,255,255,0.2)"},
    }
    
    @classmethod
    def create_layout(cls, title: str = "", **kwargs) -> dict:
        """
        デフォルト設定をベースにレイアウトを作成。

        Args:
            title: チャートタイトル
            **kwargs: 追加/上書きするレイアウトプロパティ
        
        Returns:
            マージされたレイアウト辞書
        """
        layout = cls.DEFAULT_LAYOUT.copy()
        if title:
            layout["title"] = title
        
        # xaxis/yaxisは深いマージが必要
        for key in ["xaxis", "yaxis"]:
            if key in kwargs:
                base = layout.get(key, {}).copy()
                base.update(kwargs.pop(key))
                layout[key] = base
        
        layout.update(kwargs)
        return layout
    
    @classmethod
    def create_bar_trace(cls, x: list, y: list, name: str = None, 
                         color: str = None, orientation: str = "v") -> dict:
        """
        棒グラフトレースを生成。
        
        Args:
            x: 横棒グラフの場合は値/件数、縦棒グラフの場合はカテゴリ
            y: 横棒グラフの場合はカテゴリ、縦棒グラフの場合は値/件数
            name: トレース名
            color: 棒の色
            orientation: 'v'縦、または'h'横
        
        Returns:
            Plotlyトレース辞書
        """
        trace = {
            "x": x,
            "y": y,
            "type": "bar",
            "orientation": orientation,
        }
        if name:
            trace["name"] = name
        if color:
            trace["marker"] = {"color": color}
        return trace
    
    @classmethod
    def create_line_trace(cls, x: list, y: list, name: str = None,
                          color: str = None, mode: str = "lines+markers") -> dict:
        """折れ線グラフトレースを生成。"""
        trace = {
            "x": x,
            "y": y,
            "type": "scatter",
            "mode": mode,
        }
        if name:
            trace["name"] = name
        if color:
            trace["line"] = {"color": color, "width": 2}
            trace["marker"] = {"color": color, "size": 6}
        return trace
    
    @classmethod
    def create_stacked_bar_layout(cls, title: str, x_title: str = "", 
                                   y_title: str = "", **kwargs) -> dict:
        """積み上げ棒グラフ用レイアウトを生成。"""
        layout = cls.create_layout(
            title=title,
            barmode="stack",
            xaxis={"title": x_title},
            yaxis={"title": y_title},
            legend={"orientation": "h", "y": -0.25, "x": 0, "xanchor": "left"},
            margin={"b": 100},
            **kwargs
        )
        return layout
    
    @classmethod
    def create_horizontal_bar_layout(cls, title: str, x_title: str = "",
                                      y_title: str = "", left_margin: int = 200, 
                                      **kwargs) -> dict:
        """横棒グラフ用レイアウトを生成。"""
        layout = cls.create_layout(
            title=title,
            xaxis={"title": x_title},
            yaxis={"title": y_title, "automargin": True},
            margin={"l": left_margin},
            **kwargs
        )
        return layout
    
    @classmethod
    def draw(cls, container_id: str, traces: list, layout: dict, hide_loading: bool = True):
        """
        チャートを描画SONシリアライズ付き        
        Args:
            container_id: 描画先コンテナID
            traces: Plotlyトレースのリスト            layout: Plotlyレイアウト辞書
            hide_loading: 描画後にローディング表示を動解除するい        """
    # ローディング解除は描画完了にJS側で行われる
        if hide_loading:
            window.showChartLoading(container_id, False, '')
        drawChart(container_id, json.dumps(traces), json.dumps(layout))

# ============================================================
# UI ヘルパー関数
# ============================================================

class UIHelper:
    """
    ボタンのローディング状態、ステータスメッセージ表示などを管理する。
    UIヘルパークラス。
    """
    @staticmethod
    def set_button_loading(button_id: str, loading: bool, loading_text: str = ''):
        """ボタンのローディング状態を設定。"""
        window.setButtonLoading(button_id, loading, loading_text)
    
    @staticmethod
    def show_chart_loading(container_id: str, show: bool, message: str = '読み込み中...'):
        """チャートコンテナにローディングオーバーレイを表示"""
        window.showChartLoading(container_id, show, message)
    
    @staticmethod
    def show_status(container_id: str, status_type: str, title: str, detail: str = ''):
        """
        改善されたステータスメッセージを表示
        
        Args:
            container_id: コンテナのID
            status_type: 'error', 'warning', 'success', 'info'
            title: タイトル
            detail: 詳細メッセージ
        """
        window.showStatusMessage(container_id, status_type, title, detail)
    
    @staticmethod
    def show_error(container_id: str, title: str, detail: str = ''):
        """エラーメッセージを表示"""
        UIHelper.show_status(container_id, 'error', title, detail)
    
    @staticmethod
    def show_warning(container_id: str, title: str, detail: str = ''):
        """警告メッセージを表示"""
        UIHelper.show_status(container_id, 'warning', title, detail)
    
    @staticmethod
    def show_success(container_id: str, title: str, detail: str = ''):
        """成功メッセージを表示"""
        UIHelper.show_status(container_id, 'success', title, detail)
    
    @staticmethod
    def show_info(container_id: str, title: str, detail: str = ''):
        """情報メッセージを表示"""
        UIHelper.show_status(container_id, 'info', title, detail)
    
    @staticmethod
    def set_html(container_id: str, content: str):
        """コンテナのinnerHTMLを設定"""
        el = document.getElementById(container_id)
        if el:
            el.innerHTML = content
    
    @staticmethod
    def warn_html(container_id: str, message: str):
        """警告メッセージHTMLを直接設定"""
        UIHelper.set_html(container_id, f'<div class="status-warn">{escape_html(message)}</div>')
    
    @staticmethod
    def error_html(container_id: str, message: str):
        """エラーメッセージHTMLを直接設定"""
        UIHelper.set_html(container_id, f'<div class="status-err">{escape_html(message)}</div>')
    
    @staticmethod
    def info_html(container_id: str, message: str):
        """情報メッセージHTMLを直接設定"""
        UIHelper.set_html(container_id, f'<div class="status-info">{escape_html(message)}</div>')

# ============================================================
# データ処理のヘルパー関数
# ============================================================

def get_filtered_df(year_filter: bool = True) -> pd.DataFrame | None:
    """
    フィルタリング済みDataFrameを取得する共通関数
    
    Args:
        year_filter: 年フィルタを適用するかどうか
        
    Returns:
        フィルタリング済みDataFrame、またはデータがない場合None
    """
    if not AppState.has_data():
        return None
    df = AppState.df_processed
    if year_filter:
        start = int(document.getElementById('year-start').value)
        end = int(document.getElementById('year-end').value)
        df = df[(df['year'] >= start) & (df['year'] <= end)]
    return df

def require_data(chart_id: str = None, message: str = 'データがありません') -> bool:
    """
    データの存在を確認し、なければ警告を表示
    
    Args:
        chart_id: 警告を表示するチャートコンテナID
        message: 表示するメッセージ
        
    Returns:
        データが存在すればTrue、なければFalse
    """
    if not AppState.has_data():
        if chart_id:
            UIHelper.show_warning(chart_id, message, '先にデータをインポートしてください')
        return False
    return True

def require_tfidf(chart_id: str = None) -> bool:
    """TF-IDF処理完了確認"""
    if not AppState.has_data() or not AppState.has_tfidf():
        if chart_id:
            UIHelper.show_warning(chart_id, 'TF-IDF未処理', '先にデータをインポートしてください')
        return False
    return True

def require_core_classified(chart_id: str = None, message: str = '分類結果がありません') -> bool:
    """CORE分類済みデータの存在確認"""
    if not AppState.has_core_classified():
        if chart_id:
            UIHelper.show_warning(chart_id, message, '先に分類を実行してください')
        return False
    return True

def _create_guard_decorator(check_fn, chart_id: str, message: str):
    """
    汎用ガードデコレータファクトリ。
    
    Args:
        check_fn: 条件チェック関数 (chart_id, message) -> bool
        chart_id: エラー表示先のコンテナID
        message: 表示するエラーメッセージ
    
    Returns:
        デコレータ関数
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if not check_fn(chart_id, message):
                return
            return func(*args, **kwargs)
        return wrapper
    return decorator

def ensure_data(chart_id: str = None, message: str = 'データがありません'):
    """データの存在を確認するデコレータ。"""
    return _create_guard_decorator(
        lambda cid, msg: require_data(cid, msg), chart_id, message
    )

def ensure_tfidf(chart_id: str = None, message: str = 'TF-IDF未処理'):
    """TF-IDFデータの存在を確認するデコレータ。"""
    return _create_guard_decorator(
        lambda cid, msg: require_tfidf(cid), chart_id, message
    )

def ensure_core_classified(chart_id: str = None, message: str = '分類結果がありません'):
    """CORE分類済みデータの存在を確認するデコレータ。"""
    return _create_guard_decorator(
        lambda cid, msg: require_core_classified(cid, msg), chart_id, message
    )

def get_top_applicants(df: pd.DataFrame, n: int = 10) -> list:
    """上位N出願人を取得"""
    return df.explode('applicant_list')['applicant_list'].value_counts().head(n).index.tolist()

def get_top_ipcs(df: pd.DataFrame, n: int = 10, level: int = 4) -> list:
    """上位N個IPCを取得"""
    exp = df.explode('ipc_list')
    exp['ipc_parsed'] = exp['ipc_list'].apply(lambda x: parse_ipc_atlas(x, level))
    return exp['ipc_parsed'].value_counts().head(n).index.tolist()

# ============================================================
# 後方互換性のためのグローバル変数エイリアス
# ============================================================
# 既存コードとの互換性を維持しつつ、AppStateへ移行を促進

g_df = None
g_df_processed = None
g_col_map = {}
g_tfidf_matrix = None
g_vectorizer = None
g_feature_names = []
g_status_colors = {}
g_status_order = []
g_proxies = []
g_core_rules = {}
g_core_df_classified = None
g_core_reanalyze_prompt = ""

def sync_globals_to_appstate():
    """グローバル変数をAppStateに同期移行用ヘルパー"""
    AppState.df = g_df
    AppState.df_processed = g_df_processed
    AppState.col_map = g_col_map
    AppState.tfidf_matrix = g_tfidf_matrix
    AppState.vectorizer = g_vectorizer
    AppState.feature_names = g_feature_names
    AppState.status_colors = g_status_colors
    AppState.status_order = g_status_order
    AppState.core_rules = g_core_rules
    AppState.core_df_classified = g_core_df_classified

def sync_appstate_to_globals():
    """AppStateをグローバル変数に同期移行用ヘルパー"""
    global g_df, g_df_processed, g_col_map, g_tfidf_matrix, g_vectorizer
    global g_feature_names, g_status_colors, g_status_order
    global g_core_rules, g_core_df_classified
    
    g_df = AppState.df
    g_df_processed = AppState.df_processed
    g_col_map = AppState.col_map
    g_tfidf_matrix = AppState.tfidf_matrix
    g_vectorizer = AppState.vectorizer
    g_feature_names = AppState.feature_names
    g_status_colors = AppState.status_colors
    g_status_order = AppState.status_order
    g_core_rules = AppState.core_rules
    g_core_df_classified = AppState.core_df_classified

# ============================================================
# ファイル読み込み
# ============================================================

async def on_file_change(event):
    """
    CSVファイル選択を処理し、内容を解析する。
    
    選択されたファイルを読み込み、CSVとして解析し、
    自動検出でカラムマッピングドロップダウンを設定する。
    
    Args:
        event: JavaScriptのファイル入力changeイベント
    """
    files = event.target.files
    if files.length == 0:
        return
    
    file = files.item(0)
    
    # Read file as ArrayBuffer to detect encoding
    from js import Uint8Array
    array_buffer = await file.arrayBuffer()
    byte_array = Uint8Array.new(array_buffer)
    raw_bytes = bytes(byte_array)
    
    # Detect encoding based on BOM or content patterns
    content = None
    detected_encoding = None
    
    # Check for UTF-16 LE BOM (FF FE)
    if len(raw_bytes) >= 2 and raw_bytes[0] == 0xFF and raw_bytes[1] == 0xFE:
        content = raw_bytes.decode('utf-16-le')
        detected_encoding = 'utf-16-le'
    # Check for UTF-16 BE BOM (FE FF)
    elif len(raw_bytes) >= 2 and raw_bytes[0] == 0xFE and raw_bytes[1] == 0xFF:
        content = raw_bytes.decode('utf-16-be')
        detected_encoding = 'utf-16-be'
    # Check for UTF-8 BOM (EF BB BF)
    elif len(raw_bytes) >= 3 and raw_bytes[0] == 0xEF and raw_bytes[1] == 0xBB and raw_bytes[2] == 0xBF:
        content = raw_bytes[3:].decode('utf-8')
        detected_encoding = 'utf-8-sig'
    # Check for null bytes pattern (likely UTF-16 LE without BOM)
    elif len(raw_bytes) >= 4 and (raw_bytes[1] == 0 or raw_bytes[3] == 0):
        try:
            content = raw_bytes.decode('utf-16-le')
            detected_encoding = 'utf-16-le'
        except:
            pass
    
    # If not detected, try encodings in order
    if content is None:
        for enc in ['utf-8', 'shift_jis', 'cp932', 'utf-16']:
            try:
                content = raw_bytes.decode(enc)
                detected_encoding = enc
                break
            except (UnicodeDecodeError, LookupError):
                continue
    
    if content is None:
        show_toast('error', 'ファイルのエンコーディングを検出できませんでした')
        return
    
    try:
        from io import StringIO
        
        df = pd.read_csv(StringIO(content), dtype=str)
        
        # Update AppState (primary) and global (for backward compatibility)
        AppState.df = df
        global g_df
        g_df = df
        
        # Show preview table
        preview = document.getElementById('preview-area')
        html_str = f'<div class="status-ok">✅ {len(df):,} 行読み込み</div>'
        html_str += '<div style="overflow-x: auto; margin-top: 0.5rem;"><table class="data-table"><tr>'
        for c in list(df.columns)[:6]:
            html_str += f'<th>{escape_html(str(c))}</th>'
        html_str += '</tr>'
        for _, row in df.head(3).iterrows():
            html_str += '<tr>'
            for c in list(df.columns)[:6]:
                html_str += f'<td>{escape_html(str(row[c])[:25])}</td>'
            html_str += '</tr>'
        html_str += '</table></div>'
        preview.innerHTML = html_str
        
        # Populate column selectors
        cols = ['(未選択)'] + list(df.columns)
        for sel_id in ['col-title', 'col-abstract', 'col-date', 'col-applicant', 'col-ipc', 'col-inventor', 'col-status']:
            sel = document.getElementById(sel_id)
            if sel:
                # Prevent XSS in option values and text
                opts = ''.join(f'<option value="{escape_html(str(c))}">{escape_html(str(c))}</option>' for c in cols)
                sel.innerHTML = opts
        
        # Auto-map columns based on common naming patterns
        auto_map = {
            'col-title': ['発明名称', 'Title', 'title', '名称'],
            'col-abstract': ['要約', 'Abstract', 'abstract', '要約・抄録'],
            'col-date': ['出願日', 'Date', 'applicationDate', '出願年'],
            'col-applicant': ['出願人', 'Applicant', 'applicant', '出願人/権利者'],
            'col-ipc': ['IPC', 'FI', 'ipc', 'Fターム'],
            'col-inventor': ['発明者', 'Inventor', 'inventor'],
            'col-status': ['IPC', 'FI', 'ステータス', 'Status', 'status', '法的状況', '審査状況']
        }
        
        for sel_id, keywords in auto_map.items():
            sel = document.getElementById(sel_id)
            for kw in keywords:
                for i, c in enumerate(cols):
                    if kw.lower() in str(c).lower():
                        sel.selectedIndex = i
                        break
                else:
                    continue
                break
        
        document.getElementById('file-info').textContent = f'📂 {file.name} ({len(df):,}件)'
        
    except Exception as e:
        document.getElementById('preview-area').innerHTML = f'<div class="status-err">❌{escape_html(str(e))}</div>'

# ============================================================
# 分析エンジン初期化
# ============================================================

def launch_engine(event):
    """
    読み込んだデータで分析エンジンを初期化する。
    
    生DataFrameを処理:
    - 日付を解析し年を抽出
    - 出願人/発明者リストを分割
    - IPCコードを抽出
    - テキスト分析用のTF-IDF行列を構築
    - ステータス色分けを設定
    
    Args:
        event: ボタンクリックイベント
    """
    # AppState を優先使用しつつ、後方互換性のためグローバル変数も更新
    global g_df, g_df_processed, g_col_map, g_tfidf_matrix
    global g_vectorizer, g_feature_names, g_status_colors, g_status_order
    
    if AppState.df is None and g_df is None:
        document.getElementById('launch-status').innerHTML = (
            '<div class="status-err">先にデータをインポートしてください</div>'
        )
        return
    
    # AppStateから読み込み（フォールバックでグローバル変数）
    source_df = AppState.df if AppState.df is not None else g_df
    
    document.getElementById('launch-progress').style.display = 'block'
    status = document.getElementById('launch-status')
    
    try:
        df = source_df.copy()
        updateProgress(5)
        
        # Read column mapping from UI
        col_map = {
            'title': document.getElementById('col-title').value,
            'abstract': document.getElementById('col-abstract').value,
            'date': document.getElementById('col-date').value,
            'applicant': document.getElementById('col-applicant').value,
            'ipc': document.getElementById('col-ipc').value,
            'inventor': document.getElementById('col-inventor').value,
            'status': document.getElementById('col-status').value
        }
        # Update both AppState and global for backward compatibility
        AppState.col_map = col_map
        g_col_map = col_map
        cm = col_map
        
        status.innerHTML = '<div>📅 日付を処理...</div>'
        updateProgress(15)
        
        if cm['date'] and cm['date'] != '(未選択)':
            df['parsed_date'] = parse_date(df[cm['date']])
            df['year'] = df['parsed_date'].dt.year.fillna(0).astype(int)
        else:
            df['year'] = 0
        
        status.innerHTML = '<div>👤 出願人を処理...</div>'
        updateProgress(25)
        
        if cm['applicant'] and cm['applicant'] != '(未選択)':
            df['applicant_list'] = df[cm['applicant']].apply(split_list)
        else:
            df['applicant_list'] = [[] for _ in range(len(df))]
        
        status.innerHTML = '<div>🏷IPCを処理...</div>'
        updateProgress(35)
        
        if cm['ipc'] and cm['ipc'] != '(未選択)':
            df['ipc_list'] = df[cm['ipc']].apply(extract_ipc)
        else:
            df['ipc_list'] = [[] for _ in range(len(df))]
        
        status.innerHTML = '<div>👨‍🔬 発明者処理...</div>'
        updateProgress(45)
        
        if cm['inventor'] and cm['inventor'] != '(未選択)':
            df['inventor_list'] = df[cm['inventor']].apply(split_list)
        else:
            df['inventor_list'] = [[] for _ in range(len(df))]
        
        status.innerHTML = '<div>🎨 ステータス色を設定中...</div>'
        updateProgress(50)
        
        if cm['status'] and cm['status'] != '(未選択)':
            status_series = df[cm['status']].apply(normalize_status)
            df['_status'] = status_series
            col_map['status_norm'] = '_status'
            unique_statuses = sorted(status_series.unique())
            status_colors = {
                s: PASTEL_PALETTE[i % len(PASTEL_PALETTE)]
                for i, s in enumerate(unique_statuses)
            }
            status_order = unique_statuses
        else:
            status_colors = {}
            col_map['status_norm'] = None
            status_order = []
        
        # Sync to AppState and globals
        AppState.status_colors = status_colors
        AppState.status_order = status_order
        AppState.col_map = col_map
        g_col_map = col_map
        g_status_colors = status_colors
        g_status_order = status_order
        
        status.innerHTML = '<div>📝 テキストをベクトル化中...</div>'
        updateProgress(55)
        
        # Combine title and abstract for text analysis
        title_col = cm['title'] if cm['title'] != '(未選択)' else ''
        abstract_col = cm['abstract'] if cm['abstract'] != '(未選択)' else ''
        df['text'] = df.apply(
            lambda r: str(r.get(title_col, '')) + ' ' + str(r.get(abstract_col, '')),
            axis=1
        )
        df['tokenized'] = df['text'].apply(tokenize_text)

        # COREモジュールのターゲチカラムセセレクターを更新
        core_target = document.getElementById('core-ai-target')
        if core_target:
            options = ["text"]
            labels = {
                "text": "タイトル+要約",
                "title": "タイトルのみ",
                "abstract": "要約のみ"
            }
            if cm['title'] and cm['title'] != '(未選択)':
                options.append("title")
            if cm['abstract'] and cm['abstract'] != '(未選択)':
                options.append("abstract")
            core_target.innerHTML = ''.join(
                f'<option value="{v}">{labels[v]}</option>' for v in options
            )
        
        status.innerHTML = '<div>🔢 TF-IDF行を計算中...</div>'
        updateProgress(70)
        
        # TF-IDF計算
        vectorizer = None
        tfidf_matrix = None
        feature_names = []
        
        if ensure_sklearn():
            vectorizer = TfidfVectorizer(max_features=2000, min_df=2, max_df=0.95)
            tfidf_matrix = vectorizer.fit_transform(df['tokenized'].fillna(''))
            feature_names = vectorizer.get_feature_names_out().tolist()
        
        # Sync to AppState and globals
        AppState.vectorizer = vectorizer
        AppState.tfidf_matrix = tfidf_matrix
        AppState.feature_names = feature_names
        g_vectorizer = vectorizer
        g_tfidf_matrix = tfidf_matrix
        g_feature_names = feature_names
        
        updateProgress(90)

        # Sync processed DataFrame
        AppState.df_processed = df
        g_df_processed = df
        
        # 年度コントロールを設定
        if df['year'].max() > 0:
            valid_years = df[df['year'] > 0]['year']
            document.getElementById('year-start').value = str(int(valid_years.min()))
            document.getElementById('year-end').value = str(int(valid_years.max()))
        
        # 出願人選択リストを設定
        top_applicants = (
            df.explode('applicant_list')['applicant_list']
            .value_counts()
            .head(30)
            .index.tolist()
        )
        top_applicant_counts = (
            df.explode('applicant_list')['applicant_list']
            .value_counts()
            .to_dict()
        )
        
        # 企業比較セセレクター (XSS sanitization)
        sel = document.getElementById('compare-companies')
        sel.innerHTML = ''.join(
            f'<option value="{escape_html(str(a))}">{escape_html(str(a))}</option>' 
            for a in top_applicants if a
        )
        
        # TF-IDF詳細セセレクター
        sel_tfidf = document.getElementById('tfidf-company')
        sel_tfidf.innerHTML = '<option value="(未選択)">(未選択)</option>' + ''.join(
            f'<option value="{escape_html(str(a))}">{escape_html(str(a))}</option>' 
            for a in top_applicants if a
        )

        # レーダーチャートセセレクター
        sel_radar1 = document.getElementById('radar-company1')
        sel_radar2 = document.getElementById('radar-company2')
        radar_opts = '<option value="">(選択してください)</option>' + ''.join(
            f'<option value="{escape_html(str(a))}">{escape_html(str(a))}</option>' 
            for a in top_applicants if a
        )
        sel_radar1.innerHTML = radar_opts
        sel_radar2.innerHTML = radar_opts

        # 折れ線チャート出願人セセレクター
        sel_line = document.getElementById('atlas-line-applicants')
        sel_line.innerHTML = ''.join(
            f'<option value="{escape_html(str(a))}">{escape_html(str(a))} ({top_applicant_counts.get(a, 0)})</option>'
            for a in top_applicants if a
        )
        
        updateProgress(100)
        
        # ダッシュボード統計を更新
        valid_years = df[df['year'] > 0]['year']
        year_range = f"{int(valid_years.min())}-{int(valid_years.max())}" if len(valid_years) > 0 else "-"
        unique_applicants = df.explode('applicant_list')['applicant_list'].nunique()
        window.updateDashboardStats(len(df), year_range, unique_applicants)
        
        # ダッシュボードプレビューデータを準備
        import json
        
        # 年次推移
        year_counts = df[df['year'] > 0]['year'].value_counts().to_dict()
        year_counts_js = {str(int(k)): int(v) for k, v in year_counts.items()}
        
        # Top出願人
        top_applicant_preview = dict(
            df.explode('applicant_list')['applicant_list']
            .value_counts()
            .head(5)
            .items()
        )
        top_applicant_js = {str(k): int(v) for k, v in top_applicant_preview.items()}
        
        # Top IPC
        top_ipc_preview = dict(
            df.explode('ipc_list')['ipc_list']
            .value_counts()
            .head(5)
            .items()
        )
        top_ipc_js = {str(k): int(v) for k, v in top_ipc_preview.items() if k}
        
        # Top キーワード（TF-IDFスコア）
        top_keywords_js = {}
        if g_tfidf_matrix is not None and len(g_feature_names) > 0:
            mean_scores = g_tfidf_matrix.mean(axis=0).A1
            top_indices = mean_scores.argsort()[-15:][::-1]
            top_keywords_js = {
                g_feature_names[i]: float(mean_scores[i]) 
                for i in top_indices
            }
        
        # すべてのプレビューデータをまとめて送信
        preview_data = {
            'yearCounts': year_counts_js,
            'topApplicants': top_applicant_js,
            'topIPC': top_ipc_js,
            'topKeywords': top_keywords_js
        }
        window.updateDashboardPreview(json.dumps(preview_data))
        
        # トースト通知
        window.showToast(f'分析エンジン起動完了 {len(df):,}件のデータを処理しました', 'success', 4000)
        
        # Display completion status
        status_info = (
            f"ステータス: {len(status_colors)}種類"
            if status_colors else "ステータス: 未設定"
        )
        tfidf_info = f"{tfidf_matrix.nnz:,}" if tfidf_matrix is not None else "-"
        vocab_info = f"{len(feature_names):,}" if feature_names else "-"
        status.innerHTML = f'''
            <div class="status-ok" style="font-size: 1.1rem;">🎉 分析エンジン起動完了</div>
            <div class="metrics">
                <div class="metric"><div class="metric-value">{len(df):,}</div><div class="metric-label">総件数</div></div>
                <div class="metric"><div class="metric-value">{vocab_info}</div><div class="metric-label">語彙数</div></div>
                <div class="metric"><div class="metric-value">{tfidf_info}</div><div class="metric-label">非ゼロ要素</div></div>
            </div>
            <div style="font-size: 0.85rem; margin-top: 0.5rem; color: #778da9;">{status_info}</div>
            <div style="font-size: 0.8rem; margin-top: 0.3rem; color: #9fb3c8;">重い機能はバックグラウンドで起動します</div>
        '''
        
    except Exception as e:
        import traceback
        status.innerHTML = (
            f'<div class="status-err">❌ {escape_html(str(e))}</div>'
            f'<pre style="font-size:0.7rem;">{escape_html(traceback.format_exc())}</pre>'
        )

# ============================================================
# ATLASモジュール - 統計チャート
# ============================================================

@ensure_data('atlas-chart')
def draw_atlas(event):
    """
    ユーザーの選択に基づいて統計チャートを描画する。
    
    8種類のチャートタイプをサポート:
    - trend: 年次出願件数の棒グラフ
    - trend_line: スタッキングオプション付き折れ線グラフ
    - applicant: 上位出願人の横棒グラフ
    - ipc: 上位IPCコード横棒グラフ
    - bubble: バブルチャート(出願人 x 年マトリクス)
    - ipc_applicant: ヒートマップ (IPC x 出願人)
    - treemap: 階層ツリーマップ(IPCまたは出願人)
    - lifecycle: 出願ライフサイクル分析
    
    チャートタイプオプションでステータス別の色分けをサポート。
    
    Args:
        event: ボタンクリックイベント
    """
    global g_df_processed, g_status_colors, g_col_map, g_status_order
    
    # ローディング表示開始
    UIHelper.show_chart_loading('atlas-chart', True, 'チャート生成中...')
    
    try:
        df = g_df_processed
        start = int(document.getElementById('year-start').value)
        end = int(document.getElementById('year-end').value)
        top_n = int(document.getElementById('top-n').value)
        chart_type = window.appState.chartType
        use_status = document.getElementById('use-status-breakdown').checked
        
        # Status breakdown only supported for specific chart types
        if chart_type not in ['trend', 'trend_line', 'applicant', 'bubble']:
            use_status = False
        
        dff = df[(df['year'] >= start) & (df['year'] <= end)]
        status_col = g_col_map.get('status_norm') or g_col_map.get('status')
        has_status = bool(
            status_col and status_col != '(未選択)'
            and use_status and status_col in df.columns
        )
        status_colors = dict(g_status_colors) if g_status_colors else {}
        status_order = list(g_status_order) if g_status_order else []
        
        # チャート過負荷防止のためステータスカテゴリ数を制限
        MAX_STATUS_CATEGORIES = 15
        if has_status:
            dff = dff.copy()
            dff[status_col] = dff[status_col].fillna('未設定').astype(str).replace({'': '未設定'})
            statuses_in_view = sorted(dff[status_col].unique().tolist())
            
            # 件数上位Nカテゴリに制限
            if len(statuses_in_view) > MAX_STATUS_CATEGORIES:
                debugLog(
                    f'[draw_atlas] Warning: {len(statuses_in_view)} status categories found, '
                    f'limiting to top {MAX_STATUS_CATEGORIES}'
                )
                status_counts = dff[status_col].value_counts().head(MAX_STATUS_CATEGORIES)
                statuses_in_view = status_counts.index.tolist()
                
                # 「その他」カテゴリを追加
                other_count = dff[~dff[status_col].isin(statuses_in_view)].shape[0]
                if other_count > 0:
                    statuses_in_view.append('その他')
            
                status_colors = {
                    s: PASTEL_PALETTE[i % len(PASTEL_PALETTE)]
                    for i, s in enumerate(statuses_in_view)
                }
                status_order = statuses_in_view
            
            if len(status_colors) == 0:
                has_status = False

        if chart_type == 'trend':
            if has_status:
                # 「その他」カテゴリを処理
                dff_status = dff.copy()
                if 'その他' in status_order:
                    top_statuses = [s for s in status_order if s != 'その他']
                    dff_status.loc[~dff_status[status_col].isin(top_statuses), status_col] = 'その他'
                
                plot_data = dff_status.groupby(['year', status_col]).size().reset_index(name='count')
                years_full = list(range(start, end + 1))
                traces = []
                for status in status_order:
                    sub = plot_data[plot_data[status_col] == status].set_index('year')['count']
                    sub = sub.reindex(years_full, fill_value=0)
                    traces.append(ChartHelper.create_bar_trace(
                        x=[int(x) for x in years_full],
                        y=[int(y) for y in sub.values],
                        name=str(status),
                        color=status_colors.get(str(status), "#4fc3f7")
                    ))
                layout = ChartHelper.create_stacked_bar_layout(
                    title=f"出願件数推移 ({start}-{end}) - ステータス別",
                    x_title="出願年",
                    y_title="件数"
                )
            else:
                cnt = dff['year'].value_counts().sort_index()
                cnt = cnt[cnt.index > 0]
                traces = [ChartHelper.create_bar_trace(
                    x=[int(x) for x in cnt.index],
                    y=[int(y) for y in cnt.values],
                    color=COLOR_SEQUENCE[0]
                )]
                layout = ChartHelper.create_layout(
                    title=f"出願件数推移 ({start}-{end})",
                    xaxis={"title": "出願年"},
                    yaxis={"title": "件数"}
                )
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'trend_line':
            line_mode = document.getElementById('atlas-line-mode').value
            if line_mode != 'overall':
                use_status = False
            if line_mode == 'overall':
                if has_status:
                    # Handle "Other" category
                    dff_status = dff.copy()
                    if 'その他' in status_order:
                        top_statuses = [s for s in status_order if s != 'その他']
                        dff_status.loc[~dff_status[status_col].isin(top_statuses), status_col] = 'その他'
                    
                    plot_data = dff_status.groupby(['year', status_col]).size().reset_index(name='count')
                    years_full = list(range(start, end + 1))
                    traces = []
                    for status in status_order:
                        sub = plot_data[plot_data[status_col] == status].set_index('year')['count']
                        sub = sub.reindex(years_full, fill_value=0)
                        trace = ChartHelper.create_line_trace(
                            x=[int(x) for x in years_full],
                            y=[int(y) for y in sub.values],
                            name=str(status),
                            color=status_colors.get(str(status), "#4fc3f7")
                        )
                        trace["stackgroup"] = "one"  # 積み上げ面用
                        traces.append(trace)
                    layout = ChartHelper.create_layout(
                        title=f"件数推移積み上げ面{start}-{end})",
                        xaxis={"title": "出願年"},
                        yaxis={"title": "件数", "rangemode": "tozero"},
                        legend={"orientation": "h", "y": -0.25, "x": 0, "xanchor": "left"},
                        margin={"b": 100}
                    )
                else:
                    cnt = dff['year'].value_counts().sort_index()
                    cnt = cnt[cnt.index > 0]
                    traces = [ChartHelper.create_line_trace(
                        x=[int(x) for x in cnt.index],
                        y=[int(y) for y in cnt.values],
                        color=COLOR_SEQUENCE[0]
                    )]
                    layout = ChartHelper.create_layout(
                        title=f"件数推移折れ線！{start}-{end})",
                        xaxis={"title": "出願年"},
                        yaxis={"title": "件数", "rangemode": "tozero"}
                    )
            else:
                sel = document.getElementById('atlas-line-applicants')
                selected = [opt.value for opt in sel.selectedOptions]
                if len(selected) == 0:
                    document.getElementById('atlas-chart').innerHTML = (
                        '<div class="status-warn">出願人を選択してください</div>'
                    )
                    return
                selected = selected[:5]
                exp = dff.explode('applicant_list')
                exp['applicant_list'] = exp['applicant_list'].astype(str)
                exp = exp[exp['applicant_list'].isin(selected)]
                if exp.empty:
                    document.getElementById('atlas-chart').innerHTML = (
                        '<div class="status-warn">選択した出願人のデータがありません</div>'
                    )
                    return
                
                traces = []
                for i, app in enumerate(selected):
                    sub = exp[exp['applicant_list'] == app]
                    yearly = sub['year'].value_counts().sort_index()
                    yearly = yearly.reindex(range(start, end + 1), fill_value=0)
                    traces.append(ChartHelper.create_line_trace(
                        x=[int(x) for x in yearly.index],
                        y=[int(y) for y in yearly.values],
                        name=app,
                        color=COLOR_SEQUENCE[i % len(COLOR_SEQUENCE)]
                    ))
                layout = ChartHelper.create_layout(
                    title="主要出願人の件数推移比較",
                    xaxis={"title": "出願年"},
                    yaxis={"title": "件数", "rangemode": "tozero"}
                )
                ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'applicant':
            exp = dff.explode('applicant_list')
            num_to_display = int(document.getElementById('atlas-applicant-count').value)
            top_applicants = exp['applicant_list'].value_counts().head(num_to_display).index.tolist()
            
            # Create truncated display names
            display_names = [truncate_applicant_name(a, 30) for a in top_applicants]
            
            # Calculate left margin based on longest name
            max_name_len = max((len(n) for n in display_names), default=10)
            left_margin = min(350, max(150, max_name_len * 9))
            debugLog(
                f'[draw_atlas] applicant: num_to_display={num_to_display}, '
                f'top_applicants count={len(top_applicants)}, left_margin={left_margin}'
            )
            
            if has_status:
                exp_top = exp[exp['applicant_list'].isin(top_applicants)].copy()
                
                # Handle "Other" category
                if 'その他' in status_order:
                    top_statuses = [s for s in status_order if s != 'その他']
                    exp_top.loc[~exp_top[status_col].isin(top_statuses), status_col] = 'その他'
                
                plot_data = exp_top.groupby(['applicant_list', status_col]).size().reset_index(name='count')
                debugLog(
                    f'[draw_atlas] has_status=True, status_order count={len(status_order)}, '
                    f'plot_data rows={len(plot_data)}'
                )
                
                traces = []
                for status in status_order:
                    sub = plot_data[plot_data[status_col] == status]
                    sub_sorted = pd.DataFrame({'applicant_list': top_applicants}).merge(
                        sub, on='applicant_list', how='left'
                    ).fillna(0)
                    trace = ChartHelper.create_bar_trace(
                        x=[int(x) for x in sub_sorted['count']],
                        y=display_names,
                        name=str(status),
                        color=status_colors.get(str(status), "#4fc3f7"),
                        orientation="h"
                    )
                    trace["customdata"] = top_applicants
                    trace["hovertemplate"] = "%{customdata}<br>%{x}件<extra>%{fullData.name}</extra>"
                    traces.append(trace)
                layout = ChartHelper.create_horizontal_bar_layout(
                    title=f"出願人ランキング TOP{num_to_display} - ステータス別",
                    x_title="",
                    y_title="",
                    left_margin=left_margin
                )
                layout["barmode"] = "stack"
                layout["yaxis"]["categoryorder"] = "array"
                layout["yaxis"]["categoryarray"] = display_names[::-1]
                layout["height"] = max(500, num_to_display * 30 + 100)
            else:
                cnt = exp['applicant_list'].value_counts().head(num_to_display).sort_values(ascending=True)
                y_display = [truncate_applicant_name(a, 30) for a in cnt.index.tolist()]
                trace = ChartHelper.create_bar_trace(
                    x=[int(x) for x in cnt.values],
                    y=y_display,
                    color=COLOR_SEQUENCE[1],
                    orientation="h"
                )
                trace["customdata"] = cnt.index.tolist()
                trace["hovertemplate"] = "%{customdata}<br>%{x}件<extra></extra>"
                traces = [trace]
                layout = ChartHelper.create_horizontal_bar_layout(
                    title=f"出願人ランキング TOP{num_to_display}",
                    x_title="",
                    y_title="",
                    left_margin=left_margin
                )
                layout["yaxis"]["categoryorder"] = "array"
                layout["yaxis"]["categoryarray"] = y_display
                layout["height"] = max(450, num_to_display * 28)
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'ipc':
            exp = dff.explode('ipc_list')
            exp = exp[exp['ipc_list'].notna() & (exp['ipc_list'] != '')]
            ipc_level = int(document.getElementById('atlas-ipc-level').value)
            num_to_display = int(document.getElementById('atlas-ipc-count').value)
            exp = exp.copy()
            exp['ipc_parsed'] = exp['ipc_list'].apply(lambda x: parse_ipc_atlas(x, ipc_level))
            top_ipcs = exp['ipc_parsed'].value_counts().head(num_to_display).index.tolist()
            
            if has_status:
                exp_top = exp[exp['ipc_parsed'].isin(top_ipcs)].copy()
                
                # Handle "Other" category
                if 'その他' in status_order:
                    top_statuses = [s for s in status_order if s != 'その他']
                    exp_top.loc[~exp_top[status_col].isin(top_statuses), status_col] = 'その他'
                
                plot_data = exp_top.groupby(['ipc_parsed', status_col]).size().reset_index(name='count')
                
                traces = []
                for status in status_order:
                    sub = plot_data[plot_data[status_col] == status]
                    sub_sorted = pd.DataFrame({'ipc_parsed': top_ipcs}).merge(
                        sub, on='ipc_parsed', how='left'
                    ).fillna(0)
                    traces.append(ChartHelper.create_bar_trace(
                        x=[int(x) for x in sub_sorted['count']],
                        y=sub_sorted['ipc_parsed'].tolist(),
                        name=str(status),
                        color=status_colors.get(str(status), "#4fc3f7"),
                        orientation="h"
                    ))
                layout = ChartHelper.create_horizontal_bar_layout(
                    title=f"IPCランキング TOP{num_to_display} - ステータス別",
                    x_title="",
                    y_title="",
                    left_margin=100
                )
                layout["barmode"] = "stack"
                layout["yaxis"]["categoryorder"] = "array"
                layout["yaxis"]["categoryarray"] = top_ipcs[::-1]
                layout["height"] = max(450, num_to_display * 28)
            else:
                cnt = exp['ipc_parsed'].value_counts().head(num_to_display).sort_values(ascending=True)
                traces = [ChartHelper.create_bar_trace(
                    x=[int(x) for x in cnt.values],
                    y=cnt.index.tolist(),
                    color=COLOR_SEQUENCE[2],
                    orientation="h"
                )]
                layout = ChartHelper.create_horizontal_bar_layout(
                    title=f"IPCランキング TOP{num_to_display}",
                    x_title="",
                    y_title="",
                    left_margin=100
                )
                layout["yaxis"]["categoryorder"] = "array"
                layout["yaxis"]["categoryarray"] = cnt.index.tolist()
                layout["height"] = max(450, num_to_display * 28)
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'bubble':
            exp = dff.explode('applicant_list')
            num_to_display = int(document.getElementById('atlas-bubble-count').value)
            top_apps = exp['applicant_list'].value_counts().head(num_to_display).index.tolist()
            exp_top = exp[exp['applicant_list'].isin(top_apps)]
            
            if has_status:
                # Bubble chart with status breakdown (grid pie charts)
                plot_data = exp_top.groupby(
                    ['year', 'applicant_list', status_col]
                ).size().reset_index(name='count')
                years = list(range(start, end + 1))
                plot_data = plot_data[plot_data['year'].isin(years)]
                
                traces = []
                statuses_in_view = [
                    s for s in status_order if s in plot_data[status_col].unique()
                ]
                
                # Legend traces
                for status in statuses_in_view:
                    traces.append({
                        "x": [None],
                        "y": [None],
                        "type": "scatter",
                        "mode": "markers",
                        "name": str(status),
                        "marker": {"size": 10, "color": status_colors.get(str(status), "#4fc3f7")},
                        "showlegend": True
                    })
                
                n_rows = len(top_apps)
                n_cols = len(years)
                if n_rows == 0 or n_cols == 0:
                    document.getElementById('atlas-chart').innerHTML = (
                        '<div class="status-warn">データがありません</div>'
                    )
                    return
                
                # Layout calculations for pie chart grid
                x_margin_l = 0.20
                x_margin_r = 0.02
                y_margin_b = 0.10
                y_margin_t = 0.05
                plot_width = 1.0 - (x_margin_l + x_margin_r)
                plot_height = 1.0 - (y_margin_b + y_margin_t)
                cell_w = plot_width / n_cols
                cell_h = plot_height / n_rows
                
                total_counts = exp_top.groupby(
                    ['applicant_list', 'year']
                ).size().reset_index(name='total')
                max_total = total_counts['total'].max() if not total_counts.empty else 1
                
                for i, app in enumerate(top_apps):
                    for j, year in enumerate(years):
                        cell_df = plot_data[(plot_data['applicant_list'] == app) & (plot_data['year'] == year)]
                        if not cell_df.empty:
                            total = cell_df['count'].sum()
                            # 最小サイズを0.3に設定して視認性を確保
                            scale_factor = max(0.3, (total / max_total) ** 0.5)
                            y_center = (1.0 - y_margin_t) - (i * cell_h) - (cell_h / 2)
                            x_center = x_margin_l + (j * cell_w) + (cell_w / 2)
                            d_w = cell_w * scale_factor
                            x0 = x_center - (d_w / 2)
                            x1 = x_center + (d_w / 2)
                            y0 = y_center - (scale_factor * cell_h / 2)
                            y1 = y_center + (scale_factor * cell_h / 2)
                            labels = cell_df[status_col].astype(str).tolist()
                            values = cell_df['count'].tolist()
                            colors = [status_colors.get(l, '#4fc3f7') for l in labels]
                            traces.append({
                                "type": "pie",
                                "labels": labels,
                                "values": values,
                                "marker": {
                                    "colors": colors, 
                                    "line": {"color": "rgba(30,41,59,0.8)", "width": 1}
                                },
                                "domain": {"x": [x0, x1], "y": [y0, y1]},
                                "showlegend": False,
                                "textinfo": "none",
                                "textposition": "none",
                                "hoverinfo": "label+value",
                                "sort": False,
                                "hole": 0,
                                "pull": 0,
                                "opacity": 1
                            })
                
                layout = {
                    "title": "出願人×年 バブル ステータス別",
                    "height": max(700, n_rows * 50),
                    "showlegend": True,
                    "legend": {"orientation": "h", "y": -0.15, "x": 0.5, "xanchor": "center"},
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)",
                    "xaxis": {
                        "visible": True,
                        "domain": [x_margin_l, 1.0 - x_margin_r],
                        "range": [years[0] - 0.5, years[-1] + 0.5],
                        "tickmode": "array",
                        "tickvals": years,
                        "side": "bottom",
                        "fixedrange": True,
                        "showgrid": False,
                        "zeroline": False,
                        "showline": False
                    },
                    "yaxis": {
                        "visible": True,
                        "domain": [y_margin_b, 1.0 - y_margin_t],
                        "range": [-0.5, n_rows - 0.5],
                        "tickmode": "array",
                        "tickvals": list(range(n_rows)),
                        "ticktext": top_apps[::-1],
                        "fixedrange": True,
                        "showgrid": True,
                        "gridcolor": "rgba(255,255,255,0.15)",
                        "zeroline": False,
                        "showline": False
                    },
                    "margin": {"l": 0, "r": 0, "t": 40, "b": 80}
                }
            else:
                pivot = exp_top.groupby(['year', 'applicant_list']).size().reset_index(name='count')
                
                traces = []
                for i, app in enumerate(top_apps):
                    sub = pivot[pivot['applicant_list'] == app]
                    traces.append({
                        "x": [int(x) for x in sub['year']],
                        "y": [app] * len(sub),
                        "mode": "markers",
                        "name": app[:20],
                        "marker": {"size": [max(10, int(c)*4) for c in sub['count']], "color": COLOR_SEQUENCE[i % len(COLOR_SEQUENCE)], "opacity": 0.7, "line": {"width": 1, "color": "#fff"}},
                        "text": [f"{app}<br>{y}年: {c}件" for y, c in zip(sub['year'], sub['count'])],
                        "hoverinfo": "text"
                    })
                layout = ChartHelper.create_layout(
                    title="出願人×年 バブルチャート",
                    height=500,
                    showlegend=True,
                    legend={"orientation": "v", "x": 1.02, "y": 1, "xanchor": "left"},
                    xaxis={"title": "出願年"},
                    yaxis={
                        "categoryorder": "array", 
                        "categoryarray": top_apps[::-1],
                        "showticklabels": False  # 凡例があるのでy軸ラベルは非表示
                    },
                    margin={"r": 150}  # 右側の凡例用スペース
                )
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'treemap':
            mode = document.getElementById('atlas-treemap-mode').value
            if mode == 'ipc':
                tree_df = create_treemap_data(dff, mode='ipc')
                if tree_df.empty:
                    traces = []
                    layout = {"title": "IPCデータがありません", "height": 300}
                else:
                    labels = []
                    parents = []
                    values = []
                    sections_used = set()
                    classes_used = set()
                    subclass_counts = tree_df['Subclass'].value_counts().head(50)
                    for subclass, count in subclass_counts.items():
                        section = subclass[0]
                        ipc_class = subclass[:3]
                        if section not in sections_used:
                            labels.append(section)
                            parents.append('')
                            values.append(0)
                            sections_used.add(section)
                        if ipc_class not in classes_used:
                            labels.append(ipc_class)
                            parents.append(section)
                            values.append(0)
                            classes_used.add(ipc_class)
                        labels.append(subclass)
                        parents.append(ipc_class)
                        values.append(int(count))
                    traces = [{"type": "treemap", "labels": labels, "parents": parents, "values": values, "textinfo": "label+value", "marker": {"colors": values, "colorscale": "Viridis", "line": {"color": "#1b263b", "width": 2}}, "textfont": {"color": "white", "size": 14}}]
                    layout = ChartHelper.create_layout(title="IPC階層構造マップ", height=700, paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)")
            else:
                tree_df = create_treemap_data(dff, mode='applicant')
                if tree_df.empty:
                    traces = []
                    layout = ChartHelper.create_layout(title="出願人データがありません", height=300)
                else:
                    traces = [{"type": "treemap", "labels": tree_df['Applicant'].tolist(), "parents": tree_df['Root'].tolist(), "values": tree_df['count'].tolist(), "textinfo": "label+value", "marker": {"colors": tree_df['count'].tolist(), "colorscale": "Sunset", "line": {"color": "#1b263b", "width": 2}}, "textfont": {"color": "white", "size": 12}}]
                    layout = ChartHelper.create_layout(title="出願人シェアマップ", height=700, paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)")
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'lifecycle':
            exp = dff.copy()
            exp_apps = dff.explode('applicant_list')
            exp_apps['applicant_list'] = exp_apps['applicant_list'].astype(str)
            exp_apps = exp_apps[exp_apps['applicant_list'] != '']
            apps_count = exp.groupby('year').size()
            applicants_count = exp_apps.groupby('year')['applicant_list'].nunique().reindex(apps_count.index, fill_value=0)
            lifecycle_df = pd.DataFrame({
                'year': apps_count.index,
                'applications': apps_count.values,
                'applicants': applicants_count.values
            })
            if lifecycle_df.empty or len(lifecycle_df) < 2:
                UIHelper.warn_html('atlas-chart', 'データ不足のため描画できません。期間を広げてください')
                return
            lifecycle_df['year_label'] = lifecycle_df['year'].apply(lambda y: f"'{str(int(y))[-2:]}")
            traces = [
                {
                    "x": [int(x) for x in lifecycle_df['applications']],
                    "y": [int(y) for y in lifecycle_df['applicants']],
                    "type": "scatter",
                    "mode": "lines",
                    "line": {"shape": "spline", "smoothing": 1.3, "width": 3, "color": "#aaaaaa"},
                    "opacity": 0.5,
                    "showlegend": False,
                    "hoverinfo": "skip"
                },
                {
                    "x": [int(x) for x in lifecycle_df['applications']],
                    "y": [int(y) for y in lifecycle_df['applicants']],
                    "type": "scatter",
                    "mode": "markers+text",
                    "text": lifecycle_df['year_label'].tolist(),
                    "textposition": "top center",
                    "marker": {
                        "size": 12,
                        "color": lifecycle_df['year'].tolist(),
                        "colorscale": "Viridis",
                        "showscale": True,
                        "colorbar": {"title": "出願年"}
                    },
                    "showlegend": False,
                    "hovertemplate": "<b>%{text}</b><br>件数: %{x}<br>人数: %{y}<extra></extra>"
                }
            ]
            layout = ChartHelper.create_layout(
                title="技術ライフサイクル (出願人数 vs 出願件数)",
                xaxis={"title": "出願件数 (技術活動量)"},
                yaxis={"title": "出願人数 (参プレイヤー数)"},
                height=700
            )
            ChartHelper.draw("atlas-chart", traces, layout)
        
        elif chart_type == 'ipc_applicant':
            # IPC×出願人 バブルチャート
            exp = dff.explode('applicant_list').explode('ipc_list')
            exp = exp[exp['applicant_list'].notna() & exp['ipc_list'].notna()]
            exp = exp[(exp['applicant_list'] != '') & (exp['ipc_list'] != '')]
            ipc_level = int(document.getElementById('atlas-ipcapp-level').value)
            num_ipcs = int(document.getElementById('atlas-ipcapp-ipc-count').value)
            num_apps = int(document.getElementById('atlas-ipcapp-app-count').value)
            exp = exp.copy()
            exp['ipc_parsed'] = exp['ipc_list'].apply(lambda x: parse_ipc_atlas(x, ipc_level))
            
            # TOP出願人とTOP IPCを取得
            top_apps = exp['applicant_list'].value_counts().head(num_apps).index.tolist()
            top_ipcs = exp['ipc_parsed'].value_counts().head(num_ipcs).index.tolist()
            
            exp_filtered = exp[exp['applicant_list'].isin(top_apps) & exp['ipc_parsed'].isin(top_ipcs)]
            
            if exp_filtered.empty:
                UIHelper.warn_html('atlas-chart', 'IPC×出願人データがありません')
                return
            
            if has_status:
                # ステータス別付き - 色をステータスで分ける
                plot_data = exp_filtered.groupby(['applicant_list', 'ipc_parsed', status_col]).size().reset_index(name='count')
                statuses_in_view = [s for s in status_order if s in plot_data[status_col].unique()]
                
                traces = []
                for status in statuses_in_view:
                    sub = plot_data[plot_data[status_col] == status]
                    if not sub.empty:
                        traces.append({
                            "x": sub['applicant_list'].tolist(),
                            "y": sub['ipc_parsed'].tolist(),
                            "mode": "markers",
                            "name": str(status),
                            "marker": {
                                "size": [max(10, int(c) * 2.5) for c in sub['count']],
                                "color": status_colors.get(str(status), "#4fc3f7"),
                                "opacity": 0.75,
                                "line": {"width": 1, "color": "#fff"}
                            },
                            "text": [f"{app}<br>{ipc}: {c}件<br>ステータス: {status}" for app, ipc, c in zip(sub['applicant_list'], sub['ipc_parsed'], sub['count'])],
                            "hoverinfo": "text"
                        })
                
                layout = {
                    "title": f"IPC×出願人 ポートフォリオステータス別",
                    "height": max(600, num_apps * 35),
                    "showlegend": True,
                    "legend": {"orientation": "h", "y": -0.25, "x": 0, "xanchor": "left"},
                    "xaxis": {"title": "出願人", "tickangle": -45, "categoryorder": "array", "categoryarray": top_apps},
                    "yaxis": {"title": "IPC", "categoryorder": "array", "categoryarray": top_ipcs[::-1]},
                    "margin": {"l": 100, "b": 200}
                }
            else:
                plot_data = exp_filtered.groupby(['applicant_list', 'ipc_parsed']).size().reset_index(name='count')
                
                traces = []
                for i, ipc in enumerate(top_ipcs):
                    sub = plot_data[plot_data['ipc_parsed'] == ipc]
                    if not sub.empty:
                        traces.append({
                            "x": sub['applicant_list'].tolist(),
                            "y": sub['ipc_parsed'].tolist(),
                            "mode": "markers",
                            "name": ipc,
                            "marker": {
                                "size": [max(12, int(c) * 3) for c in sub['count']],
                                "color": COLOR_SEQUENCE[i % len(COLOR_SEQUENCE)],
                                "opacity": 0.7,
                                "line": {"width": 1, "color": "#fff"}
                            },
                            "text": [f"{app}<br>{ipc}: {c}件" for app, c in zip(sub['applicant_list'], sub['count'])],
                            "hoverinfo": "text"
                        })
                
                layout = ChartHelper.create_layout(
                    title=f"IPC×出願人 ポートフォリオ TOP{num_apps}",
                    height=max(600, num_apps * 35),
                    showlegend=True,
                    xaxis={"title": "出願人", "tickangle": -45, "categoryorder": "array", "categoryarray": top_apps},
                    yaxis={"title": "IPC", "categoryorder": "array", "categoryarray": top_ipcs[::-1]},
                    margin={"l": 100, "b": 150}
                )
            ChartHelper.draw("atlas-chart", traces, layout)
    
    except Exception as e:
        UIHelper.show_chart_loading('atlas-chart', False)
        UIHelper.show_error('atlas-chart', 'チャート描画エラー', str(e))
        console.error(f'[draw_atlas] Error: {e}')

# =====================================================
# COR - 論理検索
# =====================================================
def _core_text_preprocessor(text):
    if not isinstance(text, str): return ""
    text = unicodedata.normalize('NFKC', text).lower()
    text = re.sub(r'[][^]{1,80}[]', ' ', text)
    text = re.sub(r'(?:図|Fig|FIG|fig)[. 　]*\d+', ' ', text)
    text = re.sub(r'[!"“ $%\'()！,\-:=>?@\[\]\\^_`{|}~〜〜！]', ' ', text)
    return text

class LogicNode:
    def evaluate(self, text):
        raise NotImplementedError

class AndNode(LogicNode):
    def __init__(self, children): self.children = children
    def evaluate(self, text): return all(c.evaluate(text) for c in self.children)

class OrNode(LogicNode):
    def __init__(self, children): self.children = children
    def evaluate(self, text): return any(c.evaluate(text) for c in self.children)

class RegexNode(LogicNode):
    def __init__(self, pattern):
        self.source = pattern
        try:
            self.pattern = re.compile(pattern, re.IGNORECAS | re.DOTALL)
        except Exception:
            self.pattern = None
    def evaluate(self, text):
        return bool(self.pattern.search(text)) if self.pattern else False

class CoreLogicParser:
    def __init__(self):
        self.tokens = []
        self.pos = 0

    def tokenize(self, rule_str):
        raw_tokens = re.findall(r'\(|\)|' r'\bnear\d+\b|' r'\badj\d+\b|' r'[\+\*]' r'|' r'[^\(\)\+\*\s]+', rule_str, re.IGNORECAS)
        self.tokens = [t.strip() for t in raw_tokens if t.strip()]
        self.pos = 0

    def parse(self, rule_str):
        self.tokenize(rule_str)
        if not self.tokens: return None
        node = self.expression()
        if self.pos < len(self.tokens):
            raise ValueError(f"Unexpected token at end: {self.tokens[self.pos]}")
        return node

    def expression(self):
        nodes = [self.term()]
        while self.pos < len(self.tokens) and self.tokens[self.pos] == '+':
            self.pos += 1
            nodes.append(self.term())
        return OrNode(nodes) if len(nodes) > 1 else nodes[0]

    def term(self):
        nodes = [self.factor()]
        while self.pos < len(self.tokens) and self.tokens[self.pos] == '*':
            self.pos += 1
            nodes.append(self.factor())
        return AndNode(nodes) if len(nodes) > 1 else nodes[0]

    def factor(self):
        left = self.atom()
        while self.pos < len(self.tokens) and re.match(r'^(near|adj)\d+$', self.tokens[self.pos], re.IGNORECAS):
            op = self.tokens[self.pos].lower()
            self.pos += 1
            right = self.atom()
            l_rex = self.to_regex_string(left)
            r_rex = self.to_regex_string(right)
            n = int(re.findall(r'\d+', op)[0])
            if op.startswith('near'):
                pattern = r'(?:{}.{{0,{}}}?{}|{}.{{0,{}}}?{})'.format(l_rex, n, r_rex, r_rex, n, l_rex)
            else:
                pattern = r'{}.{{0,{}}}?{}'.format(l_rex, n, r_rex)
            left = RegexNode(pattern)
        return left

    def atom(self):
        if self.pos < len(self.tokens) and self.tokens[self.pos] == '(':
            self.pos += 1
            node = self.expression()
            if self.pos < len(self.tokens) and self.tokens[self.pos] == ')':
                self.pos += 1
                return node
            raise ValueError("Missing closing parenthesis")
        elif self.pos < len(self.tokens):
            t = self.tokens[self.pos]
            self.pos += 1
            norm = unicodedata.normalize('NFKC', t).lower()
            return RegexNode(re.escape(norm))
        else:
            raise ValueError("Unexpected end of rule")

    def to_regex_string(self, node):
        if isinstance(node, RegexNode):
            return node.source
        if isinstance(node, OrNode):
            parts = [self.to_regex_string(c) for c in node.children]
            return r'(?:' + '|'.join(parts) + r')'
        if isinstance(node, AndNode):
            raise ValueError("Cannot use AND (*) inside a NEAR/ADJ condition. Use OR (+) only.")
        return ""

def parse_core_rule(rule_str):
    parser = CoreLogicParser()
    return parser.parse(rule_str)

def _core_combined_text(df, cm):
    cols = []
    if cm.get('title') and cm.get('title') != '(未選択)' and cm['title'] in df.columns:
        cols.append(df[cm['title']].fillna(''))
    if cm.get('abstract') and cm.get('abstract') != '(未選択)' and cm['abstract'] in df.columns:
        cols.append(df[cm['abstract']].fillna(''))
    if not cols:
        return df['text'].fillna('') if 'text' in df.columns else pd.Series([''] * len(df))
    text = cols[0]
    for s in cols[1:]:
        text = text + " " + s
    return text

def update_core_axis_selects():
    axes = list(g_core_rules.keys())
    meta_axes = []
    if g_df_processed is not None and 'year' in g_df_processed.columns:
        meta_axes.append('出願年')
    if g_col_map.get('applicant') and g_col_map.get('applicant') != '(未選択)':
        meta_axes.append('出願人')
    all_axes = axes + meta_axes
    x_sel = document.getElementById('core-x-axis')
    y_sel = document.getElementById('core-y-axis')
    re_sel = document.getElementById('core-reanalyze-axis')
    if x_sel:
        x_sel.innerHTML = ''.join([f'<option value="{a}">{a}</option>' for a in all_axes])
    if y_sel:
        y_sel.innerHTML = ''.join([f'<option value="{a}">{a}</option>' for a in all_axes])
    if re_sel:
        re_sel.innerHTML = ''.join([f'<option value="{a}">{a}</option>' for a in axes])

    axis_sel = document.getElementById('core-axis-select')
    if axis_sel:
        if axes:
            axis_sel.innerHTML = ''.join([f'<option value="{escape_html(str(a))}">{escape_html(str(a))}</option>' for a in axes])
        else:
            axis_sel.innerHTML = '<option value="">(軸がありません)</option>'

def render_core_rules():
    if not g_core_rules:
        UIHelper.warn_html('core-rule-list', 'ルールがありません')
        return
    html_out = ''
    for ax, cats in g_core_rules.items():
        ax_safe = escape_html(str(ax))
        html_out += f'<h4 style="margin-top:0.6rem;">軸: {ax_safe} ({len(cats)}件)</h4>'
        html_out += '<table class="data-table"><tr><th>分類</th><th>ルール</th><th>操作</th></tr>'
        for name, cd in cats.items():
            name_safe = escape_html(str(name))
            rule = cd['rule'] if isinstance(cd, dict) else cd
            rule_safe = escape_html(str(rule))
            html_out += (
                f'<tr><td>{name_safe}</td><td>{rule_safe}</td><td>'
                f'<button class="btn" data-axis="{ax_safe}" data-name="{name_safe}" onclick="window.coreEditRule(event)">編集</button> '
                f'<button class="btn" data-axis="{ax_safe}" data-name="{name_safe}" onclick="window.coreDeleteRule(event)">削除</button>'
                f'</td></tr>'
            )
        html_out += '</table>'
    document.getElementById('core-rule-list').innerHTML = html_out

def core_add_rule(event):
    global g_core_rules
    mode = document.getElementById('core-axis-mode').value
    axis = document.getElementById('core-axis-new').value.strip() if mode == 'new' else document.getElementById('core-axis-select').value
    name = document.getElementById('core-cat-name').value.strip()
    rule = document.getElementById('core-cat-rule').value.strip()
    definition = document.getElementById('core-cat-def').value.strip()
    if not axis or not name or not rule:
        UIHelper.warn_html('core-rule-status', '軸/分類名/論理式を入力してください')
        return
    try:
        parse_core_rule(rule)
    except Exception as e:
        document.getElementById('core-rule-status').innerHTML = f'<div class="status-err">❌ 構文エラー: {escape_html(str(e))}</div>'
        return
    if axis not in g_core_rules:
        g_core_rules[axis] = {}
    g_core_rules[axis][name] = {'rule': rule, 'definition': definition}
    document.getElementById('core-rule-status').innerHTML = '<div class="status-ok">✏️ ルールを追加しました</div>'
    update_core_axis_selects()
    render_core_rules()
    document.getElementById('core-cat-name').value = ''
    document.getElementById('core-cat-rule').value = ''
    document.getElementById('core-cat-def').value = ''
    document.getElementById('btn-core-add').style.display = 'inline-block'
    document.getElementById('btn-core-update').style.display = 'none'
    document.getElementById('btn-core-cancel').style.display = 'none'

def core_update_rule(event):
    global g_core_rules
    axis = document.getElementById('core-axis-select').value
    name = document.getElementById('core-cat-name').value.strip()
    rule = document.getElementById('core-cat-rule').value.strip()
    definition = document.getElementById('core-cat-def').value.strip()
    if not axis or not name or not rule:
        UIHelper.warn_html('core-rule-status', '軸/分類名/論理式を入力してください')
        return
    try:
        parse_core_rule(rule)
    except Exception as e:
        document.getElementById('core-rule-status').innerHTML = f'<div class="status-err">❌ 構文エラー: {escape_html(str(e))}</div>'
        return
    if axis not in g_core_rules:
        g_core_rules[axis] = {}
    g_core_rules[axis][name] = {'rule': rule, 'definition': definition}
    document.getElementById('core-rule-status').innerHTML = '<div class="status-ok">✏️ ルールを更新しました</div>'
    render_core_rules()
    document.getElementById('core-cat-name').value = ''
    document.getElementById('core-cat-rule').value = ''
    document.getElementById('core-cat-def').value = ''
    document.getElementById('btn-core-add').style.display = 'inline-block'
    document.getElementById('btn-core-update').style.display = 'none'
    document.getElementById('btn-core-cancel').style.display = 'none'

def core_delete_rule(axis, name):
    global g_core_rules
    if axis in g_core_rules and name in g_core_rules[axis]:
        del g_core_rules[axis][name]
        if not g_core_rules[axis]:
            del g_core_rules[axis]
    update_core_axis_selects()
    render_core_rules()

def core_edit_rule(axis, name):
    cd = g_core_rules.get(axis, {}).get(name)
    if not cd:
        return
    document.getElementById('core-axis-mode').value = 'existing'
    document.getElementById('core-axis-select').value = axis
    document.getElementById('core-cat-name').value = name
    document.getElementById('core-cat-rule').value = cd['rule'] if isinstance(cd, dict) else cd
    document.getElementById('core-cat-def').value = cd.get('definition', '') if isinstance(cd, dict) else ''
    document.getElementById('core-axis-new').value = ''
    document.getElementById('core-axis-select').disabled = False
    document.getElementById('core-axis-new').disabled = True

def core_cancel_edit(event):
    document.getElementById('core-cat-name').value = ''
    document.getElementById('core-cat-rule').value = ''
    document.getElementById('core-cat-def').value = ''
    document.getElementById('btn-core-add').style.display = 'inline-block'
    document.getElementById('btn-core-update').style.display = 'none'
    document.getElementById('btn-core-cancel').style.display = 'none'
    syncCoreAxisMode()

# JS呼び出し用にグローバルオブジェクトを初期化
if not hasattr(window, 'pyodide_globals') or window.pyodide_globals is None:
    from pyodide.ffi import JsProxy
    window.pyodide_globals = window.Object.new()

@ensure_data('core-ai-output', '先に分析エンジンを起動してください')
def core_ai_generate(event):
    global g_df_processed, g_col_map
    if not ensure_sklearn():
        UIHelper.warn_html('core-ai-output', '追加モジュールを読み込み中です。しばらく待ってから再実行してください。')
        return
    df = g_df_processed
    target = document.getElementById('core-ai-target').value
    k = int(document.getElementById('core-ai-k').value)
    n = int(document.getElementById('core-ai-n').value)
    use_mece = document.getElementById('core-ai-mece').checked

    if target == 'title':
        col = g_col_map.get('title', df.columns[0])
    elif target == 'abstract':
        col = g_col_map.get('abstract', df.columns[0])
    else:
        col = 'text'
    if col == '(未選択)':
        col = 'text'

    try:
        texts_raw = df[col].astype(str).fillna('')
        tokenized = texts_raw.apply(tokenize_text)
        vec = TfidfVectorizer(min_df=1, max_df=0.9, token_pattern=r"(?u)\b\w+\b")
        tfidf = vec.fit_transform(tokenized)
        km = KMeans(n_clusters=k, random_state=42, n_init=10).fit(tfidf)

        sampled_docs = []
        for i in range(k):
            c_idx = np.where(km.labels_ == i)[0]
            if len(c_idx) == 0:
                continue
            dists = euclidean_distances(tfidf[c_idx], km.cluster_centers_[i].reshape(1, -1))
            top_idx = c_idx[dists.flatten().argsort()[:n]]
            sampled_docs.append("\n--- Cluster {} ---\n".format(i) + "\n".join(["・" + _core_text_preprocessor(texts_raw.iloc[idx]) for idx in top_idx]))

        instruction_text = (
            "この特許母集団全体を網羅的に分類するため、**「技術分類」「課題分類」「解決手段分類」**の3つの分類軸について、**分類定義**（分類名、定義、CORE論理式セット）を設計してください。\n"
            "\n# 重要: MECE (Mutually Exclusive, Collectively Exhaustive) の原則\n"
            "- 生成する分類軸名・カテゴリは、相互に排他的（ダブりがない）であり、かつ全体として網羅的（モレがない）であるように設計してください。\n"
            "- 各軸のカテゴリ数は、MECEを満たすのに最適だとあなたが判断する数（目安として5〜10個程度）にしてください。\n"
        )
        if not use_mece:
            instruction_text = (
                "この特許母集団全体を網羅的に分類するため、以下3つの分類軸について**分類定義**を設計してください。\n"
                "- **技術分類**: 6個\n"
                "- **課題分類**: 6個\n"
                "- **解決手段分類**: 6個\n"
            )

        sampled_docs_str = "".join(sampled_docs)
        prompt = f"""
あなたは優秀な特許ストラテジストです。以下の「代表文書サンプル」は、ある特許母集団{len(df)}件をK-Means法で{k}個のクラスタに分類し、各クラスタから代表的な文書の「{col}」を{n}件ずつ抽出したものです。
# 依頼内容
{instruction_text}

以下の形式で **JSONデータのみ** を出力してください。解説は不要です。JSONをコピーしてシステムにそのままインポートします。
# JSONフォーマット（厳密に守ること）
{{
  "技術分類": [
    {{
      "name": "カテゴリ名(例: CO2分離膜)",
      "definition": "カテゴリの定義...",
      "rule": "CORE論理式(例: (CO2 + 二酸化炭素) * (膜 + メンブレン))"
    }}
  ],
  "課題分類": [ ... ],
  "解決手段分類": [ ... ]
}}

# CORE論理式文法（厳密に守ること）
- `A + B` (OR): A または B
- `A * B` (AND): A かつ B (順序問わず)
- `()`: 括弧を使って優先順位を制御できます。入れ子も可能です。
- `A nearN B`: AとBがN語以内(順序不問)
- `A adjN B`: A→BがN語以内(順序あり)
- **重要**: `near` や `adj` の条件の中には `*` (AND) を含めないでください。`+` (OR) は可。

# 代表文書サンプル
{sampled_docs_str}
"""
        document.getElementById('core-ai-output').innerHTML = '<div class="status-ok">✅ プロンプトを生成しました</div><pre style="white-space: pre-wrap; font-size: 0.8rem;">' + prompt + '</pre>'
    except Exception as e:
        document.getElementById('core-ai-output').innerHTML = f'<div class="status-err">❌ {escape_html(str(e))}</div>'

def core_import_json(event):
    global g_core_rules
    raw = document.getElementById('core-json').value.strip()
    if not raw:
        UIHelper.warn_html('core-rule-status', 'JSONを入力してください')
        return
    try:
        data = json.loads(raw)
        if not isinstance(data, dict):
            raise ValueError('JSONの形式が正しくありません')
        for axis, items in data.items():
            if axis not in g_core_rules:
                g_core_rules[axis] = {}
            if isinstance(items, list):
                for item in items:
                    name = item.get('name') or item.get('カテゴリ名')
                    rule = item.get('rule') or item.get('ルール')
                    definition = item.get('definition') or item.get('定義', '')
                    if name and rule:
                        g_core_rules[axis][name] = {'rule': rule, 'definition': definition}
        document.getElementById('core-rule-status').innerHTML = '<div class="status-ok">✏️ ルールをインポートしました</div>'
        update_core_axis_selects()
        render_core_rules()
    except Exception as e:
        document.getElementById('core-rule-status').innerHTML = f'<div class="status-err">❌{escape_html(str(e))}</div>'

@ensure_data('core-run-status', '先に分析エンジンを起動してください')
def core_run_classification(event):
    global g_df_processed, g_col_map, g_core_rules, g_core_df_classified
    if not g_core_rules:
        UIHelper.warn_html('core-run-status', 'ルールがありません')
        return
    df = g_df_processed.copy()
    try:
        combined_text = _core_combined_text(df, g_col_map)
        compiled = {}
        for ax, cats in g_core_rules.items():
            compiled[ax] = []
            for name, cd in cats.items():
                rule = cd['rule'] if isinstance(cd, dict) else cd
                node = parse_core_rule(rule)
                if node:
                    compiled[ax].append((name, node))

        def apply_rules(text, ax_nodes):
            t = _core_text_preprocessor(str(text))
            hits = []
            for c_name, node in ax_nodes:
                if node.evaluate(t):
                    hits.append(c_name)
            return ";".join(hits) if hits else "その他"

        for ax in compiled.keys():
            df[ax] = combined_text.apply(lambda x: apply_rules(x, compiled[ax]))

        g_core_df_classified = df
        document.getElementById('core-run-status').innerHTML = '<div class="status-ok">✅ 分類が完了しました</div>'

        # Summary
        summary_html = ''
        for ax in compiled.keys():
            counts = df[ax].str.split(';').explode().value_counts().head(20)
            summary_html += f'<h4 style="margin-top:0.6rem;">{escape_html(str(ax))}</h4>'
            summary_html += '<table class="data-table"><tr><th>カテゴリ</th><th>件数</th></tr>'
            for name, cnt in counts.items():
                summary_html += f'<tr><td>{escape_html(str(name))}</td><td>{int(cnt)}</td></tr>'
            summary_html += '</table>'
        document.getElementById('core-summary').innerHTML = summary_html

        # CSV
        csv_text = df.to_csv(index=False)
        document.getElementById('core-csv').value = csv_text

        update_core_axis_selects()
    except Exception as e:
        document.getElementById('core-run-status').innerHTML = f'<div class="status-err">❌{escape_html(str(e))}</div>'

@ensure_core_classified('core-reanalyze-output', '分類結果がありません')
def core_reanalyze(event):
    global g_core_df_classified, g_core_rules, g_core_reanalyze_prompt
    if not ensure_sklearn():
        UIHelper.warn_html('core-reanalyze-output', '追加モジュールを読み込み中です。しばらく待ってから再実行してください。')
        return
    axis = document.getElementById('core-reanalyze-axis').value
    if not axis:
        UIHelper.warn_html('core-reanalyze-output', '軸を選択してください')
        return
    df = g_core_df_classified
    others = df[df[axis] == 'その他']
    if others.empty:
        document.getElementById('core-reanalyze-output').innerHTML = '<div class="status-ok">✅ 『その他』はありません</div>'
        return
    k = int(document.getElementById('core-reanalyze-k').value)
    n = int(document.getElementById('core-reanalyze-n').value)
    use_mece = document.getElementById('core-reanalyze-mece').checked
    try:
        texts = _core_combined_text(others, g_col_map)
        toks = texts.apply(tokenize_text)
        vec = TfidfVectorizer(min_df=1, max_df=0.9, token_pattern=r"(?u)\b\w+\b")
        tfidf = vec.fit_transform(toks)
        actual_k = min(k, len(others))
        if actual_k < 1: actual_k = 1
        km = KMeans(n_clusters=actual_k, random_state=42, n_init=10).fit(tfidf)
        samples = []
        for i in range(actual_k):
            c_idx = np.where(km.labels_ == i)[0]
            if len(c_idx) == 0: continue
            dists = euclidean_distances(tfidf[c_idx], km.cluster_centers_[i].reshape(1, -1))
            top_idx = c_idx[dists.flatten().argsort()[:n]]
            samples.append("\n--- その他グループ {} ---\n".format(i) + "\n".join(["・" + _core_text_preprocessor(texts.iloc[idx]) for idx in top_idx]))

        exist_rules = [f"- {cat}: {d['rule']}" for cat, d in g_core_rules.get(axis, {}).items()]
        exist_rules_str = "\n".join(exist_rules)
        instruction_part = "MECEを意識し、カテゴリ数は自動で最適化してください。" if use_mece else "**3個**の新しいカテゴリを追加してください。"
        g_core_reanalyze_prompt = f"""
あなたは特許ストラテジストです。分類軸「{axis}」で『その他』に残った特許を分析し、新しいカテゴリを提案してください。
# 既存分類リスト
{exist_rules_str}

# 依頼内容
以下の未分類サンプルを分析し、既存分類と重複しないカテゴリを提案してください。{instruction_part}

# JSONフォーマット
{{
  "{axis}": [
    {{"name": "新カテゴリ名", "definition": "...", "rule": "論理式"}}
  ]
}}

# 未分類特許のサンプル
{''.join(samples)}
"""
        document.getElementById('core-reanalyze-output').innerHTML = '<div class="status-ok">✅ 再分析プロンプトを生成しました</div><pre style="white-space: pre-wrap; font-size: 0.8rem;">' + g_core_reanalyze_prompt + '</pre>'
    except Exception as e:
        document.getElementById('core-reanalyze-output').innerHTML = f'<div class="status-err">❌ {escape_html(str(e))}</div>'

@ensure_core_classified('core-map', '先に分類を実行してください')
def core_draw_map(event):
    global g_core_df_classified, g_core_rules, g_col_map
    df = g_core_df_classified.copy()
    x_ax = document.getElementById('core-x-axis').value
    y_ax = document.getElementById('core-y-axis').value
    chart_type = document.getElementById('core-map-type').value
    exclude_other = document.getElementById('core-exclude-other').checked

    def get_axis_series(ax):
        if ax == '出願年':
            return df['year'].fillna(0).astype(int).astype(str), None
        if ax == '出願人':
            col = g_col_map.get('applicant')
            if col and col in df.columns:
                return df[col].fillna('Unknown'), ';'
            return pd.Series(['Unknown'] * len(df)), None
        if ax in df.columns:
            return df[ax].fillna('その他'), ';'
        return pd.Series(['その他'] * len(df)), None

    x_series, x_sep = get_axis_series(x_ax)
    y_series, y_sep = get_axis_series(y_ax)
    temp = pd.DataFrame({'X': x_series, 'Y': y_series})

    def explode_col(series, sep):
        if sep is None:
            return series.astype(str)
        return series.astype(str).str.split(sep).explode().str.strip()

    temp['X'] = explode_col(temp['X'], x_sep)
    temp['Y'] = explode_col(temp['Y'], y_sep)
    temp = temp[(temp['X'] != '') & (temp['Y'] != '')]
    if exclude_other:
        temp = temp[(temp['X'] != 'その他') & (temp['Y'] != 'その他')]

    if temp.empty:
        UIHelper.warn_html('core-map', 'データがありません')
        return

    pivot = temp.groupby(['X', 'Y']).size().reset_index(name='count')

    if chart_type == 'heatmap':
        x_vals = sorted(pivot['X'].unique())
        y_vals = sorted(pivot['Y'].unique())
        z = pd.pivot_table(pivot, index='Y', columns='X', values='count', fill_value=0).reindex(index=y_vals, columns=x_vals).values
        traces = [{"type": "heatmap", "x": x_vals, "y": y_vals, "z": z, "colorscale": "Blues"}]
        layout = ChartHelper.create_layout(title=f"特許マップ({x_ax} × {y_ax})", height=600)
    else:
        traces = [{
            "type": "scatter",
            "mode": "markers",
            "x": pivot['X'].tolist(),
            "y": pivot['Y'].tolist(),
            "marker": {"size": [max(8, int(c) * 3) for c in pivot['count']], "color": pivot['count'].tolist(), "colorscale": "Blues", "showscale": True},
            "text": [f"{x}<br>{y}<br>{c}件" for x, y, c in zip(pivot['X'], pivot['Y'], pivot['count'])],
            "hoverinfo": "text"
        }]
        layout = ChartHelper.create_layout(title=f"特許マップ({x_ax} × {y_ax})", height=600)

    ChartHelper.draw("core-map", traces, layout)

def finish_heavy_init():
    global g_df_processed, g_vectorizer, g_tfidf_matrix, g_feature_names
    if g_df_processed is None or g_tfidf_matrix is not None:
        return
    if not ensure_sklearn():
        return
    try:
        df = g_df_processed
        g_vectorizer = TfidfVectorizer(max_features=2000, min_df=2, max_df=0.95)
        g_tfidf_matrix = g_vectorizer.fit_transform(df['tokenized'].fillna(''))
        g_feature_names = g_vectorizer.get_feature_names_out().tolist()
        try:
            document.getElementById('launch-status').innerHTML += '<div class="status-ok">✅ 追加モジュールの準備が完了しました</div>'
        except Exception:
            pass
    except Exception:
        pass

@ensure_data('core-results')
def core_search(event):
    global g_df_processed, g_tfidf_matrix, g_vectorizer, g_col_map
    
    query = document.getElementById('core-query').value.strip()
    if not query:
        UIHelper.warn_html('core-results', 'クエリを入力してください')
        return
    
    target = document.getElementById('core-target').value
    limit = int(document.getElementById('core-limit').value)
    df = g_df_processed
    cm = g_col_map
    
    try:
        def evaluate_query(text, query):
            text = str(text).lower()
            query = query.strip()
            
            while '(' in query:
                match = re.search(r'\(([^()]+)\)', query)
                if match:
                    inner = match.group(1)
                    result = evaluate_query(text, inner)
                    query = query[:match.start()] + ('TRU' if result else 'FALS') + query[match.end():]
                else:
                    break
            
            query = re.sub(r'\bNOT\s+(\S+)', lambda m: 'FALS' if m.group(1).lower() in text else 'TRU', query, flags=re.IGNORECAS)
            
            parts = re.split(r'\s+AND\s+', query, flags=re.IGNORECAS)
            for part in parts:
                or_parts = re.split(r'\s+OR\s+', part, flags=re.IGNORECAS)
                or_result = False
                for op in or_parts:
                    op = op.strip()
                    if op == 'TRU':
                        or_result = True
                    elif op == 'FALS':
                        pass
                    elif op.lower() in text:
                        or_result = True
                if not or_result:
                    return False
            return True
        
        if target == 'title':
            search_col = cm.get('title', df.columns[0])
        elif target == 'abstract':
            search_col = cm.get('abstract', df.columns[0])
        else:
            search_col = 'text'
        
        if search_col == '(未選択)': search_col = 'text'
        
        q_norm = query.replace('AND', '*').replace('and', '*').replace('OR', '+').replace('or', '+')
        use_parser = any(tok in q_norm for tok in ['+', '*', 'near', 'adj', 'NEAR', 'ADJ'])
        if use_parser:
            node = parse_core_rule(q_norm)
            if not node:
                UIHelper.warn_html('core-results', 'クエリを解析できません')
                return
            mask = df[search_col].apply(lambda x: node.evaluate(_core_text_preprocessor(str(x))))
        else:
            mask = df[search_col].apply(lambda x: evaluate_query(str(x), query))
        results = df[mask].head(limit)
        
        title_col = cm.get('title', df.columns[0])
        if title_col == '(未選択)': title_col = df.columns[0]
        
        result_html = f'<div class="status-ok">🔍 {len(results)} 件ヒット（{int(mask.sum())}件中</div>'
        if len(results) > 0:
            result_html += '<table class="data-table"><tr><th>No.</th><th>タイトル</th><th>年</th><th>出願人</th></tr>'
            for i, (_, row) in enumerate(results.iterrows(), 1):
                apps = row.get('applicant_list', [])
                app_str = escape_html(str(apps[0])[:15]) if apps else '-'
                title_cut = escape_html(str(row.get(title_col, ""))[:50])
                result_html += f'<tr><td>{i}</td><td>{title_cut}</td><td>{row.get("year", "-")}</td><td>{app_str}</td></tr>'
            result_html += '</table>'
        
        document.getElementById('core-results').innerHTML = result_html
        
    except Exception as e:
        document.getElementById('core-results').innerHTML = f'<div class="status-err">❌{escape_html(str(e))}</div>'

# =====================================================
# Saturn V
# =====================================================
@ensure_data('saturn-status')
@ensure_tfidf('saturn-status')
def run_saturn(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names, g_col_map
    
    # ボタンのローディング状態を設定
    UIHelper.set_button_loading('btn-saturn-run', True)
    UIHelper.show_chart_loading('saturn-chart', True, '技術ランドスケープを生成中...')
    
    try:
        if not ensure_sklearn():
            UIHelper.show_info('saturn-status', '追加モジュールを読み込み中', 'しばらく待ってから再実行してください')
            return
        
        document.getElementById('saturn-status').innerHTML = '<span class="spinner"></span> 計算中...'
        
        df = g_df_processed
        n_clusters = int(document.getElementById('n-clusters').value)
        sample_size = int(document.getElementById('sample-size').value)
        dim_method = document.getElementById('dim-method').value
        
        if sample_size > 0 and sample_size < len(df):
            idx = np.random.choice(len(df), sample_size, replace=False)
            X = g_tfidf_matrix[idx].toarray()
            dfs = df.iloc[idx].copy().reset_index(drop=True)
        else:
            X = g_tfidf_matrix.toarray()
            dfs = df.copy().reset_index(drop=True)
            idx = np.arange(len(df))
        
        if dim_method == 'pca':
            reducer = PCA(n_components=min(50, X.shape[1]))
            X_reduced = reducer.fit_transform(X)
            reducer2d = PCA(n_components=2)
            coords = reducer2d.fit_transform(X_reduced)
        elif dim_method == 'svd':
            reducer = TruncatedSVD(n_components=min(50, X.shape[1]-1))
            X_reduced = reducer.fit_transform(X)
            reducer2d = TruncatedSVD(n_components=2)
            coords = reducer2d.fit_transform(X_reduced)
        else:
            reducer = PCA(n_components=min(30, X.shape[1]))
            X_reduced = reducer.fit_transform(X)
            tsne = TSN(n_components=2, perplexity=min(30, len(X_reduced)-1), random_state=42, n_iter=300)
            coords = tsne.fit_transform(X_reduced)
        
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        labels = kmeans.fit_predict(X_reduced if dim_method != 'tsne' else coords)
        
        dfs['x'] = coords[:, 0]
        dfs['y'] = coords[:, 1]
        dfs['cluster'] = labels
        
        def get_top_words(row_idx, n=3):
            row = g_tfidf_matrix[idx[row_idx]].toarray().flatten()
            top_indices = np.argsort(row)[::-1][:n]
            return ', '.join([g_feature_names[i] for i in top_indices if row[i] > 0][:n])
        
        title_col = g_col_map.get('title', df.columns[0])
        if title_col == '(未選択)': title_col = df.columns[0]
        
        # EAGLEオプション取得
        show_contour = document.getElementById('saturn-contour').checked
        show_hull = document.getElementById('saturn-hull').checked
        show_labels = document.getElementById('saturn-labels').checked
        
        traces = []
        
        # 等高線表示 (histogram2dcontour) - 2D等高線
        if show_contour:
            x_all = [float(c) for c in coords[:, 0]]
            y_all = [float(c) for c in coords[:, 1]]
            
            # Plotly.js の histogram2dcontour を使用
            debugLog(f'Contour data: {len(x_all)} points')
            traces.append({
                "type": "histogram2dcontour",
                "x": x_all,
                "y": y_all,
                "colorscale": "Blues",
                "reversescale": False,
                "showscale": False,
                "autocontour": True,
                "ncontours": 20,
                "contours": {"coloring": "heatmap", "showlines": True},
                "line": {"width": 0.5, "color": "rgba(255,255,255,0.3)"},
                "hoverinfo": "skip",
                "name": "等高線"
            })
        
        # クラスタ境界
        if show_hull:
            for k in range(n_clusters):
                cluster_mask = dfs['cluster'] == k
                if cluster_mask.sum() < 3:
                    continue
                cluster_points = coords[cluster_mask]
                
                # 凸包計算（簡易版：点を角度でソート）
                # scipy がない場合でも動作する簡易的な外周計算
                center = cluster_points.mean(axis=0)
                angles = np.arctan2(cluster_points[:, 1] - center[1], 
                                   cluster_points[:, 0] - center[0])
                sorted_idx = np.argsort(angles)
                # 外周の点のみを抽出（点の20%または最低8点）
                n_hull = max(8, len(sorted_idx) // 5)
                step = max(1, len(sorted_idx) // n_hull)
                hull_idx = sorted_idx[::step]
                sorted_points = cluster_points[hull_idx]
                hull_x = list(sorted_points[:, 0]) + [sorted_points[0, 0]]
                hull_y = list(sorted_points[:, 1]) + [sorted_points[0, 1]]
                
                # 色を解析
                color = COLOR_SEQUENCE[k % len(COLOR_SEQUENCE)]
                r = int(color[1:3], 16)
                g = int(color[3:5], 16)
                b = int(color[5:7], 16)
                
                traces.append({
                    "type": "scatter",
                    "mode": "lines",
                    "x": [float(x) for x in hull_x],
                    "y": [float(y) for y in hull_y],
                    "line": {"color": color, "width": 2, "dash": "dot"},
                    "fill": "toself",
                    "fillcolor": f"rgba({r},{g},{b},0.1)",
                    "showlegend": False,
                    "hoverinfo": "skip",
                    "name": f"C{k+1}境界"
                })
        
        # クラスタ散币
        for k in range(n_clusters):
            mask = dfs['cluster'] == k
            if mask.sum() == 0: continue
            subset = dfs[mask]
            subset_idx = np.where(mask)[0]
            
            # ホバーテキスト（ホバー時のみ表示）
            hover_texts = []
            for i in subset_idx:
                title = str(dfs.iloc[i].get(title_col, ''))[:40]
                apps = dfs.iloc[i].get('applicant_list', [])
                app = apps[0][:20] if apps else '-'
                kw = get_top_words(i)
                hover_texts.append(f'<b>{title}...</b><br>出願人: {app}<br>KW: {kw}')
            
            trace = {
                "x": [float(x) for x in subset['x']],
                "y": [float(y) for y in subset['y']],
                "mode": "markers",
                "type": "scatter",
                "name": f"C{k+1} ({len(subset)}件)",
                "text": hover_texts,
                "hoverinfo": "text",
                "marker": {"size": 8, "color": COLOR_SEQUENCE[k % len(COLOR_SEQUENCE)], "opacity": 0.75, "line": {"width": 0.5, "color": "#fff"}}
            }
            
            traces.append(trace)
        
        # クラスタ中心性ラベル
        if show_labels:
            center_x = []
            center_y = []
            center_text = []
            for k in range(n_clusters):
                mask = dfs['cluster'] == k
                if mask.sum() == 0: continue
                cx = dfs.loc[mask, 'x'].mean()
                cy = dfs.loc[mask, 'y'].mean()
                center_x.append(float(cx))
                center_y.append(float(cy))
                
                # クラスタの主要キーワードを取得
                cluster_indices = np.where(mask)[0]
                cluster_tfidf = g_tfidf_matrix[idx[cluster_indices]].mean(axis=0).A1
                top_idx = np.argsort(cluster_tfidf)[::-1][:2]
                top_kw = ', '.join([g_feature_names[i] for i in top_idx])
                center_text.append(f"<b>C{k+1}</b><br>{top_kw}")
            
            traces.append({
                "x": center_x,
                "y": center_y,
                "mode": "text",
                "type": "scatter",
                "text": center_text,
                "textfont": {"size": 11, "color": "#fff"},
                "showlegend": False,
                "hoverinfo": "skip"
            })
        
        layout = ChartHelper.create_layout(
            title=f"技術ランドスケープ ({dim_method.upper()} + K-Means)",
            height=600,
            showlegend=True,
            legend={"orientation": "h", "y": -0.1}
        )
        ChartHelper.draw("saturn-chart", traces, layout)
        
        import html as html_module
        summary_html = '<h4 style="margin-top: 0.5rem;">クラスタサマリー</h4><table class="data-table"><tr><th>クラスタ</th><th>件数</th><th>主要キーワード</th></tr>'
        for k in range(n_clusters):
            mask = dfs['cluster'] == k
            cnt = int(mask.sum())
            if cnt > 0:
                cluster_indices = np.where(mask)[0]
                cluster_tfidf = g_tfidf_matrix[idx[cluster_indices]].mean(axis=0).A1
                top_indices = np.argsort(cluster_tfidf)[::-1][:5]
                top_words = ', '.join([html_module.escape(str(g_feature_names[i])) for i in top_indices])
                summary_html += f'<tr><td style="color:{COLOR_SEQUENCE[k % len(COLOR_SEQUENCE)]}; font-weight:bold;">C{k+1}</td><td>{cnt}</td><td style="font-size:0.75rem;">{top_words}</td></tr>'
        summary_html += '</table>'
        document.getElementById('saturn-summary').innerHTML = summary_html
        UIHelper.show_success('saturn-status', '分析完了', f'{n_clusters}クラスタを検出しました')
        
    except Exception as e:
        import traceback
        UIHelper.show_error('saturn-status', 'エラーが発生しました', str(e))
        debugLog(traceback.format_exc())
    finally:
        UIHelper.set_button_loading('btn-saturn-run', False)
        UIHelper.show_chart_loading('saturn-chart', False)

# =====================================================
# Explorer
# =====================================================
@ensure_tfidf('keyword-chart')
def show_keywords(event):
    global g_tfidf_matrix, g_feature_names
    
    top_n = int(document.getElementById('keyword-top').value)
    
    sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
    top_indices = np.argsort(sums)[::-1][:top_n]
    
    words = [g_feature_names[i] for i in top_indices]
    scores = [float(sums[i]) for i in top_indices]
    
    colors = [f'rgba(79, 195, 247, {0.4 + 0.6 * (1 - i/top_n)})' for i in range(top_n)]
    
    traces = [ChartHelper.create_bar_trace(
        x=scores[::-1],
        y=words[::-1],
        orientation="h",
        color=colors[0]
    )]
    traces[0]["marker"] = {"color": colors[::-1]}
    layout = ChartHelper.create_horizontal_bar_layout(
        title=f"キーワードランキング TOP{top_n}",
        x_title="",
        y_title="",
        left_margin=150
    )
    layout["yaxis"]["categoryorder"] = "total ascending"
    layout["height"] = max(450, top_n * 20)
    ChartHelper.draw("keyword-chart", traces, layout)

@ensure_data('trend-chart')
def show_trend(event):
    global g_df_processed
    
    keywords = [k.strip() for k in document.getElementById('trend-keywords').value.split(',') if k.strip()]
    if not keywords:
        UIHelper.warn_html('trend-chart', 'キーワードを入力してください')
        return
    
    df = g_df_processed
    
    traces = []
    for i, kw in enumerate(keywords[:5]):
        mask = df['tokenized'].str.contains(kw.lower(), na=False)
        trend = df[mask].groupby('year').size()
        trend = trend[trend.index > 0].sort_index()
        
        traces.append(ChartHelper.create_line_trace(
            x=[int(x) for x in trend.index],
            y=[int(y) for y in trend.values],
            name=kw,
            color=COLOR_SEQUENCE[i % len(COLOR_SEQUENCE)]
        ))
    
    layout = ChartHelper.create_layout(
        title="キーワードトレンド",
        height=450,
        xaxis={"title": "年"},
        yaxis={"title": "出現件数", "rangemode": "tozero"}
    )
    ChartHelper.draw("trend-chart", traces, layout)

@ensure_data('compare-chart')
@ensure_tfidf('compare-chart')
def compare_companies(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    sel = document.getElementById('compare-companies')
    companies = [sel.options.item(i).value for i in range(sel.options.length) if sel.options.item(i).selected]
    
    if len(companies) < 2:
        UIHelper.warn_html('compare-chart', '2社以上選択してください')
        return
    
    df = g_df_processed
    
    traces = []
    for i, company in enumerate(companies[:6]):
        mask = df['applicant_list'].apply(lambda x: company in x if x else False)
        company_indices = np.where(mask)[0]
        
        if len(company_indices) > 0:
            company_tfidf = g_tfidf_matrix[company_indices].mean(axis=0).A1
            top_indices = np.argsort(company_tfidf)[::-1][:10]
            words = [g_feature_names[j] for j in top_indices]
            scores = [float(company_tfidf[j]) for j in top_indices]
            
            traces.append({
                "type": "scatterpolar",
                "r": scores + [scores[0]],
                "theta": words + [words[0]],
                "fill": "toself",
                "name": company[:20],
                "line": {"color": COLOR_SEQUENCE[i % len(COLOR_SEQUENCE)]},
                "opacity": 0.7
            })
    
    layout = ChartHelper.create_layout(
        title="企業キーワードプロファイル比較",
        polar={"radialaxis": {"visible": True, "range": [0, max([max(t['r']) for t in traces]) * 1.1]}},
        height=550,
        showlegend=True
    )
    ChartHelper.draw("compare-chart", traces, layout)

@ensure_data('heatmap-chart')
@ensure_tfidf('heatmap-chart')
def show_heatmap(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    n_companies = int(document.getElementById('heatmap-companies').value)
    n_keywords = int(document.getElementById('heatmap-keywords').value)
    
    df = g_df_processed
    
    top_companies = df.explode('applicant_list')['applicant_list'].value_counts().head(n_companies).index.tolist()
    
    sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
    top_kw_indices = np.argsort(sums)[::-1][:n_keywords]
    top_keywords = [g_feature_names[i] for i in top_kw_indices]
    
    z = []
    for company in top_companies:
        mask = df['applicant_list'].apply(lambda x: company in x if x else False)
        company_indices = np.where(mask)[0]
        if len(company_indices) > 0:
            company_tfidf = g_tfidf_matrix[company_indices].mean(axis=0).A1
            row = [float(company_tfidf[i]) for i in top_kw_indices]
        else:
            row = [0] * n_keywords
        z.append(row)
    
    traces = [{
        "type": "heatmap",
        "z": z,
        "x": top_keywords,
        "y": [c[:15] for c in top_companies],
        "colorscale": "Blues",
        "showscale": True
    }]
    layout = ChartHelper.create_layout(
        title="企業×キーワードヒートマップ",
        height=max(450, n_companies * 30),
        margin={"l": 150, "b": 120},
        xaxis={"tickangle": -45}
    )
    ChartHelper.draw("heatmap-chart", traces, layout)

# =====================================================
# Explorer - 急上昇ワード検出
# =====================================================
@ensure_data('emerging-chart')
@ensure_tfidf('emerging-chart')
def show_emerging(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names, g_vectorizer
    
    base_year = int(document.getElementById('emerging-year').value)
    top_n = int(document.getElementById('emerging-top').value)
    
    df = g_df_processed
    
    # 期間分
    df_old = df[df['year'] < base_year]
    df_new = df[df['year'] >= base_year]
    
    if len(df_old) < 10 or len(df_new) < 10:
        UIHelper.warn_html('emerging-chart', 'データが不足しています（期間を調整してください）')
        return
    
    # 年間キーワード頻度を計算
    old_indices = df_old.index.tolist()
    new_indices = df_new.index.tolist()
    
    # インデックスをソーティング
    old_mask = df.index.isin(old_indices)
    new_mask = df.index.isin(new_indices)
    
    old_idx = np.where(old_mask)[0]
    new_idx = np.where(new_mask)[0]
    
    if len(old_idx) == 0 or len(new_idx) == 0:
        UIHelper.warn_html('emerging-chart', '期間データがありません')
        return
    
    # TF-IDF合計を計算
    old_tfidf = np.array(g_tfidf_matrix[old_idx].sum(axis=0)).flatten() / len(old_idx)
    new_tfidf = np.array(g_tfidf_matrix[new_idx].sum(axis=0)).flatten() / len(new_idx)
    
    # 成長率計算（新期間/旧期間 - 1）
    growth = np.zeros(len(g_feature_names))
    for i in range(len(g_feature_names)):
        if old_tfidf[i] > 0.001:
            growth[i] = (new_tfidf[i] - old_tfidf[i]) / old_tfidf[i]
        elif new_tfidf[i] > 0.01:
            growth[i] = 10  # 新出キーワード    
    # 新期間で一定以上頻度があるもののみ
    valid_mask = new_tfidf > 0.005
    growth[~valid_mask] = -999
    
    top_indices = np.argsort(growth)[::-1][:top_n]
    
    words = [g_feature_names[i] for i in top_indices]
    growth_rates = [float(growth[i]) * 100 for i in top_indices]  # パーセンテージ
    
    # D3アニメーション棒グラフ用のデータ準備
    bar_data = [{"label": f"{w} (+{g:.0f}%)" if g > 0 else f"{w} ({g:.0f}%)", "value": g} 
                for w, g in zip(words, growth_rates)]
    title = f"急上昇キーワード TOP{top_n}（{base_year}年以降 vs 以前）"
    
    # D3.jsでアニメーション付き棒グラフを描画
    window.drawAnimatedBarChart("emerging-chart", json.dumps(bar_data), title, "viridis")

# =====================================================
# KWIC検索 (Keyword in Context)
# =====================================================
@ensure_data('kwic-result', 'データが読み込まれていません')
def kwic_search(event):
    global g_df_processed
    
    keyword = document.getElementById('kwic-keyword').value.strip()
    if not keyword:
        UIHelper.warn_html('kwic-result', 'キーワードを入力してください')
        return
    
    context_len = int(document.getElementById('kwic-context').value)
    target = document.getElementById('kwic-target').value
    
    df = g_df_processed
    
    # 検索対象列を決定
    target_col = None
    target_cols = {
        'title': ['発明名称', 'title', 'Title', '名称'],
        'abstract': ['要約', 'abstract', 'Abstract', '概要'],
        'claims': ['請求項', 'claims', 'Claims', '請求の範囲']
    }
    
    for col_name in target_cols.get(target, []):
        if col_name in df.columns:
            target_col = col_name
            break
    
    if target_col is None:
        document.getElementById('kwic-result').innerHTML = f'<div class="status-warn">対象列が見つかりません: {target}</div>'
        return
    
    results = []
    keyword_lower = keyword.lower()
    
    for idx, row in df.iterrows():
        text = str(row.get(target_col, ''))
        if not text:
            continue
        
        text_lower = text.lower()
        pos = 0
        while True:
            pos = text_lower.find(keyword_lower, pos)
            if pos == -1:
                break
            
            start = max(0, pos - context_len)
            end = min(len(text), pos + len(keyword) + context_len)
            
            before = text[start:pos]
            match = text[pos:pos + len(keyword)]
            after = text[pos + len(keyword):end]
            
            prefix = '...' if start > 0 else ''
            suffix = '...' if end < len(text) else ''
            
            doc_id = str(row.get('publication_number', row.get('出願番号', idx)))[:20]
            applicant = str(row.get('applicant_list', [''])[0] if isinstance(row.get('applicant_list'), list) else row.get('出願人', ''))[:20]
            
            results.append({
                'doc_id': doc_id,
                'applicant': applicant,
                'context': f'{prefix}{escape_html(before)}<mark style="background:#ffd93d;color:#000;font-weight:bold;">{escape_html(match)}</mark>{escape_html(after)}{suffix}'
            })
            
            pos += len(keyword)
            
            if len(results) >= 100:  # 最大100件
                break
        
        if len(results) >= 100:
            break
    
    if not results:
        document.getElementById('kwic-result').innerHTML = f'<div class="status-warn">「{escape_html(keyword)}」が見つかりませんでした</div>'
        return
    
    result_html = f'''
        <div style="margin-bottom: 0.5rem; color: #4fc3f7;">
            <strong>検索結果: {len(results)}件</strong>（最大100件表示）</div>
        <table class="data-table" style="font-size: 0.85rem;">
            <tr><th style="width:15%;">文書ID</th><th style="width:15%;">出願人</th><th>コンテキスト</th></tr>
    '''
    
    for r in results:
        result_html += f'<tr><td>{escape_html(r["doc_id"])}</td><td>{escape_html(r["applicant"])}</td><td style="text-align:left;">{r["context"]}</td></tr>'
    
    result_html += '</table>'
    document.getElementById('kwic-result').innerHTML = result_html

# =====================================================
# CREW - ネットワーク分析
# =====================================================
@ensure_data('network-status')
def build_network(event):
    global g_df_processed
    if not ensure_networkx():
        UIHelper.warn_html('network-status', '追加モジュールを読み込み中です。しばらく待ってから再実行してください。')
        return
    
    document.getElementById('network-status').innerHTML = '<div class="spinner" style="width:25px;height:25px;display:inline-block;"></div> 構築中...'
    
    try:
        df = g_df_processed
        network_type = document.getElementById('network-type').value
        min_edge = int(document.getElementById('min-edge').value)
        
        G = nx.Graph()
        
        if network_type == 'inventor':
            col = 'inventor_list'
        elif network_type == 'applicant':
            col = 'applicant_list'
        else:
            col = 'ipc_list'
        
        edge_counts = Counter()
        for items in df[col]:
            if len(items) >= 2:
                for i in range(len(items)):
                    for j in range(i+1, len(items)):
                        edge = tuple(sorted([items[i], items[j]]))
                        edge_counts[edge] += 1
        
        for (n1, n2), weight in edge_counts.items():
            if weight >= min_edge:
                G.add_edge(n1, n2, weight=weight)
        
        if len(G.nodes()) == 0:
            UIHelper.warn_html('network-status', 'ノードがありません。最小エッジ重みを下げてください')
            return
        
        # ノード数制限
        max_nodes = int(document.getElementById('network-max-nodes').value)
        if len(G.nodes()) > max_nodes:
            # 次数上位ノードのみを残す
            degrees_all = dict(G.degree())
            top_nodes_list = sorted(degrees_all.items(), key=lambda x: -x[1])[:max_nodes]
            keep_nodes = set([n for n, _ in top_nodes_list])
            G = G.subgraph(keep_nodes).copy()
        
        pos = nx.spring_layout(G, k=2/np.sqrt(len(G.nodes())), iterations=50, seed=42)
        
        # 中心性を選択
        centrality_type = document.getElementById('network-centrality').value
        
        if centrality_type == 'betweenness':
            centrality = nx.betweenness_centrality(G)
            centrality_name = '媒介中心性'
        elif centrality_type == 'closeness':
            centrality = nx.closeness_centrality(G)
            centrality_name = '近接中心性'
        elif centrality_type == 'eigenvector':
            try:
                centrality = nx.eigenvector_centrality(G, max_iter=100)
            except (nx.NetworkXException, nx.PowerIterationFailedConvergence):
                centrality = nx.degree_centrality(G)  # Fallback if eigenvector fails
            centrality_name = '固有ベクトル中心性'
        else:
            centrality = nx.degree_centrality(G)
            centrality_name = '次数中心性'
        
        degrees = dict(G.degree())
        max_degree = max(degrees.values()) if degrees else 1
        max_centrality = max(centrality.values()) if centrality else 1
        
        # D3 Force用のノードデータを準備
        nodes_data = []
        for i, n in enumerate(G.nodes()):
            nodes_data.append({
                "id": n,
                "label": str(n),
                "size": 8 + 20 * (degrees[n] / max_degree),
                "degree": degrees[n],
                "centrality": centrality[n],
                "group": i % 10
            })
        
        # D3 Force用のリンクデータを準備
        links_data = []
        for edge in G.edges(data=True):
            links_data.append({
                "source": edge[0],
                "target": edge[1],
                "weight": edge[2].get('weight', 1)
            })
        
        type_name = {'inventor': '発明者', 'applicant': '出願人', 'ipc': 'IPC'}[network_type]
        title = f"{type_name}ネットワーク（{len(G.nodes())}ノード）- {centrality_name}"
        
        # D3.jsでインタラクティブなネットワークを描画
        window.drawForceNetwork("network-chart", json.dumps(nodes_data), json.dumps(links_data), title)
        
        stats_html = f'''
            <div class="metrics">
                <div class="metric"><div class="metric-value">{len(G.nodes())}</div><div class="metric-label">ノード数</div></div>
                <div class="metric"><div class="metric-value">{len(G.edges())}</div><div class="metric-label">エッジ数</div></div>
                <div class="metric"><div class="metric-value">{nx.number_connected_components(G)}</div><div class="metric-label">連結成分数</div></div>
                <div class="metric"><div class="metric-value">{nx.density(G):.3f}</div><div class="metric-label">密度</div></div>
            </div>
            <p style="color:#4fc3f7; margin:0.5rem 0; font-size:0.9rem;">💡 ノードをドラッグして動かせます</p>
            <h4>{centrality_name} TOP10</h4>
            <table class="data-table"><tr><th>ノード</th><th>次数</th><th>{centrality_name}</th></tr>
        '''
        top_nodes = sorted(centrality.items(), key=lambda x: -x[1])[:10]
        for node, cent in top_nodes:
            stats_html += f'<tr><td>{escape_html(str(node)[:30])}</td><td>{degrees[node]}</td><td>{cent:.3f}</td></tr>'
        stats_html += '</table>'
        document.getElementById('network-stats').innerHTML = stats_html
        document.getElementById('network-status').innerHTML = '<span class="status-ok">✅ 完了</span>'
        
    except Exception as e:
        import traceback
        document.getElementById('network-status').innerHTML = f'<span class="status-err">❌{escape_html(str(e))}</span>'
        debugLog(traceback.format_exc())

# =====================================================
# MEGA - ワードクラウド（D3-cloud使用）
# =====================================================
@ensure_data('wordcloud-chart', '先にCSVデータを読み込んでください')
def show_wordcloud(event):
    """
    d3-cloudを使用した本格的なワードクラウドを生成する。
    TF-IDFスコアに基づいて単語サイズと配置を決定。
    TF-IDF未実行の場合は自動的に実行する。
    """
    global g_tfidf_matrix, g_feature_names, g_vectorizer, g_df_processed
    
    # TF-IDF未実行なら自動実行
    if g_tfidf_matrix is None:
        document.getElementById('wordcloud-chart').innerHTML = '<div class="status-info">🔄 TF-IDF分析を自動実行中...</div>'
        
        if not ensure_sklearn():
            UIHelper.warn_html('wordcloud-chart', 'scikit-learnを読み込み中です。しばらく待ってから再実行してください。')
            return
        
        try:
            g_vectorizer = TfidfVectorizer(max_features=2000, min_df=2, max_df=0.95)
            g_tfidf_matrix = g_vectorizer.fit_transform(g_df_processed['tokenized'].fillna(''))
            g_feature_names = g_vectorizer.get_feature_names_out().tolist()
            debugLog(f"[WordCloud] TF-IDF自動実行完了: {len(g_feature_names)} features")
        except Exception as e:
            document.getElementById('wordcloud-chart').innerHTML = f'<div class="status-err">TF-IDF分析エラー: {escape_html(str(e))}</div>'
            return
    
    max_words = int(document.getElementById('wc-max-words').value)
    colorscheme = document.getElementById('wc-colorscheme').value
    
    # TF-IDFスコアの合計を計算
    sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
    top_indices = np.argsort(sums)[::-1][:max_words]
    
    # 単語データを準備（d3-cloud用）
    word_data = []
    for i in top_indices:
        word_data.append({
            "text": g_feature_names[i],
            "score": float(sums[i])
        })
    
    # JavaScript側のdrawWordCloud関数を呼び出す
    window.drawWordCloud("wordcloud-chart", json.dumps(word_data), colorscheme)

# =====================================================
# MEGA - N-gram分析
# =====================================================
@ensure_data('ngram-chart')
def show_ngram(event):
    global g_df_processed
    
    n = int(document.getElementById('ngram-size').value)
    top_n = int(document.getElementById('ngram-top').value)
    
    df = g_df_processed
    
    # N-gramを抽出
    ngram_counter = Counter()
    for tokens in df['tokenized'].dropna():
        words = tokens.split()
        if len(words) >= n:
            for i in range(len(words) - n + 1):
                ngram = ' '.join(words[i:i+n])
                ngram_counter[ngram] += 1
    
    top_ngrams = ngram_counter.most_common(top_n)
    
    if not top_ngrams:
        UIHelper.warn_html('ngram-chart', 'N-gramが見つかりません')
        return
    
    # D3アニメーション棒グラフ用のデータ準備
    bar_data = [{"label": ng, "value": int(c)} for ng, c in top_ngrams]
    title = f"{'バイ' if n==2 else 'トライ'}グラム TOP{top_n}"
    # D3.jsでアニメーション付き棒グラフを描画
    window.drawAnimatedBarChart("ngram-chart", json.dumps(bar_data), title, "warm")

# =====================================================
# MEGA - 共起ネットワーク
# =====================================================
@ensure_data('cooccur-chart')
@ensure_tfidf('cooccur-chart')
def show_cooccurrence(event):
    global g_df_processed, g_feature_names, g_tfidf_matrix
    if not ensure_networkx():
        UIHelper.warn_html('cooccur-chart', '追加モジュールを読み込み中です。しばらく待ってから再実行してください。')
        return
    
    n_nodes = int(document.getElementById('cooccur-nodes').value)
    min_cooccur = int(document.getElementById('cooccur-min').value)
    
    df = g_df_processed
    
    # 頻出キーワードを抽出
    sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
    top_indices = np.argsort(sums)[::-1][:n_nodes]
    top_words = [g_feature_names[i] for i in top_indices]
    top_words_set = set(top_words)
    
    # 共起カウント
    cooccur = Counter()
    for tokens in df['tokenized'].dropna():
        words = [w for w in tokens.split() if w in top_words_set]
        words = list(set(words))
        if len(words) >= 2:
            for i in range(len(words)):
                for j in range(i+1, len(words)):
                    pair = tuple(sorted([words[i], words[j]]))
                    cooccur[pair] += 1
    
    # ネットワーク構築
    G = nx.Graph()
    for (w1, w2), cnt in cooccur.items():
        if cnt >= min_cooccur:
            G.add_edge(w1, w2, weight=cnt)
    
    if len(G.nodes()) == 0:
        UIHelper.warn_html('cooccur-chart', '共起関係がありません。閾値を下げてください')
        return
    
    degrees = dict(G.degree())
    max_deg = max(degrees.values()) if degrees else 1
    
    # D3 Force用のノードデータ
    nodes_data = []
    for i, n in enumerate(G.nodes()):
        nodes_data.append({
            "id": n,
            "label": str(n),
            "size": 6 + 10 * (degrees[n] / max_deg),
            "degree": degrees[n],
            "centrality": degrees[n] / max_deg,
            "group": i % 10
        })
    
    # D3 Force用のリンクデータ
    links_data = []
    for edge in G.edges(data=True):
        links_data.append({
            "source": edge[0],
            "target": edge[1],
            "weight": edge[2].get('weight', 1)
        })
    
    title = f"キーワード共起ネットワーク（{len(G.nodes())}語 / {len(G.edges())}エッジ）"
    
    # D3.jsでインタラクティブな共起ネットワークを描画
    window.drawForceNetwork("cooccur-chart", json.dumps(nodes_data), json.dumps(links_data), title)

# =====================================================
# NOVA - アドバンスド可視化（PyScript限定機能）
# =====================================================

@ensure_data('sankey-chart', 'データを読み込んでください')
def show_sankey(event):
    """
    サンキーダイアグラムを生成する（D3.js版）。
    出願人と技術分野（IPC/FI）の関係をフロー図で可視化。
    
    Parameters
    ----------
    event : Event
        ボタンクリックイベント    """
    global g_df_processed
    
    n_applicants = int(document.getElementById('sankey-applicants').value)
    n_ipcs = int(document.getElementById('sankey-ipcs').value)
    color_scheme = document.getElementById('sankey-color').value
    
    df = g_df_processed.copy()
    
    # 出願人とIPC/FIの集計（IPCがなければFIを使用）
    rows = []
    for _, row in df.iterrows():
        apps = row.get('applicant_list', [])
        # IPCを優先、なければFIを使用
        ipcs = row.get('ipc_list', [])
        if not ipcs:
            ipcs = row.get('fi_list', [])
        if not apps or not ipcs:
            continue
        for app in apps[:2]:  # 最大2出願人
            for ipc in ipcs[:2]:  # 最大2IPC/FI
                ipc_main = ipc[:4] if len(ipc) >= 4 else ipc
                rows.append({'applicant': app.strip(), 'ipc': ipc_main})
    
    if not rows:
        UIHelper.warn_html('sankey-chart', '出願人/IPC・FIデータが不足しています')
        return
    
    flow_df = pd.DataFrame(rows)
    
    # 上位出願人
    top_apps = flow_df['applicant'].value_counts().head(n_applicants).index.tolist()
    
    # 上位IPC/FI
    top_ipcs = flow_df['ipc'].value_counts().head(n_ipcs).index.tolist()
    
    # フィルタリング
    flow_df = flow_df[flow_df['applicant'].isin(top_apps) & flow_df['ipc'].isin(top_ipcs)]
    flow_counts = flow_df.groupby(['applicant', 'ipc']).size().reset_index(name='count')
    
    # サンキー用データ構造
    nodes = []
    node_map = {}
    
    for app in top_apps:
        node_map[f"app_{app}"] = len(nodes)
        nodes.append({"name": app})
    
    for ipc in top_ipcs:
        node_map[f"ipc_{ipc}"] = len(nodes)
        nodes.append({"name": ipc})
    
    links = []
    for _, row in flow_counts.iterrows():
        source_key = f"app_{row['applicant']}"
        target_key = f"ipc_{row['ipc']}"
        if source_key in node_map and target_key in node_map:
            links.append({
                "source": node_map[source_key],
                "target": node_map[target_key],
                "value": int(row['count'])
            })
    
    sankey_data = {"nodes": nodes, "links": links}
    
    # D3.jsでサンキーダイアグラムを描画
    window.drawSankeyDiagram("sankey-chart", json.dumps(sankey_data), color_scheme)

@ensure_data('race-chart', 'データを読み込んでください')
def show_bubble_race(event=None):
    """
    バブルレースチャートを生成・再生する。
    年ごとの出願人ランキングをアニメーションで表示。
    
    Parameters
    ----------
    event : Event
        ボタンクリックイベント
    """
    global g_df_processed
    
    n_companies = int(document.getElementById('race-companies').value)
    speed_val = document.getElementById('race-speed').value
    speed_map = {'slow': 1000, 'normal': 500, 'fast': 250, 'ultra': 100}
    speed = speed_map.get(speed_val, 250)
    
    df = g_df_processed.copy()
    
    # year列が0の欠損データを除外
    df = df[df['year'] > 0].copy()
    
    if len(df) == 0:
        UIHelper.warn_html('race-chart', '年データがありません')
        return
    
    # explodeを使って出願人を展開
    exp = df.explode('applicant_list')
    exp = exp[exp['applicant_list'].notna()]
    exp['applicant_list'] = exp['applicant_list'].astype(str).str.strip()
    exp = exp[exp['applicant_list'] != '']
    
    if len(exp) == 0:
        UIHelper.warn_html('race-chart', '出願人データがありません')
        return
    
    # 年ごと・出願人ごとの件数集計
    year_app_counts = exp.groupby(['year', 'applicant_list']).size().reset_index(name='count')
    
    # デバッグログ
    debugLog(f"[BubbleRace] Total records: {len(year_app_counts)}, Years: {exp['year'].nunique()}, Applicants: {exp['applicant_list'].nunique()}")
    
    # 年ごとのデータを構築
    year_data = {}
    for _, row in year_app_counts.iterrows():
        year_int = int(row['year'])
        if year_int not in year_data:
            year_data[year_int] = {}
        year_data[year_int][row['applicant_list']] = int(row['count'])
    
    if not year_data:
        UIHelper.warn_html('race-chart', '年次データが不足しています')
        return
    
    # 注意: 年の出願人数を確認    for y in sorted(year_data.keys())[:3]:
        apps_in_year = year_data[y]
        debugLog(f"[BubbleRace] Year {y}: {len(apps_in_year)} applicants")
        top3 = sorted(apps_in_year.items(), key=lambda x: x[1], reverse=True)[:3]
        for name, cnt in top3:
            debugLog(f"  - {name[:30]}: {cnt}")
    
    # 累積データに変換
    sorted_years = sorted(year_data.keys())
    cumulative = {}
    race_data = {}
    
    for year in sorted_years:
        for app, count in year_data[year].items():
            cumulative[app] = cumulative.get(app, 0) + count
        
        # 上位N社
        sorted_apps = sorted(cumulative.items(), key=lambda x: x[1], reverse=True)[:n_companies]
        race_data[str(year)] = [{"name": a[0], "value": a[1]} for a in sorted_apps]
    
    debugLog(f"[BubbleRace] Years: {len(sorted_years)}, Total applicants: {len(cumulative)}")
    
    # D3.jsでバブルレースを初期化
    window.drawBubbleRace("race-chart", json.dumps(race_data), speed)

@ensure_data('circle-chart', 'データを読み込んでください')
def show_circle_packing(event):
    """
    サークルパッキングを生成する。
    階層的データ構造をインタラクティブに表示。
    
    Parameters
    ----------
    event : Event
        ボタンクリックイベント
    """
    global g_df_processed, g_col_map
    
    hierarchy = document.getElementById('circle-hierarchy').value
    n_count = int(document.getElementById('circle-count').value)
    
    df = g_df_processed.copy()
    
    if hierarchy == 'applicant-ipc':
        # 出願人 →IPC 階層
        parent_col = 'applicant_list'
        child_col = 'ipc_list'
    elif hierarchy == 'ipc-applicant':
        # IPC →出願人 階層
        parent_col = 'ipc_list'
        child_col = 'applicant_list'
    else:
        # 年 →出願人 階層
        parent_col = 'year'
        child_col = 'applicant_list'
    
    # データ集計
    hierarchy_data = {}
    for _, row in df.iterrows():
        if parent_col == 'year':
            parents = [str(row.get('year', ''))]
        else:
            parents = row.get(parent_col, [])[:1]
        
        children = row.get(child_col, [])[:2] if child_col != 'year' else [str(row.get('year', ''))]
        
        if not parents or not children:
            continue
        
        for parent in parents:
            parent = str(parent).strip()
            if not parent:
                continue
            if parent not in hierarchy_data:
                hierarchy_data[parent] = {}
            
            for child in children:
                child = str(child).strip()[:20] if child_col == 'applicant_list' else str(child).strip()[:4]
                if not child:
                    continue
                hierarchy_data[parent][child] = hierarchy_data[parent].get(child, 0) + 1
    
    # 上位親を選択
    parent_totals = {p: sum(c.values()) for p, c in hierarchy_data.items()}
    top_parents = sorted(parent_totals.items(), key=lambda x: x[1], reverse=True)[:n_count]
    
    # 階層データ構造を構築
    children_list = []
    for parent, total in top_parents:
        child_items = hierarchy_data.get(parent, {})
        # 上位子要素
        top_children = sorted(child_items.items(), key=lambda x: x[1], reverse=True)[:8]
        children_list.append({
            "name": parent[:15] if len(parent) > 15 else parent,
            "children": [{"name": c[0], "value": c[1]} for c in top_children]
        })
    
    root_data = {
        "name": "Patent Data",
        "children": children_list
    }
    
    # 案件リスト表示用のデータを構築
    patent_data = {}
    app_col = g_col_map.get('applicant')
    title_col = g_col_map.get('title')
    appno_col = g_col_map.get('app_number')
    
    for parent, total in top_parents:
        parent_key = parent[:15] if len(parent) > 15 else parent
        parent_patents = []
        
        # 親に該当する案件を抽出
        for _, row in df.iterrows():
            if parent_col == 'year':
                if str(row.get('year', '')) == parent:
                    parent_patents.append({
                        "app_number": str(row.get(appno_col, ''))[:20] if appno_col else '',
                        "title": str(row.get(title_col, ''))[:80] if title_col else '',
                        "year": str(row.get('year', '')),
                        "applicant": str(row.get(parent_col, [])[:1][0] if row.get(parent_col) else '')[:30]
                    })
            else:
                parents_in_row = row.get(parent_col, [])
                if parent in [str(p) for p in parents_in_row]:
                    applicant_str = ''
                    if app_col:
                        app_list = row.get('applicant_list', [])
                        applicant_str = app_list[0] if app_list else ''
                    parent_patents.append({
                        "app_number": str(row.get(appno_col, ''))[:20] if appno_col else '',
                        "title": str(row.get(title_col, ''))[:80] if title_col else '',
                        "year": str(row.get('year', '')),
                        "applicant": str(applicant_str)[:30]
                    })
        
        patent_data[parent_key] = parent_patents[:100]  # 最大100件
        
        # 子ノード用のデータも追加
        for child_name, child_count in hierarchy_data.get(parent, {}).items():
            child_key = child_name
            child_patents = []
            
            for _, row in df.iterrows():
                # 親と子両方に該当する案件
                if parent_col == 'year':
                    parent_match = str(row.get('year', '')) == parent
                else:
                    parent_match = parent in [str(p) for p in row.get(parent_col, [])]
                
                if child_col == 'year':
                    child_match = str(row.get('year', '')) == child_name
                else:
                    child_match = child_name in [str(c)[:20] if child_col == 'applicant_list' else str(c)[:4] for c in row.get(child_col, [])]
                
                if parent_match and child_match:
                    applicant_str = ''
                    if app_col:
                        app_list = row.get('applicant_list', [])
                        applicant_str = app_list[0] if app_list else ''
                    child_patents.append({
                        "app_number": str(row.get(appno_col, ''))[:20] if appno_col else '',
                        "title": str(row.get(title_col, ''))[:80] if title_col else '',
                        "year": str(row.get('year', '')),
                        "applicant": str(applicant_str)[:30]
                    })
            
            if child_patents:
                patent_data[child_key] = child_patents[:100]
    
    # JavaScriptに案件データを渡す
    window.circlePackPatents = window.JSON.parse(json.dumps(patent_data))
    
    # D3.jsでサークルパッキングを描画
    window.drawCirclePacking("circle-chart", json.dumps(root_data))

# =====================================================
# MEGA - TF-IDF詳細
# =====================================================
@ensure_data('tfidf-result')
@ensure_tfidf('tfidf-result')
def show_tfidf_detail(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    company = document.getElementById('tfidf-company').value
    if not company or company == '(未選択)':
        UIHelper.warn_html('tfidf-result', '企業を選択してください')
        return
    
    df = g_df_processed
    
    mask = df['applicant_list'].apply(lambda x: company in x if x else False)
    company_indices = np.where(mask)[0]
    
    if len(company_indices) == 0:
        UIHelper.warn_html('tfidf-result', '該当データがありません')
        return
    
    # 企業全体のTF-IDF平均
    company_tfidf = g_tfidf_matrix[company_indices].mean(axis=0).A1
    
    # 全体平均との差分で特徴語抽出
    overall_tfidf = np.array(g_tfidf_matrix.mean(axis=0)).flatten()
    diff = company_tfidf - overall_tfidf
    
    top_indices = np.argsort(diff)[::-1][:20]
    
    company_escaped = escape_html(str(company))
    result_html = f'''
        <div class="status-ok">📊 {company_escaped} の特徴語分析（{len(company_indices)}件）</div>
        <table class="data-table" style="margin-top: 0.5rem;">
            <tr><th>キーワード</th><th>スコア</th><th>全体比</th></tr>
    '''
    
    for i in top_indices:
        word = escape_html(str(g_feature_names[i]))
        score = float(company_tfidf[i])
        ratio = score / (overall_tfidf[i] + 0.0001)
        bar_width = min(100, ratio * 20)
        result_html += f'''<tr>
            <td>{word}</td>
            <td>{score:.3f}</td>
            <td><div style="background:#4fc3f7; height:8px; width:{bar_width}%; border-radius:3px;"></div> {ratio:.1f}x</td>
        </tr>'''
    
    result_html += '</table>'
    document.getElementById('tfidf-result').innerHTML = result_html

# =====================================================
# MEGA - 戦略マトリクス (CAGR×シェア)
# =====================================================
@ensure_data('strategy-chart', 'データがありません')
def show_strategy_matrix(event):
    global g_df_processed
    
    df = g_df_processed
    n_companies = int(document.getElementById('strategy-companies').value)
    base_year = int(document.getElementById('strategy-base-year').value)
    size_mode = document.getElementById('strategy-size').value
    
    # 出願人ごとの年別件数を集計
    exp = df.explode('applicant_list')
    exp = exp[exp['applicant_list'].notna() & (exp['applicant_list'] != '')]
    
    # TOP出願人を抽出
    top_apps = exp['applicant_list'].value_counts().head(n_companies).index.tolist()
    exp = exp[exp['applicant_list'].isin(top_apps)]
    
    # 年別件数
    yearly = exp.groupby(['applicant_list', 'year']).size().reset_index(name='count')
    
    # 企業のCAGRとシェアを計算
    results = []
    total_count = len(df)
    max_year = int(df['year'].max())
    
    for app in top_apps:
        app_data = yearly[yearly['applicant_list'] == app]
        
        # 総件数
        total = int(app_data['count'].sum())
        
        # シェア
        share = (total / total_count) * 100
        
        # 直近3年件数
        recent = app_data[app_data['year'] >= max_year - 2]['count'].sum()
        
        # CAGR計算（base_year以前 vs 以降）
        old_period = app_data[app_data['year'] < base_year]['count'].sum()
        new_period = app_data[app_data['year'] >= base_year]['count'].sum()
        
        if old_period > 0:
            years_diff = max_year - base_year + 1
            if years_diff > 0 and new_period > 0:
                cagr = ((new_period / old_period) ** (1 / years_diff) - 1) * 100
            else:
                cagr = -50  # 減少
        else:
            cagr = 100 if new_period > 0 else 0  # 新規参入
        
        # CAGRを-100～200に制限
        cagr = max(-100, min(200, cagr))
        
        results.append({
            'name': app,
            'share': share,
            'cagr': cagr,
            'total': total,
            'recent': int(recent)
        })
    
    if not results:
        UIHelper.warn_html('strategy-chart', 'データがありません')
        return
    
    # バブルサイズ
    if size_mode == 'recent':
        sizes = [max(15, r['recent'] * 3) for r in results]
    else:
        sizes = [max(15, r['total'] * 0.5) for r in results]
    
    # 象限を色分
    colors = []
    for r in results:
        if r['cagr'] > 0 and r['share'] > np.median([x['share'] for x in results]):
            colors.append('#81c784')  # 高長・高シェア星        elif r['cagr'] > 0:
            colors.append('#4fc3f7')  # 高長・低シェア問題        elif r['share'] > np.median([x['share'] for x in results]):
            colors.append('#ffb74d')  # 低長・高シェアのなる木        else:
            colors.append('#e57373')  # 低長・低シェア負け犬    
    traces = [{
        "x": [r['share'] for r in results],
        "y": [r['cagr'] for r in results],
        "mode": "markers+text",
        "type": "scatter",
        "text": [truncate_applicant_name(r['name'], 15) for r in results],
        "textposition": "top center",
        "textfont": {"size": 10},
        "marker": {
            "size": sizes,
            "color": colors,
            "opacity": 0.7,
            "line": {"width": 1, "color": "#fff"}
        },
        "hovertemplate": "<b>%{text}</b><br>シェア: %{x:.1f}%<br>成長率: %{y:.1f}%<extra></extra>"
    }]
    
    # 象限線
    med_share = np.median([r['share'] for r in results])
    shapes = [
        {"type": "line", "x0": med_share, "x1": med_share, "y0": -100, "y1": 200, 
         "line": {"color": "rgba(255,255,255,0.3)", "width": 1, "dash": "dot"}},
        {"type": "line", "x0": 0, "x1": max([r['share'] for r in results]) * 1.2, "y0": 0, "y1": 0, 
         "line": {"color": "rgba(255,255,255,0.3)", "width": 1, "dash": "dot"}}
    ]
    
    layout = ChartHelper.create_layout(
        title=f"戦略マトリクス（{base_year}年以降 CAGR×シェア）",
        xaxis={"title": "シェア (%)", "rangemode": "tozero"},
        yaxis={"title": f"成長率 CAGR (%) - {base_year}年基準", "zeroline": True},
        height=600,
        shapes=shapes,
        annotations=[
            {"x": 0.95, "y": 0.95, "xref": "paper", "yref": "paper", "text": "⭐ スター", "showarrow": False, "font": {"color": "#81c784"}},
            {"x": 0.05, "y": 0.95, "xref": "paper", "yref": "paper", "text": "❓ 問題児", "showarrow": False, "font": {"color": "#4fc3f7"}},
            {"x": 0.95, "y": 0.05, "xref": "paper", "yref": "paper", "text": "💰 金のなる木", "showarrow": False, "font": {"color": "#ffb74d"}},
            {"x": 0.05, "y": 0.05, "xref": "paper", "yref": "paper", "text": "🐕 負け犬", "showarrow": False, "font": {"color": "#e57373"}}
        ]
    )
    
    ChartHelper.draw("strategy-chart", traces, layout)
    
    # サマリー
    summary_html = '<h4>ポジション分析</h4><table class="data-table"><tr><th>出願人</th><th>シェア</th><th>成長率</th><th>ポジション</th></tr>'
    for r in results:
        if r['cagr'] > 0 and r['share'] > med_share:
            pos = '⭁Eスター'
        elif r['cagr'] > 0:
            pos = '❌ 問題'
        elif r['share'] > med_share:
            pos = '💰 金なる木'
        else:
            pos = '🐕 負け犬'
        summary_html += f'<tr><td>{escape_html(truncate_applicant_name(r["name"], 25))}</td><td>{r["share"]:.1f}%</td><td>{r["cagr"]:+.1f}%</td><td>{pos}</td></tr>'
    summary_html += '</table>'
    document.getElementById('strategy-summary').innerHTML = summary_html

# =====================================================
# ツリーマップ
# =====================================================
@ensure_data('treemap-chart')
def show_treemap(event):
    global g_df_processed
    
    df = g_df_processed
    level = document.getElementById('treemap-level').value
    colorscheme = document.getElementById('treemap-color').value
    
    # IPC分類を取得
    ipc_list = df.explode('ipc_list')['ipc_list'].dropna()
    
    # レベルに応じてIPCを切り詰め
    if level == 'section':
        ipc_list = ipc_list.str[:1]  # A, B, C, ...
    elif level == 'class':
        ipc_list = ipc_list.str[:3]  # A01, G06, ...
    else:  # subclass
        ipc_list = ipc_list.str[:4]  # A01B, G06F, ...
    
    counts = ipc_list.value_counts().head(50)
    
    if len(counts) == 0:
        UIHelper.warn_html('treemap-chart', 'IPC分類が見つかりません')
        return
    
    # セクション情報を追加（階層構造用）
    labels = list(counts.index)
    parents = []
    values = list(counts.values)
    
    if level != 'section':
        # 親としてセクションを追加
        sections = set([l[0] for l in labels])
        section_labels = list(sections)
        section_values = [0] * len(section_labels)  # 親の値は0
        section_parents = [''] * len(section_labels)  # ルート
        
        # ラベルの親を設定
        for l in labels:
            parents.append(l[0])  # セクションが親
        
        # セクションを頭に追加
        labels = section_labels + labels
        parents = section_parents + parents
        values = section_values + [int(v) for v in values]
    else:
        parents = [''] * len(labels)
        values = [int(v) for v in values]
    
    traces = [{
        "type": "treemap",
        "labels": labels,
        "parents": parents,
        "values": values,
        "textinfo": "label+value+percent parent",
        "marker": {
            "colors": values,
            "colorscale": colorscheme,
            "line": {"color": "#1b263b", "width": 2}
        },
        "textfont": {"color": "white", "size": 13},
        "hovertemplate": "<b>%{label}</b><br>件数: %{value}<br>割合: %{percentParent:.1%}<extra></extra>"
    }]
    
    layout = ChartHelper.create_layout(
        title=f"IPC分類ツリーマップ（{level.upper()}レベル）",
        height=600,
        margin={"t": 50, "l": 10, "r": 10, "b": 10},
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)"
    )
    ChartHelper.draw("treemap-chart", traces, layout)

# =====================================================
# レーダーチャート
# =====================================================
@ensure_data('radar-chart')
def show_radar(event):
    global g_df_processed
    
    df = g_df_processed
    company1 = document.getElementById('radar-company1').value
    company2 = document.getElementById('radar-company2').value
    axis_type = document.getElementById('radar-axis').value
    
    if not company1:
        UIHelper.warn_html('radar-chart', '企業を選択してください')
        return
    
    # 企業のIPC分布を計算
    def get_ipc_dist(company_name):
        mask = df['applicant_list'].apply(lambda x: company_name in x if x else False)
        subset = df[mask]
        if axis_type == 'section':
            ipcs = subset.explode('ipc_list')['ipc_list'].dropna().str[:1]
        else:
            ipcs = subset.explode('ipc_list')['ipc_list'].dropna().str[:3]
        return ipcs.value_counts()
    
    dist1 = get_ipc_dist(company1)
    
    # dist1が空の場合エラー処理
    if dist1.empty:
        UIHelper.warn_html('radar-chart', '選択した企業のIPCデータがありません')
        return
    
    if axis_type == 'section':
        # すべてのセクション (A-H)
        categories = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
    else:
        # TOP10のIPCクラス（両企業の合計から）
        if company2:
            dist2 = get_ipc_dist(company2)
            combined = (dist1.add(dist2, fill_value=0)).sort_values(ascending=False).head(10)
        else:
            combined = dist1.sort_values(ascending=False).head(10)
        categories = list(combined.index)
    
    # カテゴリが空の場合エラー処理
    if not categories:
        UIHelper.warn_html('radar-chart', '表示するデータがありません')
        return
    
    # 正規化（各企業の最大値を100とする）
    values1 = [float(dist1.get(c, 0)) for c in categories]
    max1 = max(values1) if values1 and max(values1) > 0 else 1
    values1_norm = [v / max1 * 100 for v in values1]
    
    traces = [{
        "type": "scatterpolar",
        "r": values1_norm + [values1_norm[0]],  # 閉じるために最初値を追加
        "theta": categories + [categories[0]],
        "fill": "toself",
        "fillcolor": "rgba(79, 195, 247, 0.3)",
        "line": {"color": "#4fc3f7"},
        "name": truncate_applicant_name(company1, 20)
    }]
    
    if company2:
        dist2 = get_ipc_dist(company2)
        values2 = [float(dist2.get(c, 0)) for c in categories]
        max2 = max(values2) if max(values2) > 0 else 1
        values2_norm = [v / max2 * 100 for v in values2]
        
        traces.append({
            "type": "scatterpolar",
            "r": values2_norm + [values2_norm[0]],
            "theta": categories + [categories[0]],
            "fill": "toself",
            "fillcolor": "rgba(255, 183, 77, 0.3)",
            "line": {"color": "#ffb74d"},
            "name": truncate_applicant_name(company2, 20)
        })
    
    layout = ChartHelper.create_layout(
        title="技術ポートフォリオ比較レーダーチャート",
        height=600,
        polar={
            "radialaxis": {"visible": True, "range": [0, 100]},
            "bgcolor": "rgba(0,0,0,0.1)"
        },
        showlegend=True
    )
    
    ChartHelper.draw("radar-chart", traces, layout)

# =====================================================
# 新D3.js可視化関数
# =====================================================

@ensure_data('sunburst-chart')
def show_sunburst(event):
    """サンバースト図でIPC/FI階層構造を表示"""
    global g_df_processed
    
    df = g_df_processed
    source = document.getElementById('sunburst-source').value
    color_scheme = document.getElementById('sunburst-color').value
    
    # IPC/FI階層データを構築
    if source == 'fi' and 'fi_list' in df.columns:
        all_codes = df.explode('fi_list')['fi_list'].dropna()
    else:
        all_codes = df.explode('ipc_list')['ipc_list'].dropna()
    
    # 階層構造を構築
    hierarchy = {"name": "IPC", "children": []}
    section_map = {}
    
    for code in all_codes:
        if len(code) < 4:
            continue
        section = code[0]  # A, B, C...
        cls = code[:3]     # A01, G06...
        subclass = code[:4] if len(code) >= 4 else cls  # A01B, G06F...
        
        if section not in section_map:
            section_map[section] = {"name": section, "children": []}
            hierarchy["children"].append(section_map[section])
        
        sec_children = section_map[section]["children"]
        cls_node = next((c for c in sec_children if c["name"] == cls), None)
        if cls_node is None:
            cls_node = {"name": cls, "children": []}
            sec_children.append(cls_node)
        
        sub_node = next((c for c in cls_node["children"] if c["name"] == subclass), None)
        if sub_node is None:
            sub_node = {"name": subclass, "value": 0}
            cls_node["children"].append(sub_node)
        sub_node["value"] = sub_node.get("value", 0) + 1
    
    # 空のchildrenを持つノードを修正
    def fix_empty_children(node):
        if "children" in node:
            if len(node["children"]) == 0:
                del node["children"]
                node["value"] = 1
            else:
                for child in node["children"]:
                    fix_empty_children(child)
    
    fix_empty_children(hierarchy)
    
    window.drawSunburst("sunburst-chart", json.dumps(hierarchy), color_scheme)

@ensure_data('chord-chart')
def show_chord(event):
    """コード図（共起関係）を表示"""
    global g_df_processed
    
    df = g_df_processed
    chord_type = document.getElementById('chord-type').value
    top_n = int(document.getElementById('chord-count').value)
    
    # 対象リスト取得
    if chord_type == 'inventor':
        col = 'inventor_list'
    elif chord_type == 'ipc':
        col = 'ipc_list'
    else:
        col = 'applicant_list'
    
    # TOP Nを取得
    all_items = df.explode(col)[col].dropna()
    top_items = all_items.value_counts().head(top_n).index.tolist()
    
    # 共起マトリクスを構築
    n = len(top_items)
    item_to_idx = {item: i for i, item in enumerate(top_items)}
    matrix = [[0] * n for _ in range(n)]
    
    for _, row in df.iterrows():
        items = row.get(col, [])
        if not isinstance(items, list):
            continue
        filtered = [it for it in items if it in item_to_idx]
        for i in range(len(filtered)):
            for j in range(i + 1, len(filtered)):
                idx_i = item_to_idx[filtered[i]]
                idx_j = item_to_idx[filtered[j]]
                matrix[idx_i][idx_j] += 1
                matrix[idx_j][idx_i] += 1
    
    data = {"names": top_items, "matrix": matrix}
    window.drawChordDiagram("chord-chart", json.dumps(data))

@ensure_data('stream-chart', 'データがありません。まず前処理実行してください。')
def show_streamgraph(event):
    """ストリームグラフを表示"""
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    df = g_df_processed
    stream_type = document.getElementById('stream-type').value
    top_n = int(document.getElementById('stream-count').value)
    
    # 年カラムの確認
    if 'year' not in df.columns:
        UIHelper.warn_html('stream-chart', '年カラムがありません。出願日カラムを設定してください。')
        return
    
    # 有効な年を取得（0より大きい年のみ）
    valid_years = sorted([y for y in df['year'].dropna().unique() if y > 0])
    if len(valid_years) == 0:
        UIHelper.warn_html('stream-chart', '有効な年データがありません。')
        return
    
    # キーワード分析の場合TF-IDFを使用
    if stream_type == 'keyword':
        if g_tfidf_matrix is None or g_feature_names is None or len(g_feature_names) == 0:
            UIHelper.warn_html('stream-chart', 'TF-IDF行列がありません。前処理を実行してください。')
            return
        
        # 全体でのTOP Nキーワードを取得
        sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
        top_indices = np.argsort(sums)[::-1][:top_n]
        top_items = [g_feature_names[i] for i in top_indices]
        
        # 年別集計
        series = []
        for year in valid_years:
            year_mask = df['year'] == year
            row = {"year": int(year)}
            
            # その年のドキュメントTF-IDF値を集計
            year_indices = df[year_mask].index.tolist()
            if len(year_indices) > 0:
                # tokenizedカラムでキーワード出現をカウント
                for kw in top_items:
                    count = 0
                    for idx in year_indices:
                        if idx < len(df):
                            text = str(df.iloc[idx].get('tokenized', ''))
                            if kw in text.split():
                                count += 1
                    row[kw] = count
            else:
                for kw in top_items:
                    row[kw] = 0
            series.append(row)
    else:
        # 出願人またはIPCの場合
        col = 'applicant_list' if stream_type == 'applicant' else 'ipc_list'
        
        # カラム存在チェック
        if col not in df.columns:
            document.getElementById('stream-chart').innerHTML = f'<div class="status-warn">カラム「{col}」が見つかりません。</div>'
            return
        
        # TOP Nを取得
        try:
            all_items = df[col].explode().dropna()
            if len(all_items) == 0:
                UIHelper.warn_html('stream-chart', '分析対象のデータがありません。')
                return
            top_items = all_items.value_counts().head(top_n).index.tolist()
        except Exception as e:
            document.getElementById('stream-chart').innerHTML = f'<div class="status-err">データ取得エラー: {escape_html(str(e))}</div>'
            return
        
        # 年別集計
        series = []
        for year in valid_years:
            year_df = df[df['year'] == year]
            row = {"year": int(year)}
            # 年別にexplodeしてカウントを取得
            year_exploded = year_df[col].explode().dropna()
            year_counts = year_exploded.value_counts()
            for item in top_items:
                count = year_counts.get(item, 0)
                row[item] = int(count)
            series.append(row)
    
    # 空データチェック
    if len(series) == 0 or len(top_items) == 0:
        UIHelper.warn_html('stream-chart', '表示するデータがありません')
        return
    
    data = {"keys": top_items, "series": series}
    window.drawStreamgraph("stream-chart", json.dumps(data))

@ensure_data('dendro-chart')
def show_dendrogram(event):
    """デンドログラムで階層クラスタリングを表示"""
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    target = document.getElementById('dendro-target').value
    top_n = int(document.getElementById('dendro-count').value)
    method = document.getElementById('dendro-method').value
    
    df = g_df_processed
    
    # 対象データを取得
    if target == 'keyword':
        if g_tfidf_matrix is None:
            return
        # キーワード上位を取得（共起パターンでクラスタリング）
        sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
        top_indices = np.argsort(sums)[::-1][:top_n]
        names = [g_feature_names[i] for i in top_indices]
        hierarchy = build_simple_hierarchy(names)
    else:
        # 出願人を技術ポートフォリオの類似度でクラスタリング
        top_items = df.explode('applicant_list')['applicant_list'].value_counts().head(top_n).index.tolist()
        hierarchy = build_simple_hierarchy(top_items)
    
    window.drawDendrogram("dendro-chart", json.dumps(hierarchy))

def build_simple_hierarchy(items):
    """アイテムリストから簡易的な階層構造を構築"""
    if len(items) <= 2:
        return {"name": "root", "children": [{"name": it} for it in items]}
    
    mid = len(items) // 2
    left_items = items[:mid]
    right_items = items[mid:]
    
    return {
        "name": "",
        "children": [
            build_simple_hierarchy(left_items) if len(left_items) > 1 else {"name": left_items[0]},
            build_simple_hierarchy(right_items) if len(right_items) > 1 else {"name": right_items[0]}
        ]
    }

# =====================================================
# エクスポート機能
# =====================================================
@ensure_data('export-result', 'データがありません')
def export_summary(event):
    global g_df_processed
    
    df = g_df_processed
    
    summary = f"""=== ARTEMIS 分析サマリー ===
総件数: {len(df):,}
期間: {df['year'].min()} - {df['year'].max()}
出願人数: {df.explode('applicant_list')['applicant_list'].nunique():,}
IPC数: {df.explode('ipc_list')['ipc_list'].nunique():,}
発明者: {df.explode('inventor_list')['inventor_list'].nunique():,}

--- TOP5 出願人 ---
"""
    top_apps = df.explode('applicant_list')['applicant_list'].value_counts().head(5)
    for app, cnt in top_apps.items():
        summary += f"{app}: {cnt}件\n"
    summary += "\n--- TOP5 IPC ---\n"
    top_ipcs = df.explode('ipc_list')['ipc_list'].value_counts().head(5)
    for ipc, cnt in top_ipcs.items():
        summary += f"{ipc}: {cnt}件\n"
    # クリップボードにコピー
    from js import navigator
    navigator.clipboard.writeText(summary)
    
    document.getElementById('export-result').innerHTML = '<div class="status-ok">📋 クリップボードにコピーしました</div>'

@ensure_tfidf('export-result')
def export_keywords(event):
    global g_tfidf_matrix, g_feature_names
    
    sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
    top_indices = np.argsort(sums)[::-1][:50]
    
    keyword_list = "=== TOP50 キーワード ===\n"
    for rank, i in enumerate(top_indices, 1):
        keyword_list += f"{rank}. {g_feature_names[i]} (スコア: {sums[i]:.2f})\n"
    from js import navigator
    navigator.clipboard.writeText(keyword_list)
    
    document.getElementById('export-result').innerHTML = '<div class="status-ok">📋 キーワードリストをコピーしました</div>'

# =====================================================
# VOYAGER - 自動レポート生成
# =====================================================
@ensure_data('export-result', 'データがありません')
def generate_report(event):
    global g_df_processed, g_tfidf_matrix, g_feature_names
    
    df = g_df_processed
    
    # 基本統計
    total = len(df)
    year_min = int(df['year'].min()) if df['year'].min() > 0 else '不明'
    year_max = int(df['year'].max()) if df['year'].max() > 0 else '不明'
    
    # 出願人分析
    exp_apps = df.explode('applicant_list')['applicant_list']
    n_applicants = exp_apps.nunique()
    top_apps = exp_apps.value_counts().head(10)
    
    # IPC分析
    exp_ipc = df.explode('ipc_list')['ipc_list']
    n_ipcs = exp_ipc.nunique()
    top_ipcs = exp_ipc.value_counts().head(5)
    
    # 発明者分析
    exp_inv = df.explode('inventor_list')['inventor_list']
    n_inventors = exp_inv.nunique()
    
    # 年別トレンド
    yearly = df['year'].value_counts().sort_index()
    yearly = yearly[yearly.index > 0]
    if len(yearly) >= 3:
        recent_3y = yearly.tail(3).sum()
        prev_3y = yearly.iloc[-6:-3].sum() if len(yearly) >= 6 else yearly.head(3).sum()
        trend_pct = ((recent_3y - prev_3y) / prev_3y * 100) if prev_3y > 0 else 0
        trend_text = f"増加傾向(+{trend_pct:.0f}%)" if trend_pct > 10 else f"減少傾向({trend_pct:.0f}%)" if trend_pct < -10 else "横ばい"
    else:
        trend_text = "データ不足"
    
    # キーワード
    if g_tfidf_matrix is not None and g_feature_names:
        sums = np.array(g_tfidf_matrix.sum(axis=0)).flatten()
        top_kw_idx = np.argsort(sums)[::-1][:10]
        top_keywords = [g_feature_names[i] for i in top_kw_idx]
    else:
        top_keywords = ['(未分類)']
    
    # レポート生成
    report = f"""══════════════════════════════════════════════════════════════
                    ARTEMIS 特許分析レポート
══════════════════════════════════════════════════════════════

■ 分析概要:
───────────────────────────────────────────────────────────────
  分析対象期間: {year_min} 年 〜 {year_max} 年
  総件数: {total:,} 件
  出願人数: {n_applicants:,} 社
  発明者数: {n_inventors:,} 名
  IPC分類数: {n_ipcs:,} 種類
  出願トレンド: {trend_text}

■ 主要出願人 TOP10
───────────────────────────────────────────────────────────────
"""
    for i, (app, cnt) in enumerate(top_apps.items(), 1):
        share = (cnt / total) * 100
        report += f"  {i:2d}. {app[:35]:<35} {cnt:>5}件 ({share:>5.1f}%)\n"
    report += f"""
■ 技術分野 (IPC TOP5)
───────────────────────────────────────────────────────────────
"""
    for i, (ipc, cnt) in enumerate(top_ipcs.items(), 1):
        report += f"  {i}. {ipc}: {cnt}件\n"
    report += f"""
■ 注目キーワード TOP10
───────────────────────────────────────────────────────────────
  {', '.join(top_keywords)}

■ 年別出願推移
───────────────────────────────────────────────────────────────
"""
    for year, cnt in yearly.tail(10).items():
        bar = '▓' * min(50, int(cnt / yearly.max() * 50))
        report += f"  {int(year)}: {bar} {cnt}件\n"
    report += f"""
══════════════════════════════════════════════════════════════
  Generated by ARTEMIS (Apollo PyScript Edition)
  Analysis Date: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M')}
══════════════════════════════════════════════════════════════"""
    document.getElementById('report-output').style.display = 'block'
    document.getElementById('report-text').value = report
    document.getElementById('export-result').innerHTML = '<div class="status-ok">📝 レポートを生成しました</div>'

@ensure_data('export-result', 'データがありません')
def export_all_data(event):
    global g_df_processed
    
    # CSVデータを生成
    csv_data = g_df_processed.to_csv(index=False)
    
    from js import navigator
    navigator.clipboard.writeText(csv_data)
    
    document.getElementById('export-result').innerHTML = '<div class="status-ok">📦 全データをクリップボードにコピーしました</div>'

@ensure_data('data-preview')
def show_data_preview(event=None):
    global g_df_processed, g_col_map
    
    df = g_df_processed
    title_col = g_col_map.get('title', df.columns[0])
    if title_col == '(未選択)': title_col = df.columns[0]
    
    result_html = '<table class="data-table"><tr><th>#</th><th>年</th><th>タイトル</th><th>出願人</th></tr>'
    for i, (_, row) in enumerate(df.head(20).iterrows(), 1):
        apps = row.get('applicant_list', [])
        app_str = escape_html(str(apps[0])[:20]) if apps else '-'
        title = escape_html(str(row.get(title_col, ''))[:40])
        result_html += f'<tr><td>{i}</td><td>{row.get("year", "-")}</td><td>{title}</td><td>{app_str}</td></tr>'
    result_html += '</table>'
    document.getElementById('data-preview').innerHTML = result_html

# =====================================================
# イベント登録
# =====================================================
g_proxies.clear()
file_proxy = create_proxy(on_file_change)
launch_proxy = create_proxy(launch_engine)
atlas_proxy = create_proxy(draw_atlas)
core_search_proxy = create_proxy(core_search)
core_ai_proxy = create_proxy(core_ai_generate)
core_import_proxy = create_proxy(core_import_json)
core_run_proxy = create_proxy(core_run_classification)
core_reanalyze_proxy = create_proxy(core_reanalyze)
core_map_proxy = create_proxy(core_draw_map)
core_add_proxy = create_proxy(core_add_rule)
core_delete_proxy = create_proxy(core_delete_rule)
core_update_proxy = create_proxy(core_update_rule)
core_edit_proxy = create_proxy(core_edit_rule)
core_cancel_proxy = create_proxy(core_cancel_edit)
g_proxies.extend([file_proxy, launch_proxy, atlas_proxy, core_search_proxy, core_ai_proxy, core_import_proxy, core_run_proxy, core_reanalyze_proxy, core_map_proxy, core_add_proxy, core_delete_proxy, core_update_proxy, core_edit_proxy, core_cancel_proxy])

document.getElementById('file-input').addEventListener('change', file_proxy)
document.getElementById('btn-launch').addEventListener('click', launch_proxy)
document.getElementById('btn-atlas').addEventListener('click', atlas_proxy)
document.getElementById('use-status-breakdown').addEventListener('change', atlas_proxy)
document.getElementById('btn-core-search').addEventListener('click', core_search_proxy)
document.getElementById('btn-core-ai').addEventListener('click', core_ai_proxy)
document.getElementById('btn-core-import').addEventListener('click', core_import_proxy)
document.getElementById('btn-core-add').addEventListener('click', core_add_proxy)
document.getElementById('btn-core-update').addEventListener('click', core_update_proxy)
document.getElementById('btn-core-cancel').addEventListener('click', core_cancel_proxy)
document.getElementById('btn-core-run').addEventListener('click', core_run_proxy)
document.getElementById('btn-core-reanalyze').addEventListener('click', core_reanalyze_proxy)
document.getElementById('btn-core-map').addEventListener('click', core_map_proxy)

# JavaScript連携用のコールバックを登録
window.pyodide_globals.core_delete_rule = core_delete_proxy
window.pyodide_globals.core_edit_rule = core_edit_proxy
window.pyodide_globals.update_core_axis_selects = update_core_axis_selects
window.pyodide_globals.render_core_rules = render_core_rules
window.pyodide_globals.finish_heavy_init = finish_heavy_init

# 残りのモジュールイベントハンドラーを登録
document.getElementById('btn-saturn').addEventListener('click', create_proxy(run_saturn))
document.getElementById('btn-keyword').addEventListener('click', create_proxy(show_keywords))
document.getElementById('btn-trend').addEventListener('click', create_proxy(show_trend))
document.getElementById('btn-compare').addEventListener('click', create_proxy(compare_companies))
document.getElementById('btn-heatmap').addEventListener('click', create_proxy(show_heatmap))
document.getElementById('btn-emerging').addEventListener('click', create_proxy(show_emerging))
document.getElementById('btn-kwic').addEventListener('click', create_proxy(kwic_search))
document.getElementById('btn-network').addEventListener('click', create_proxy(build_network))
document.getElementById('btn-wordcloud').addEventListener('click', create_proxy(show_wordcloud))
document.getElementById('btn-ngram').addEventListener('click', create_proxy(show_ngram))
document.getElementById('btn-cooccur').addEventListener('click', create_proxy(show_cooccurrence))
document.getElementById('btn-tfidf').addEventListener('click', create_proxy(show_tfidf_detail))
document.getElementById('btn-export-summary').addEventListener('click', create_proxy(export_summary))
document.getElementById('btn-export-keywords').addEventListener('click', create_proxy(export_keywords))
document.getElementById('btn-strategy').addEventListener('click', create_proxy(show_strategy_matrix))
document.getElementById('btn-generate-report').addEventListener('click', create_proxy(generate_report))
document.getElementById('btn-export-all').addEventListener('click', create_proxy(export_all_data))
document.getElementById('btn-treemap').addEventListener('click', create_proxy(show_treemap))
document.getElementById('btn-sankey').addEventListener('click', create_proxy(show_sankey))
document.getElementById('btn-radar').addEventListener('click', create_proxy(show_radar))
document.getElementById('btn-circle-pack').addEventListener('click', create_proxy(show_circle_packing))
document.getElementById('btn-sunburst').addEventListener('click', create_proxy(show_sunburst))
document.getElementById('btn-chord').addEventListener('click', create_proxy(show_chord))
document.getElementById('btn-stream').addEventListener('click', create_proxy(show_streamgraph))
document.getElementById('btn-dendro').addEventListener('click', create_proxy(show_dendrogram))

# バブルレースのPython関数をJavaScriptから呼び出せるように登録
window.pyShowBubbleRace = create_proxy(show_bubble_race)

# ============================================================
# 初期化完了
# ============================================================

# 読み込みオーバーレイを非表示にする
document.getElementById('init-overlay').style.display = 'none'
debugLog('[ARTEMIS] Pythonエンジンの初期化が完了しました')

# JavaScriptにPythonの準備完了通知
try:
    import js
    window.setPyReady(True)
except Exception:
    pass
    </script>

    <!-- クレジットフッター -->
    <footer id="credit-footer" style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, rgba(10, 15, 26, 0.95), rgba(10, 15, 26, 0.8));
        backdrop-filter: blur(4px);
        padding: 6px 16px;
        font-size: 11px;
        color: #64748b;
        text-align: center;
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        z-index: 100;
        pointer-events: auto;
    ">
        <span style="opacity: 0.8;">
            ARTEMIS © 2026 Hajime Kumami | Based on 
            <a href="https://github.com/shibayamalicht/apollo-patent-analysis" 
               target="_blank" 
               rel="noopener noreferrer"
               style="color: #4fc3f7; text-decoration: none; transition: color 0.2s;"
               onmouseover="this.style.color='#81d4fa'"
               onmouseout="this.style.color='#4fc3f7'">APOLLO</a>
            by しばやま | MIT License
        </span>
    </footer>
</body>
</html>